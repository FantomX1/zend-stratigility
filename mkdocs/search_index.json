{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Stratigility\n\n\n\n\nFrom \"Strata\", Latin for \"layer\", and \"agility\".\n\n\n\n\nStratigility is a port of \nSencha Connect\n to PHP. It allows\nyou to build applications out of \nmiddleware\n.",
            "title": "Intro"
        },
        {
            "location": "/intro/#stratigility",
            "text": "From \"Strata\", Latin for \"layer\", and \"agility\".   Stratigility is a port of  Sencha Connect  to PHP. It allows\nyou to build applications out of  middleware .",
            "title": "Stratigility"
        },
        {
            "location": "/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility\n\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you will need an\n  implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nFinalHandler\n for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as long as they implement\nthe PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you will need an\n  implementation of PSR-7; one such package is\n   Diactoros .    zendframework/zend-escaper , used by the  FinalHandler  for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as long as they implement\nthe PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/usage/",
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen();\n\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen();  The above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/middleware/",
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can take the incoming\nrequest, perform actions based on it, and either complete the response or pass delegation on to the\nnext middleware in the queue.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe('/', function ($req, $res, $next) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    return $res->end('Hello world!');\n});\n\n// Another page\n$app->pipe('/foo', function ($req, $res, $next) {\n    return $res->end('FOO!');\n});\n\n$server->listen();\n\n\n\n\nIn the above example, we have two examples of middleware. The first is a landing page, and listens\nat the root path. If the request path is empty or \n/\n, it completes the response. If it is not, it\ndelegates to the next middleware in the stack. The second middleware matches on the path \n/foo\n --\nmeaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that case, it will complete the\nresponse with its own message. If no paths match at this point, a \"final handler\" is composed by\ndefault to report 404 status.\n\n\nSo, concisely put, \nmiddleware are PHP callables that accept a request and response object, and do\nsomething with it\n.\n\n\nMiddleware can decide more processing can be performed by calling the \n$next\n callable that is\npassed as the third argument. With this paradigm, you can build a workflow engine for handling\nrequests -- for instance, you could have middleware perform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware, and can attach to specific paths, allowing you to mix\nand match applications under a common domain. As an example, you could put API middleware next to\nmiddleware that serves its documentation, next to middleware that serves files, and segregate each\nby URI:\n\n\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path segment stripped,\nallowing them to be developed separately and re-used under any path you wish.\n\n\nWithin Stratigility, middleware can be:\n\n\n\n\nAny PHP callable that accepts, minimally, a\n  \nPSR-7\n\n  ServerRequest and Response (in that order), and, optionally, a callable (for invoking the next\n  middleware in the queue, if any).\n\n\nAn object implementing \nZend\\Stratigility\\MiddlewareInterface\n. \nZend\\Stratigility\\MiddlewarePipe\n\n  implements this interface.",
            "title": "Middleware"
        },
        {
            "location": "/middleware/#middleware",
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can take the incoming\nrequest, perform actions based on it, and either complete the response or pass delegation on to the\nnext middleware in the queue.  use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe('/', function ($req, $res, $next) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    return $res->end('Hello world!');\n});\n\n// Another page\n$app->pipe('/foo', function ($req, $res, $next) {\n    return $res->end('FOO!');\n});\n\n$server->listen();  In the above example, we have two examples of middleware. The first is a landing page, and listens\nat the root path. If the request path is empty or  / , it completes the response. If it is not, it\ndelegates to the next middleware in the stack. The second middleware matches on the path  /foo  --\nmeaning it will match  /foo ,  /foo/ , and any path beneath. In that case, it will complete the\nresponse with its own message. If no paths match at this point, a \"final handler\" is composed by\ndefault to report 404 status.  So, concisely put,  middleware are PHP callables that accept a request and response object, and do\nsomething with it .  Middleware can decide more processing can be performed by calling the  $next  callable that is\npassed as the third argument. With this paradigm, you can build a workflow engine for handling\nrequests -- for instance, you could have middleware perform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware, and can attach to specific paths, allowing you to mix\nand match applications under a common domain. As an example, you could put API middleware next to\nmiddleware that serves its documentation, next to middleware that serves files, and segregate each\nby URI:  $app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);  The handlers in each middleware attached this way will see a URI with that path segment stripped,\nallowing them to be developed separately and re-used under any path you wish.  Within Stratigility, middleware can be:   Any PHP callable that accepts, minimally, a\n   PSR-7 \n  ServerRequest and Response (in that order), and, optionally, a callable (for invoking the next\n  middleware in the queue, if any).  An object implementing  Zend\\Stratigility\\MiddlewareInterface .  Zend\\Stratigility\\MiddlewarePipe \n  implements this interface.",
            "title": "Middleware"
        },
        {
            "location": "/error-handlers/",
            "text": "Error Handlers\n\n\nTo handle errors, you can write middleware that accepts \nexactly\n four arguments:\n\n\nfunction ($error, $request, $response, $next) { }\n\n\n\n\nAlternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nWhen using \nMiddlewarePipe\n, as the queue is executed, if \n$next()\n is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call \n$next()\n.\n\nError handlers that call \n$next()\n SHOULD call it with the error it received itself, or with\nanother error.\n\n\nError handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.",
            "title": "Error Handlers"
        },
        {
            "location": "/error-handlers/#error-handlers",
            "text": "To handle errors, you can write middleware that accepts  exactly  four arguments:  function ($error, $request, $response, $next) { }  Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .  When using  MiddlewarePipe , as the queue is executed, if  $next()  is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call  $next() . Error handlers that call  $next()  SHOULD call it with the error it received itself, or with\nanother error.  Error handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.",
            "title": "Error Handlers"
        },
        {
            "location": "/creating-middleware/",
            "text": "Creating Middleware\n\n\nTo create middleware, write a callable capable of receiving minimally PSR-7 ServerRequest and Response\nobjects, and optionally a callback to call the next in the chain.  In your middleware, you can handle\nas much or as little of the request as you want, including delegating to other middleware. If your\nmiddleware accepts a third argument, \n$next\n, it can allow further processing or return handling to\nthe parent middleware by calling it.\n\n\nAs an example, consider the following middleware which will use an external router to map the\nincoming request path to a handler; if unable to map the request, it returns processing to the next\nmiddleware.\n\n\nfunction ($req, $res, $next) use ($router) {\n    $path = $req->getUri()->getPath();\n\n    // Route the path\n    $route = $router->route($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route->getHandler();\n    return $handler($req, $res, $next);\n}\n\n\n\n\nMiddleware written in this way can be any of the following:\n\n\n\n\nClosures (as shown above)\n\n\nFunctions\n\n\nStatic class methods\n\n\nPHP array callbacks (e.g., \n[ $dispatcher, 'dispatch' ]\n, where \n$dispatcher\n is a class instance)\n\n\nInvokable PHP objects (i.e., instances of classes implementing \n__invoke()\n)\n\n\nObjects implementing \nZend\\Stratigility\\MiddlewareInterface\n (including\n  \nZend\\Stratigility\\MiddlewarePipe\n)\n\n\n\n\nIn all cases, if you wish to implement typehinting, the signature is:\n\n\nfunction (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next = null\n) : Psr\\Http\\Message\\ResponseInterface\n\n\n\n\nThe implementation Stratigility offers also allows you to write specialized error handler\nmiddleware. The signature is the same as for normal middleware, except that it expects an additional\nargument prepended to the signature, \n$error\n.  (Alternately, you can implement\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n.) The signature is:\n\n\nfunction (\n    $error, // Can be any type\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Creating Middleware"
        },
        {
            "location": "/creating-middleware/#creating-middleware",
            "text": "To create middleware, write a callable capable of receiving minimally PSR-7 ServerRequest and Response\nobjects, and optionally a callback to call the next in the chain.  In your middleware, you can handle\nas much or as little of the request as you want, including delegating to other middleware. If your\nmiddleware accepts a third argument,  $next , it can allow further processing or return handling to\nthe parent middleware by calling it.  As an example, consider the following middleware which will use an external router to map the\nincoming request path to a handler; if unable to map the request, it returns processing to the next\nmiddleware.  function ($req, $res, $next) use ($router) {\n    $path = $req->getUri()->getPath();\n\n    // Route the path\n    $route = $router->route($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route->getHandler();\n    return $handler($req, $res, $next);\n}  Middleware written in this way can be any of the following:   Closures (as shown above)  Functions  Static class methods  PHP array callbacks (e.g.,  [ $dispatcher, 'dispatch' ] , where  $dispatcher  is a class instance)  Invokable PHP objects (i.e., instances of classes implementing  __invoke() )  Objects implementing  Zend\\Stratigility\\MiddlewareInterface  (including\n   Zend\\Stratigility\\MiddlewarePipe )   In all cases, if you wish to implement typehinting, the signature is:  function (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next = null\n) : Psr\\Http\\Message\\ResponseInterface  The implementation Stratigility offers also allows you to write specialized error handler\nmiddleware. The signature is the same as for normal middleware, except that it expects an additional\nargument prepended to the signature,  $error .  (Alternately, you can implement Zend\\Stratigility\\ErrorMiddlewareInterface .) The signature is:  function (\n    $error, // Can be any type\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Creating Middleware"
        },
        {
            "location": "/executing-middleware/",
            "text": "Executing and composing middleware\n\n\nThe easiest way to execute middleware is to write closures and attach them to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest \nMiddlewarePipe\n instances to create\ngroups of related middleware, and attach them using a base path so they only execute if that path is\nmatched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"\n\n\n\n\nAnother approach is to extend the \nZend\\Stratigility\\MiddlewarePipe\n class itself, particularly if\nyou want to allow attaching other middleware to your own middleware. In such a case, you will\ngenerally override the \n__invoke()\n method to perform any additional logic you have, and then call\non the parent in order to iterate through your stack of middleware:\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __invoke(Request $request, Response $response, callable $next = null)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::__invoke($request, $response, $next);\n\n        // maybe do more work?\n    }\n}\n\n\n\n\nAnother approach using this method would be to override the constructor to add in specific\nmiddleware, perhaps using configuration provided. In this case, make sure to also call\n\nparent::__construct()\n to ensure the middleware queue is initialized; we recommend doing this as the\nfirst action of the method.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}\n\n\n\n\nThese approaches are particularly suited for cases where you may want to implement a specific\nworkflow for an application segment using existing middleware, but do not necessarily want that\nmiddleware applied to all requests in the application.",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/executing-middleware/#executing-and-composing-middleware",
            "text": "The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe  instance. You can nest  MiddlewarePipe  instances to create\ngroups of related middleware, and attach them using a base path so they only execute if that path is\nmatched.  $api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"  Another approach is to extend the  Zend\\Stratigility\\MiddlewarePipe  class itself, particularly if\nyou want to allow attaching other middleware to your own middleware. In such a case, you will\ngenerally override the  __invoke()  method to perform any additional logic you have, and then call\non the parent in order to iterate through your stack of middleware:  use Zend\\Stratigility\\MiddlewarePipe;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __invoke(Request $request, Response $response, callable $next = null)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::__invoke($request, $response, $next);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add in specific\nmiddleware, perhaps using configuration provided. In this case, make sure to also call parent::__construct()  to ensure the middleware queue is initialized; we recommend doing this as the\nfirst action of the method.  use Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}  These approaches are particularly suited for cases where you may want to implement a specific\nworkflow for an application segment using existing middleware, but do not necessarily want that\nmiddleware applied to all requests in the application.",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/api/",
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and has been discussed\npreviously. Its API is:\n\n\nclass MiddlewarePipe implements MiddlewareInterface\n{\n    public function pipe(string|callable $path, callable $middleware = null);\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request = null,\n        Psr\\Http\\Message\\ResponseInterface $response = null,\n        callable $out = null\n    ) :  Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\n\npipe()\n takes up to two arguments. If only one argument is provided, \n$middleware\n will be assigned\nthat value, and \n$path\n will be re-assigned to the value \n/\n; this is an indication that the\n\n$middleware\n should be invoked for any path. If \n$path\n is provided, the \n$middleware\n will only be\nexecuted for that path and any subpaths.\n\n\nMiddleware is executed in the order in which it is piped to the \nMiddlewarePipe\n instance.\n\n\n__invoke()\n is itself middleware. If \n$out\n is not provided, an instance of\n\nZend\\Stratigility\\FinalHandler\n will be created, and used in the event that the pipe stack is\nexhausted (\nMiddlewarePipe\n passes the \n$response\n instance it receives to \nFinalHandler\n as well,\nso that the latter can determine if the response it receives is new).\n\n\nThe callable should use the same signature as \nNext()\n:\n\n\nfunction (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    $err = null\n) : Psr\\Http\\Message\\ResponseInterface\n\n\n\n\nInternally, \nMiddlewarePipe\n creates an instance of \nZend\\Stratigility\\Next\n, feeding it its queue,\nexecutes it, and returns a response.\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail of middleware, and exists to allow\ndelegating to middleware registered later in the stack. It is implemented as a functor.\n\n\nBecause \nPsr\\Http\\Message\n's interfaces are immutable, if you make changes to your Request and/or\nResponse instances, you will have new instances, and will need to make these known to the next\nmiddleware in the chain. \nNext\n expects these arguments for every invocation. Additionally, if an\nerror condition has occurred, you may pass an optional third argument, \n$err\n, representing the\nerror condition.\n\n\nclass Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response,\n        $err = null\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\n\nYou should \nalways\n either capture or return the return value of \n$next()\n when calling it in your\napplication. The expected return value is a response instance, but if it is not, you may want to\nreturn the response provided to you.\n\n\nAs examples:\n\n\nProviding an altered request:\n\n\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n\n\n\nProviding an altered response:\n\n\nfunction ($request, $response, $next)\n{\n    $updated = $response->addHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $next($request, $updated);\n}\n\n\n\n\nProviding both an altered request and response:\n\n\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $updated = $response->addHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $next(\n        $request->withBodyParams($bodyParser($request)),\n        $updated\n    );\n}\n\n\n\n\nReturning a response to complete the request\n\n\nIf you have no changes to the response, and do not want further middleware in the pipeline to\nexecute, do not call \n$next()\n and simply return from your middleware. However, it's almost always\nbetter and more predictable to return the response instance, as this will ensure it propagates back\nup to all callers.\n\n\nfunction ($request, $response, $next)\n{\n    $response = $response->addHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n\n\n\nOne caveat: if you are in a nested middleware or not the first in the stack, all parent and/or\nprevious middleware must also call \nreturn $next(/* ... */)\n for this to work correctly.\n\n\nAs such, \nwe recommend always returning \n$next()\n when invoking it in your middleware\n:\n\n\nreturn $next(/* ... */);\n\n\n\n\nAnd, if not calling \n$next()\n, returning the response instance:\n\n\nreturn $response;\n\n\n\n\nThe \nFinalHandler\n implementation will check the \n$response\n instance passed when invoking it\nagainst the instance passed during instantiation, and, if different, return it. As such, \nreturn\n$next(/* ... */)\n is the recommended workflow.\n\n\nRaising an error condition\n\n\nTo raise an error condition, pass a non-null value as the third argument to \n$next()\n:\n\n\nfunction ($request, $response, $next)\n{\n    try {\n        // try some operation...\n    } catch (Exception $e) {\n        return $next($request, $response, $e); // Next registered error middleware will be invoked\n    }\n}\n\n\n\n\nFinalHandler\n\n\nZend\\Stratigility\\FinalHandler\n is a default implementation of middleware to execute when the stack\nexhausts itself. It expects three arguments when invoked: a request instance, a response instance,\nand an error condition (or \nnull\n for no error). It returns a response.\n\n\nFinalHandler\n allows two optional arguments during instantiation\n\n\n\n\n$options\n, an array of options with which to configure itself. These options currently include:\n\n\nenv\n, the application environment. If set to \"production\", no stack traces will be provided.\n\n\nonerror\n, a callable to execute if an error is passed when \nFinalHandler\n is invoked. The\n    callable is invoked with the error (which will be \nnull\n in the absence of an error), the request,\n    and the response, in that order.\n\n\nPsr\\Http\\Message\\ResponseInterface $response\n; if passed, it will compare the response passed\n  during invocation against this instance; if they are different, it will return the response from\n  the invocation, as this indicates that one or more middleware provided a new response instance.\n\n\n\n\nInternally, \nFinalHandler\n does the following on invocation:\n\n\n\n\nIf \n$error\n is non-\nnull\n, it creates an error response from the response provided at invocation,\n  ensuring a 400 or 500 series response is returned.\n\n\nIf the response at invocation matches the response provided at instantiation, it returns it\n  without further changes. This is an indication that some middleware at some point in the execution\n  chain called \n$next()\n with a new response instance.\n\n\nIf the response at invocation does not match the response provided at instantiation, or if no\n  response was provided at instantiation, it creates a 404 response, as the assumption is that no\n  middleware was capable of handling the request.\n\n\n\n\nHTTP Messages\n\n\nZend\\Stratigility\\Http\\Request\n\n\nZend\\Stratigility\\Http\\Request\n acts as a decorator for a \nPsr\\Http\\Message\\ServerRequestInterface\n\ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.\n\n\nAs an example, consider the following:\n\n\n$app1 = new Middleware();\n$app1->pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2->pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);\n\n\n\n\nIn the above, if the URI of the original incoming request is \n/root/foo\n, what \n$fooCallback\n will\nreceive is a URI with a past consisting of only \n/foo\n. This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.\n\n\nIf you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014 \nZend\\Stratigility\\Http\\Request\n contains a method, \ngetOriginalRequest()\n,\nwhich will always return the original request provided to the application:\n\n\nfunction ($request, $response, $next)\n{\n    $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]';\n    $response = $response->setHeader('Location', $location);\n    $response = $response->setStatus(302);\n    return $response;\n}\n\n\n\n\nZend\\Stratigility\\Http\\Response\n\n\nZend\\Stratigility\\Http\\Response\n acts as a decorator for a \nPsr\\Http\\Message\\ResponseInterface\n\ninstance, and also implements \nZend\\Stratigility\\Http\\ResponseInterface\n, which provides the\nfollowing convenience methods:\n\n\n\n\nwrite()\n, which proxies to the \nwrite()\n method of the composed response stream.\n\n\nend()\n, which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the \nwrite()\n method. Once \nend()\n has been called, the response is\n  immutable and will throw an exception if a state mutating method like \nwithHeader\n is called.\n\n\nisComplete()\n indicates whether or not \nend()\n has been called.\n\n\n\n\nAdditionally, it provides access to the original response created by the server via the method\n\ngetOriginalResponse()\n.",
            "title": "API Reference"
        },
        {
            "location": "/api/#api-reference",
            "text": "The following make up the primary API of Stratigility.",
            "title": "API Reference"
        },
        {
            "location": "/api/#middleware",
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and has been discussed\npreviously. Its API is:  class MiddlewarePipe implements MiddlewareInterface\n{\n    public function pipe(string|callable $path, callable $middleware = null);\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request = null,\n        Psr\\Http\\Message\\ResponseInterface $response = null,\n        callable $out = null\n    ) :  Psr\\Http\\Message\\ResponseInterface;\n}  pipe()  takes up to two arguments. If only one argument is provided,  $middleware  will be assigned\nthat value, and  $path  will be re-assigned to the value  / ; this is an indication that the $middleware  should be invoked for any path. If  $path  is provided, the  $middleware  will only be\nexecuted for that path and any subpaths.  Middleware is executed in the order in which it is piped to the  MiddlewarePipe  instance.  __invoke()  is itself middleware. If  $out  is not provided, an instance of Zend\\Stratigility\\FinalHandler  will be created, and used in the event that the pipe stack is\nexhausted ( MiddlewarePipe  passes the  $response  instance it receives to  FinalHandler  as well,\nso that the latter can determine if the response it receives is new).  The callable should use the same signature as  Next() :  function (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    $err = null\n) : Psr\\Http\\Message\\ResponseInterface  Internally,  MiddlewarePipe  creates an instance of  Zend\\Stratigility\\Next , feeding it its queue,\nexecutes it, and returns a response.",
            "title": "Middleware"
        },
        {
            "location": "/api/#next",
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail of middleware, and exists to allow\ndelegating to middleware registered later in the stack. It is implemented as a functor.  Because  Psr\\Http\\Message 's interfaces are immutable, if you make changes to your Request and/or\nResponse instances, you will have new instances, and will need to make these known to the next\nmiddleware in the chain.  Next  expects these arguments for every invocation. Additionally, if an\nerror condition has occurred, you may pass an optional third argument,  $err , representing the\nerror condition.  class Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response,\n        $err = null\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}  You should  always  either capture or return the return value of  $next()  when calling it in your\napplication. The expected return value is a response instance, but if it is not, you may want to\nreturn the response provided to you.  As examples:",
            "title": "Next"
        },
        {
            "location": "/api/#providing-an-altered-request",
            "text": "function ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}",
            "title": "Providing an altered request:"
        },
        {
            "location": "/api/#providing-an-altered-response",
            "text": "function ($request, $response, $next)\n{\n    $updated = $response->addHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $next($request, $updated);\n}",
            "title": "Providing an altered response:"
        },
        {
            "location": "/api/#providing-both-an-altered-request-and-response",
            "text": "function ($request, $response, $next) use ($bodyParser)\n{\n    $updated = $response->addHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $next(\n        $request->withBodyParams($bodyParser($request)),\n        $updated\n    );\n}",
            "title": "Providing both an altered request and response:"
        },
        {
            "location": "/api/#returning-a-response-to-complete-the-request",
            "text": "If you have no changes to the response, and do not want further middleware in the pipeline to\nexecute, do not call  $next()  and simply return from your middleware. However, it's almost always\nbetter and more predictable to return the response instance, as this will ensure it propagates back\nup to all callers.  function ($request, $response, $next)\n{\n    $response = $response->addHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}  One caveat: if you are in a nested middleware or not the first in the stack, all parent and/or\nprevious middleware must also call  return $next(/* ... */)  for this to work correctly.  As such,  we recommend always returning  $next()  when invoking it in your middleware :  return $next(/* ... */);  And, if not calling  $next() , returning the response instance:  return $response;  The  FinalHandler  implementation will check the  $response  instance passed when invoking it\nagainst the instance passed during instantiation, and, if different, return it. As such,  return\n$next(/* ... */)  is the recommended workflow.",
            "title": "Returning a response to complete the request"
        },
        {
            "location": "/api/#raising-an-error-condition",
            "text": "To raise an error condition, pass a non-null value as the third argument to  $next() :  function ($request, $response, $next)\n{\n    try {\n        // try some operation...\n    } catch (Exception $e) {\n        return $next($request, $response, $e); // Next registered error middleware will be invoked\n    }\n}",
            "title": "Raising an error condition"
        },
        {
            "location": "/api/#finalhandler",
            "text": "Zend\\Stratigility\\FinalHandler  is a default implementation of middleware to execute when the stack\nexhausts itself. It expects three arguments when invoked: a request instance, a response instance,\nand an error condition (or  null  for no error). It returns a response.  FinalHandler  allows two optional arguments during instantiation   $options , an array of options with which to configure itself. These options currently include:  env , the application environment. If set to \"production\", no stack traces will be provided.  onerror , a callable to execute if an error is passed when  FinalHandler  is invoked. The\n    callable is invoked with the error (which will be  null  in the absence of an error), the request,\n    and the response, in that order.  Psr\\Http\\Message\\ResponseInterface $response ; if passed, it will compare the response passed\n  during invocation against this instance; if they are different, it will return the response from\n  the invocation, as this indicates that one or more middleware provided a new response instance.   Internally,  FinalHandler  does the following on invocation:   If  $error  is non- null , it creates an error response from the response provided at invocation,\n  ensuring a 400 or 500 series response is returned.  If the response at invocation matches the response provided at instantiation, it returns it\n  without further changes. This is an indication that some middleware at some point in the execution\n  chain called  $next()  with a new response instance.  If the response at invocation does not match the response provided at instantiation, or if no\n  response was provided at instantiation, it creates a 404 response, as the assumption is that no\n  middleware was capable of handling the request.",
            "title": "FinalHandler"
        },
        {
            "location": "/api/#http-messages",
            "text": "",
            "title": "HTTP Messages"
        },
        {
            "location": "/api/#zendstratigilityhttprequest",
            "text": "Zend\\Stratigility\\Http\\Request  acts as a decorator for a  Psr\\Http\\Message\\ServerRequestInterface \ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.  As an example, consider the following:  $app1 = new Middleware();\n$app1->pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2->pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);  In the above, if the URI of the original incoming request is  /root/foo , what  $fooCallback  will\nreceive is a URI with a past consisting of only  /foo . This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.  If you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014  Zend\\Stratigility\\Http\\Request  contains a method,  getOriginalRequest() ,\nwhich will always return the original request provided to the application:  function ($request, $response, $next)\n{\n    $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]';\n    $response = $response->setHeader('Location', $location);\n    $response = $response->setStatus(302);\n    return $response;\n}",
            "title": "Zend\\Stratigility\\Http\\Request"
        },
        {
            "location": "/api/#zendstratigilityhttpresponse",
            "text": "Zend\\Stratigility\\Http\\Response  acts as a decorator for a  Psr\\Http\\Message\\ResponseInterface \ninstance, and also implements  Zend\\Stratigility\\Http\\ResponseInterface , which provides the\nfollowing convenience methods:   write() , which proxies to the  write()  method of the composed response stream.  end() , which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the  write()  method. Once  end()  has been called, the response is\n  immutable and will throw an exception if a state mutating method like  withHeader  is called.  isComplete()  indicates whether or not  end()  has been called.   Additionally, it provides access to the original response created by the server via the method getOriginalResponse() .",
            "title": "Zend\\Stratigility\\Http\\Response"
        }
    ]
}