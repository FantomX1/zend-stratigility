{
    "docs": [
        {
            "location": "/", 
            "text": "../../README.md", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "Stratigility\n\n\n\n\nFrom \"Strata\", Latin for \"layer\", and \"agility\".\n\n\n\n\nStratigility started as a port of \nSencha Connect\n\nto PHP. It allows you to build applications out of \nmiddleware\n.", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#stratigility", 
            "text": "From \"Strata\", Latin for \"layer\", and \"agility\".   Stratigility started as a port of  Sencha Connect \nto PHP. It allows you to build applications out of  middleware .", 
            "title": "Stratigility"
        }, 
        {
            "location": "/install/", 
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility\n\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\nhttp-interop/http-middleware\n,\n  which provides the interfaces that will become PSR-15.\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nErrorHandler\n middleware and the\n  (legacy) \nFinalHandler\n implementation for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.", 
            "title": "Installation and Requirements"
        }, 
        {
            "location": "/install/#installation-and-requirements", 
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n   Diactoros .    http-interop/http-middleware ,\n  which provides the interfaces that will become PSR-15.    zendframework/zend-escaper , used by the  ErrorHandler  middleware and the\n  (legacy)  FinalHandler  implementation for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.", 
            "title": "Installation and Requirements"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server-\nlisten(new NoopFinalHandler());\n\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server- listen(new NoopFinalHandler());  The above example is useless by itself until you pipe middleware into the application.", 
            "title": "Usage"
        }, 
        {
            "location": "/middleware/", 
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app-\npipe('/', function ($req, $res, $next) {\n    if (! in_array($req-\ngetUri()-\ngetPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    $res-\ngetBody()-\nwrite('Hello world!');\n    return $res;\n});\n\n// Another page\n$app-\npipe('/foo', function ($req, $res, $next) {\n    $res-\ngetBody()-\nwrite('FOO!');\n    return $res;\n});\n\n$server-\nlisten();\n\n\n\n\nIn the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or\n\n/\n, it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path \n/foo\n\n\n meaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.\n\n\nSo, concisely put, \nmiddleware are PHP callables that accept a request and\nresponse object, and do something with it\n.\n\n\n\n\nhttp-interop middleware\n\n\nThe above example demonstrates the legacy (pre-1.3.0) signature for\nmiddleware, which is also widely used across other middleware frameworks\nsuch as Slim, Relay, Adroit, etc.\n\n\nhttp-interop is a project attempting to standardize middleware signatures.\nThe signature it uses for server-side middleware is:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface ServerMiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\n\nwhere \nDelegateInterface\n is defined as:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface DelegateInterface\n{\n    public function process(\n        RequestInterface $request\n    ) : ResponseInterface;\n}\n\n\n\n\nStratigility allows you to implement \nServerMiddlewareInterface\n to provide\nmiddleware.  Additionally, you can define \ncallable\n middleware with the\nfollowing signature, and it will be dispatched as http-interop middleware:\n\n\nfunction(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;\n\n\n\n\n(The \n$request\n argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)\n\n\nAs such, the above example can also be written as follows:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\n$app-\npipe('/', function ($request, DelegateInterface $delegate) {\n    if (! in_array($req-\ngetUri()-\ngetPath(), ['/', ''], true)) {\n        return $delegate-\nprocess($req);\n    }\n    return new TextResponse('Hello world!');\n});\n\n\n\n\n\n\nMiddleware can decide more processing can be performed by calling the \n$next\n\ncallable (or, when defining http-interop middleware, \n$delegate\n) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests \n for instance, you could have middleware perform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:\n\n\n$app-\npipe('/api', $apiMiddleware);\n$app-\npipe('/docs', $apiDocMiddleware);\n$app-\npipe('/files', $filesMiddleware);\n\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.\n\n\nWithin Stratigility, middleware can be:\n\n\n\n\nAny PHP callable that accepts, minimally, a\n  \nPSR-7\n\n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).\n\n\nAny \nhttp-interop 0.2.0 - middleware\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements\n  \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n.\n\n\nAn object implementing \nZend\\Stratigility\\MiddlewareInterface\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements this interface.\n  (Legacy; this interface is deprecated starting in 1.3.0.)", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#middleware", 
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.  use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app- pipe('/', function ($req, $res, $next) {\n    if (! in_array($req- getUri()- getPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    $res- getBody()- write('Hello world!');\n    return $res;\n});\n\n// Another page\n$app- pipe('/foo', function ($req, $res, $next) {\n    $res- getBody()- write('FOO!');\n    return $res;\n});\n\n$server- listen();  In the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path  /foo   meaning it will match  /foo ,  /foo/ , and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.  So, concisely put,  middleware are PHP callables that accept a request and\nresponse object, and do something with it .", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#http-interop-middleware", 
            "text": "The above example demonstrates the legacy (pre-1.3.0) signature for\nmiddleware, which is also widely used across other middleware frameworks\nsuch as Slim, Relay, Adroit, etc.  http-interop is a project attempting to standardize middleware signatures.\nThe signature it uses for server-side middleware is:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface ServerMiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  where  DelegateInterface  is defined as:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface DelegateInterface\n{\n    public function process(\n        RequestInterface $request\n    ) : ResponseInterface;\n}  Stratigility allows you to implement  ServerMiddlewareInterface  to provide\nmiddleware.  Additionally, you can define  callable  middleware with the\nfollowing signature, and it will be dispatched as http-interop middleware:  function(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;  (The  $request  argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)  As such, the above example can also be written as follows:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\n$app- pipe('/', function ($request, DelegateInterface $delegate) {\n    if (! in_array($req- getUri()- getPath(), ['/', ''], true)) {\n        return $delegate- process($req);\n    }\n    return new TextResponse('Hello world!');\n});   Middleware can decide more processing can be performed by calling the  $next \ncallable (or, when defining http-interop middleware,  $delegate ) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests   for instance, you could have middleware perform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:  $app- pipe('/api', $apiMiddleware);\n$app- pipe('/docs', $apiDocMiddleware);\n$app- pipe('/files', $filesMiddleware);  The handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.  Within Stratigility, middleware can be:   Any PHP callable that accepts, minimally, a\n   PSR-7 \n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).  Any  http-interop 0.2.0 - middleware .\n   Zend\\Stratigility\\MiddlewarePipe  implements\n   Interop\\Http\\Middleware\\ServerMiddlewareInterface .  An object implementing  Zend\\Stratigility\\MiddlewareInterface .\n   Zend\\Stratigility\\MiddlewarePipe  implements this interface.\n  (Legacy; this interface is deprecated starting in 1.3.0.)", 
            "title": "http-interop middleware"
        }, 
        {
            "location": "/error-handlers/", 
            "text": "Error Handlers\n\n\nIn your application, you may need to handle error conditions:\n\n\n\n\nErrors raised by PHP itself (e.g., inability to open a file or database\n  connection).\n\n\nExceptions/throwables raised by PHP and/or code you write or consume.\n\n\nInability of any middleware to handle a request.\n\n\n\n\nYou can typically handle these conditions via middleware itself.\n\n\nHandling 404 conditions\n\n\n\n\nSince 1.3.0\n\n\n\n\nIf no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition, \nZend\\Stratigility\\Middleware\\NotFoundHandler\n. The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:\n\n\n// setup layers\n$app-\npipe(/* ... */);\n$app-\npipe(/* ... */);\n$app-\npipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\n\nNote that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.\n\n\nIf you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this-\nrenderer = $renderer;\n        $this-\nresponse = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this-\nresponse-\nwithStatus(404);\n        $response-\ngetBody()-\nwrite(\n            $this-\nrenderer-\nrender('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\n\nHandling PHP errors and exceptions\n\n\n\n\nSince 1.3.0\n\n\n\n\n\n\nOpting in to error middleware\n\n\nIf you have upgraded from Expressive 1.0.0, you will have been using the\n\nFinalHandler\n implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in \ntry/catch\n blocks.\n\n\nStarting in 1.3.0, we provide a new way to handle errors via middleware.\n\n\nTo opt-in to the new system, you must call \nraiseThrowables()\n on your\nmiddleware pipeline:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline-\nraiseThrowables();\n\n\n\n\n(Starting in 2.0.0, this will no longer be necessary, but until then, this is\nhow you opt-in to the system described below.)\n\n\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n is a middleware implementation to\nregister as the \noutermost layer\n of your application (or close to the outermost\nlayer). It does the following:\n\n\n\n\nCreates a PHP error handler that catches any errors in the \nerror_handling()\n\n  mask and throws them as \nErrorException\n instances.\n\n\nWraps the invocation of the delegate in a try/catch block:\n\n\nif no exception is caught, and the result is a response, it returns it.\n\n\nif no exception is caught, it raises an exception, which will be caught.\n\n\nany caught exception is transformed into an error response.\n\n\n\n\nTo generate the error response, we provide the ability to inject a callable with\nthe following signature into the \nErrorHandler\n during instantiation:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\n\nWe provide a default implementation, \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n,\nwhich generates an error response with a \n5XX\n series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.\n\n\nIn order to work, the \nErrorHandler\n needs a prototype response instance, and,\noptionally, an error response generator (if none is provided,\n\nErrorResponseGenerator\n is used, in production mode):\n\n\n// setup error handling\n$app-\npipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app-\npipe(/* ... */);\n$app-\npipe(/* ... */);\n\n\n\n\nAs a full example, you can combine the two middleware into the same application\nas separate layers:\n\n\n// setup error handling\n$app-\npipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app-\npipe(/* ... */);\n$app-\npipe(/* ... */);\n\n// setup 404 handling\n$app-\npipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\n\nThe \nErrorResponseGenerator\n provides no templating facilities, and only\nresponds as \ntext/html\n. If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.\n\n\nAs an example:\n\n\nuse ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this-\nrenderer = $renderer;\n        $this-\nisDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response-\nwithStatus(500);\n        $response-\ngetBody()-\nwrite($this-\nrenderer-\nrender('error::error', [\n            'exception'        =\n $e,\n            'development_mode' =\n $this-\nisDevelopmentMode,\n        ]));\n        return $response;\n    }\n}\n\n\n\n\nYou would then pass this to the \nErrorHandler\n:\n\n\n$app-\npipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));\n\n\n\n\nErrorHandler Listeners\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n provides the ability to attach\n\nlisteners\n; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.\n\n\nListeners must implement the following signature:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\n\nAttach listeners using \nErrorHandler::attachListener()\n:\n\n\n$errorHandler-\nattachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request-\ngetMethod(),\n        (string) $request-\ngetUri(),\n        $throwable-\ngetMessage()\n    );\n    $logger-\nerror($message);\n});\n\n\n\n\nLegacy error middleware\n\n\n\n\nDeprecated starting in 1.3.0, to be removed in 2.0.0. Please see the\n  \nmigration guide\n for more details, as well\n  as the preceding section.\n\n\n\n\nTo handle errors, you can write middleware that accepts \nexactly\n four arguments:\n\n\nfunction ($error, $request, $response, $next) { }\n\n\n\n\nAlternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nWhen using \nMiddlewarePipe\n, as the queue is executed, if \n$next()\n is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call \n$next()\n.\n\nError handlers that call \n$next()\n SHOULD call it with the error it received itself, or with\nanother error.\n\n\nError handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.", 
            "title": "Error Handlers"
        }, 
        {
            "location": "/error-handlers/#error-handlers", 
            "text": "In your application, you may need to handle error conditions:   Errors raised by PHP itself (e.g., inability to open a file or database\n  connection).  Exceptions/throwables raised by PHP and/or code you write or consume.  Inability of any middleware to handle a request.   You can typically handle these conditions via middleware itself.", 
            "title": "Error Handlers"
        }, 
        {
            "location": "/error-handlers/#handling-404-conditions", 
            "text": "Since 1.3.0   If no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition,  Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:  // setup layers\n$app- pipe(/* ... */);\n$app- pipe(/* ... */);\n$app- pipe(new NotFoundHandler(new Response());\n\n// execute application  Note that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.  If you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this- renderer = $renderer;\n        $this- response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this- response- withStatus(404);\n        $response- getBody()- write(\n            $this- renderer- render('error::404')\n        );\n        return $response;\n    }\n}", 
            "title": "Handling 404 conditions"
        }, 
        {
            "location": "/error-handlers/#handling-php-errors-and-exceptions", 
            "text": "Since 1.3.0", 
            "title": "Handling PHP errors and exceptions"
        }, 
        {
            "location": "/error-handlers/#opting-in-to-error-middleware", 
            "text": "If you have upgraded from Expressive 1.0.0, you will have been using the FinalHandler  implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in  try/catch  blocks.  Starting in 1.3.0, we provide a new way to handle errors via middleware.  To opt-in to the new system, you must call  raiseThrowables()  on your\nmiddleware pipeline:  $pipeline = new MiddlewarePipe();\n$pipeline- raiseThrowables();  (Starting in 2.0.0, this will no longer be necessary, but until then, this is\nhow you opt-in to the system described below.)   Zend\\Stratigility\\Middleware\\ErrorHandler  is a middleware implementation to\nregister as the  outermost layer  of your application (or close to the outermost\nlayer). It does the following:   Creates a PHP error handler that catches any errors in the  error_handling() \n  mask and throws them as  ErrorException  instances.  Wraps the invocation of the delegate in a try/catch block:  if no exception is caught, and the result is a response, it returns it.  if no exception is caught, it raises an exception, which will be caught.  any caught exception is transformed into an error response.   To generate the error response, we provide the ability to inject a callable with\nthe following signature into the  ErrorHandler  during instantiation:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We provide a default implementation,  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator ,\nwhich generates an error response with a  5XX  series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.  In order to work, the  ErrorHandler  needs a prototype response instance, and,\noptionally, an error response generator (if none is provided, ErrorResponseGenerator  is used, in production mode):  // setup error handling\n$app- pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app- pipe(/* ... */);\n$app- pipe(/* ... */);  As a full example, you can combine the two middleware into the same application\nas separate layers:  // setup error handling\n$app- pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app- pipe(/* ... */);\n$app- pipe(/* ... */);\n\n// setup 404 handling\n$app- pipe(new NotFoundHandler(new Response());\n\n// execute application  The  ErrorResponseGenerator  provides no templating facilities, and only\nresponds as  text/html . If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.  As an example:  use ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this- renderer = $renderer;\n        $this- isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response- withStatus(500);\n        $response- getBody()- write($this- renderer- render('error::error', [\n            'exception'        =  $e,\n            'development_mode' =  $this- isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}  You would then pass this to the  ErrorHandler :  $app- pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));", 
            "title": "Opting in to error middleware"
        }, 
        {
            "location": "/error-handlers/#errorhandler-listeners", 
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  provides the ability to attach listeners ; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.  Listeners must implement the following signature:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  Attach listeners using  ErrorHandler::attachListener() :  $errorHandler- attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request- getMethod(),\n        (string) $request- getUri(),\n        $throwable- getMessage()\n    );\n    $logger- error($message);\n});", 
            "title": "ErrorHandler Listeners"
        }, 
        {
            "location": "/error-handlers/#legacy-error-middleware", 
            "text": "Deprecated starting in 1.3.0, to be removed in 2.0.0. Please see the\n   migration guide  for more details, as well\n  as the preceding section.   To handle errors, you can write middleware that accepts  exactly  four arguments:  function ($error, $request, $response, $next) { }  Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .  When using  MiddlewarePipe , as the queue is executed, if  $next()  is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call  $next() . Error handlers that call  $next()  SHOULD call it with the error it received itself, or with\nanother error.  Error handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.", 
            "title": "Legacy error middleware"
        }, 
        {
            "location": "/creating-middleware/", 
            "text": "Creating Middleware\n\n\nTo create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware. By accepting the\nthird argument, \n$next\n, it can allow further processing via invoking that\nargument, or return handling to the parent middleware by returning a response.\n\n\nAs an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.\n\n\nfunction ($req, $res, $next) use ($router) {\n    $path = $req-\ngetUri()-\ngetPath();\n\n    // Route the path\n    $route = $router-\nroute($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route-\ngetHandler();\n    return $handler($req, $res, $next);\n}\n\n\n\n\nMiddleware written in this way can be any of the following:\n\n\n\n\nClosures (as shown above)\n\n\nFunctions\n\n\nStatic class methods\n\n\nPHP array callbacks (e.g., \n[ $dispatcher, 'dispatch' ]\n, where \n$dispatcher\n is a class instance)\n\n\nInvokable PHP objects (i.e., instances of classes implementing \n__invoke()\n)\n\n\nObjects implementing \nZend\\Stratigility\\MiddlewareInterface\n (including\n  \nZend\\Stratigility\\MiddlewarePipe\n)\n\n\n\n\nIn all cases, if you wish to implement typehinting, the signature is:\n\n\nfunction (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface\n\n\n\n\nLegacy error middleware\n\n\n\n\nDeprecated since 1.3.0; to be removed in version 2.0.0. Please use the the\n  \nNotFoundHandler\n and \nErrorHandler\n detailed in the\n  \nerror handling chapter\n, or equivalents.\n\n\n\n\nThe implementation Stratigility offers also allows you to write specialized\nerror handler middleware. The signature is the same as for normal middleware,\nexcept that it expects an additional argument prepended to the signature,\n\n$error\n.  (Alternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.)\nThe signature is:\n\n\nfunction (\n    $error, // Can be any type\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface", 
            "title": "Creating Middleware"
        }, 
        {
            "location": "/creating-middleware/#creating-middleware", 
            "text": "To create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware. By accepting the\nthird argument,  $next , it can allow further processing via invoking that\nargument, or return handling to the parent middleware by returning a response.  As an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.  function ($req, $res, $next) use ($router) {\n    $path = $req- getUri()- getPath();\n\n    // Route the path\n    $route = $router- route($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route- getHandler();\n    return $handler($req, $res, $next);\n}  Middleware written in this way can be any of the following:   Closures (as shown above)  Functions  Static class methods  PHP array callbacks (e.g.,  [ $dispatcher, 'dispatch' ] , where  $dispatcher  is a class instance)  Invokable PHP objects (i.e., instances of classes implementing  __invoke() )  Objects implementing  Zend\\Stratigility\\MiddlewareInterface  (including\n   Zend\\Stratigility\\MiddlewarePipe )   In all cases, if you wish to implement typehinting, the signature is:  function (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface", 
            "title": "Creating Middleware"
        }, 
        {
            "location": "/creating-middleware/#legacy-error-middleware", 
            "text": "Deprecated since 1.3.0; to be removed in version 2.0.0. Please use the the\n   NotFoundHandler  and  ErrorHandler  detailed in the\n   error handling chapter , or equivalents.   The implementation Stratigility offers also allows you to write specialized\nerror handler middleware. The signature is the same as for normal middleware,\nexcept that it expects an additional argument prepended to the signature, $error .  (Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .)\nThe signature is:  function (\n    $error, // Can be any type\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface", 
            "title": "Legacy error middleware"
        }, 
        {
            "location": "/executing-middleware/", 
            "text": "Executing and composing middleware\n\n\nThe easiest way to execute middleware is to write closures and attach them to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest \nMiddlewarePipe\n\ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api-\npipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app-\npipe('/api', $api);     // API middleware attached to the path \n/api\n\n\n\n\nAnother approach is to extend the \nZend\\Stratigility\\MiddlewarePipe\n class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the \nprocess()\n\nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(Request $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}\n\n\n\n\nAnother approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call \nparent::__construct()\n to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this-\npipe(/* some middleware */);\n    }\n}\n\n\n\n\nThese approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.", 
            "title": "Executing and composing middleware"
        }, 
        {
            "location": "/executing-middleware/#executing-and-composing-middleware", 
            "text": "The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe  instance. You can nest  MiddlewarePipe \ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.  $api = new MiddlewarePipe();  // API middleware collection\n$api- pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app- pipe('/api', $api);     // API middleware attached to the path  /api  Another approach is to extend the  Zend\\Stratigility\\MiddlewarePipe  class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the  process() \nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(Request $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call  parent::__construct()  to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.  use Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this- pipe(/* some middleware */);\n    }\n}  These approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.", 
            "title": "Executing and composing middleware"
        }, 
        {
            "location": "/api/", 
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and\nhas been discussed previously. Its API is:\n\n\nnamespace Zend\\Stratigility;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\MiddlewareInterface as InteropMiddlewareInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements MiddlewareInterface, ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|InteropMiddlewareInterface|ServerRequestInterface $path,\n        callable|InteropMiddlewareInterface|ServerRequestInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface,\n        ResponseInterface $response,\n        callable $out = null\n    ) :  ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\n\npipe()\n takes up to two arguments. If only one argument is provided,\n\n$middleware\n will be assigned that value, and \n$path\n will be re-assigned to\nthe value \n/\n; this is an indication that the \n$middleware\n should be invoked\nfor any path. If \n$path\n is provided, the \n$middleware\n will only be executed\nfor that path and any subpaths.\n\n\nMiddleware is executed in the order in which it is piped to the\n\nMiddlewarePipe\n instance.\n\n\nThe \nMiddlewarePipe\n is itself middleware, and can be executed in stacks that\nexpect the \n__invoke()\n signature (via the \n__invoke()\n signature), or stacks\nexpecting http-interop middleware signatures (via the \nprocess()\n method).\n\n\nWhen executing the \nMiddlewarePipe\n via its \n__invoke()\n method, if \n$out\n is\nnot provided, an instance of \nZend\\Stratigility\\FinalHandler\n will be created\nand used in the event that the pipe stack is exhausted (\nMiddlewarePipe\n passes\nthe \n$response\n instance it receives to \nFinalHandler\n as well, so that the\nlatter can determine if the response it receives is new).\n\n\n\n\n$out is no longer optional\n\n\nStarting in version 1.3.0, we now raise a deprecation notice if no argument is\npassed for the \n$out\n argument to \n__invoke()\n; starting in version 2.0.0,\nthe argument will be required.  Always pass a \nNext\n instance, a\n\nZend\\Stratigility\\NoopFinalHandler\n instance, or a custom callback; we no\nlonger recommend the \nFinalHandler\n implementation.\n\n\n\n\nWhen using \n__invoke()\n, the callable \n$out\n argument should use the signature:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\n\nWithin Stratigility, \nZend\\Stratigility\\Next\n provides such an implementation.\n\n\nStarting in version 1.3.0, \nMiddlewarePipe\n also implements the http-interop\n\nServerMiddlewareInterface\n, and thus provides a \nprocess()\n method. This\nmethod requires a \nServerRequestInterface\n instance and an\n\nInterop\\Http\\Middleware\\DelegateInterface\n instance on invocation; the latter\ncan be a \nNext\n instance, as it also implements that interface.\n\n\nInternally, for both \n__invoke()\n and \nprocess()\n, \nMiddlewarePipe\n creates an\ninstance of \nZend\\Stratigility\\Next\n, feeding it its queue, executes it, and\nreturns its response.\n\n\nResponse prototype\n\n\nStarting in version 1.3.0, you can compose a \"response prototype\" in the\n\nMiddlewarePipe\n. When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the \nsection on middleware\ndecorators\n, below) such that it will now conform to\nhttp-interop middleware interfaces.\n\n\nTo use this functionality, inject the prototype before piping middleware:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline-\nsetResponsePrototype(new Response());\n\n\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an \nInterop\\Http\\Middleware\\DelegateInterface\n.\n\n\nFunctor invocation\n\n\nBecause \nPsr\\Http\\Message\n's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain. \nNext\n expects\nthese arguments for every invocation. Additionally, if an error condition has\noccurred, you may pass an optional third argument, \n$err\n, representing the\nerror condition.\n\n\nclass Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\n\nYou should \nalways\n either capture or return the return value of \n$next()\n when calling it in your\napplication. The expected return value is a response instance, but if it is not, you may want to\nreturn the response provided to you.\n\n\n\n\n$err argument\n\n\nTechnically, \nNext::__invoke()\n accepts a third, optional argument, \n$err\n.\nHowever, as of version 1.3.0, this argument is deprecated, and usage will\nraise a deprecation notice during runtime. We will be removing the argument\nentirely starting with version 2.0.0.\n\n\n$response argument\n\n\nUsing the \n$response\n argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.\n\n\nAs such, we recommend ignoring the \n$response\n argument and doing one of the\nfollowing:\n\n\n\n\nFor innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance. \nDiactoros provides a number of convenient custom responses\n.\n\n\nFor middleware delegating to another layer, operate on the \nreturned\n\n  response instead:\n\n\n\n\n$response = $next($request, $response);\nreturn $response-\nwithHeader('X-Foo', 'Bar');\n\n\n\n\n\n\nDelegate invocation\n\n\n\n\nSince 1.3.0.\n\n\n\n\nWhen invoked as a \nDelegateInterface\n, the \nprocess()\n method will be invoked, and\npassed a \nServerRequestInterface\n instance \nonly\n. If you need to return a response,\nyou will need to:\n\n\n\n\nCompose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR\n\n\nCreate and return a concrete response type, OR\n\n\nOperate on a response returned by invoking the delegate.\n\n\n\n\nProviding an altered request:\n\n\n// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request-\nwithBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate-\nprocess(\n        $request-\nwithBodyParams($bodyParams)\n    );\n}\n\n\n\n\nReturning a response to complete the request\n\n\nIf your middleware does not need to delegate to another layer, it's time to\nreturn a response.\n\n\nWhile we pass a response when using \nNext\n as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response;\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype-\nwithAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype-\nwithAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n\n\n\nDelegation\n\n\nIf your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.\n\n\nIf using the legacy middleware signature, invoke the \n$next\n argument:\n\n\nreturn $next($request, $response);\n\n\n\n\nIf using a \nDelegateInterface\n, invoke its \nprocess()\n method:\n\n\nreturn $delegate-\nprocess($request);\n\n\n\n\nMiddleware should always return a response, and, if it cannot, return the\nresult of delegation.\n\n\nRaising an error condition\n\n\n\n\nDeprecated as of 1.3.0; please use exceptions and a error handling middleware\n  such as the \nErrorHandler\n\n  to handle error conditions in your application instead.\n\n\n\n\nTo raise an error condition, pass a non-null value as the third argument to \n$next()\n:\n\n\nfunction ($request, $response, $next)\n{\n    try {\n        // try some operation...\n    } catch (Exception $e) {\n        return $next($request, $response, $e); // Next registered error middleware will be invoked\n    }\n}\n\n\n\n\nFinalHandler\n\n\n\n\nDeprecated starting with 1.3.0. Use \nZend\\Stratigility\\NoopFinalHandler\n or a\n  custom handler guaranteed to return a response instead.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n is a default implementation of middleware to execute when the stack\nexhausts itself. It expects three arguments when invoked: a request instance, a response instance,\nand an error condition (or \nnull\n for no error). It returns a response.\n\n\nFinalHandler\n allows two optional arguments during instantiation\n\n\n\n\n$options\n, an array of options with which to configure itself. These options currently include:\n\n\nenv\n, the application environment. If set to \"production\", no stack traces will be provided.\n\n\nonerror\n, a callable to execute if an error is passed when \nFinalHandler\n is invoked. The\n    callable is invoked with the error (which will be \nnull\n in the absence of an error), the request,\n    and the response, in that order.\n\n\nPsr\\Http\\Message\\ResponseInterface $response\n; if passed, it will compare the response passed\n  during invocation against this instance; if they are different, it will return the response from\n  the invocation, as this indicates that one or more middleware provided a new response instance.\n\n\n\n\nInternally, \nFinalHandler\n does the following on invocation:\n\n\n\n\nIf \n$error\n is non-\nnull\n, it creates an error response from the response provided at invocation,\n  ensuring a 400 or 500 series response is returned.\n\n\nIf the response at invocation matches the response provided at instantiation, it returns it\n  without further changes. This is an indication that some middleware at some point in the execution\n  chain called \n$next()\n with a new response instance.\n\n\nIf the response at invocation does not match the response provided at instantiation, or if no\n  response was provided at instantiation, it creates a 404 response, as the assumption is that no\n  middleware was capable of handling the request.\n\n\n\n\nHTTP Messages\n\n\nZend\\Stratigility\\Http\\Request\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Request\n acts as a decorator for a \nPsr\\Http\\Message\\ServerRequestInterface\n\ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.\n\n\nAs an example, consider the following:\n\n\n$app1 = new Middleware();\n$app1-\npipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2-\npipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);\n\n\n\n\nIn the above, if the URI of the original incoming request is \n/root/foo\n, what \n$fooCallback\n will\nreceive is a URI with a past consisting of only \n/foo\n. This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.\n\n\nIf you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014 \nZend\\Stratigility\\Http\\Request\n contains a method, \ngetOriginalRequest()\n,\nwhich will always return the original request provided to the application:\n\n\nfunction ($request, $response, $next)\n{\n    $location = $request-\ngetOriginalRequest()-\ngetUri()-\ngetPath() . '/[:id]';\n    $response = $response-\nsetHeader('Location', $location);\n    $response = $response-\nsetStatus(302);\n    return $response;\n}\n\n\n\n\nZend\\Stratigility\\Http\\Response\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Response\n acts as a decorator for a \nPsr\\Http\\Message\\ResponseInterface\n\ninstance, and also implements \nZend\\Stratigility\\Http\\ResponseInterface\n, which provides the\nfollowing convenience methods:\n\n\n\n\nwrite()\n, which proxies to the \nwrite()\n method of the composed response stream.\n\n\nend()\n, which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the \nwrite()\n method. Once \nend()\n has been called, the response is\n  immutable and will throw an exception if a state mutating method like \nwithHeader\n is called.\n\n\nisComplete()\n indicates whether or not \nend()\n has been called.\n\n\n\n\nAdditionally, it provides access to the original response created by the server via the method\n\ngetOriginalResponse()\n.\n\n\nMiddleware\n\n\nStratigility provides several concrete middleware implementations.\n\n\nErrorHandler and NotFoundHandler\n\n\nThese two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the\n\nerror handling chapter\n.\n\n\nOriginalMessages\n\n\nThis callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the \nmigration chapter\n\nfor more details.\n\n\nMiddleware Decorators\n\n\nStarting in version 1.3.0, we offer the ability to work with http-interop\nmiddleware. Internally, if a response prototype is composed in the\n\nMiddlewarePipe\n, callable middleware piped to the \nMiddlewarePipe\n will be\nwrapped in one of these decorators.\n\n\nTwo versions exist:\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper($middleware, $response);\n\n\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on\n  \nInterop\\Http\\Middleware\\DelegateInterface\n:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ... \n  }\n);\n\n\n\n\nYou can manually decorate callable middleware using these decorators, or simply\nlet \nMiddlewarePipe\n do the work for you. To let \nMiddlewarePipe\n handle this,\nhowever, you \nmust\n compose a response prototype prior to piping middleware\nusing the legacy middleware signature.\n\n\nDelegates\n\n\nIn addition to \nZend\\Stratigility\\Next\n, Stratigility provides another\n\nInterop\\Http\\Middleware\\DelegateInterface\n implementation,\n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n.\n\n\nThis class can be used to wrap a callable \n$next\n instance for use in passing\nto a \nServerMiddlewareInterface::process()\n method as a delegate; the primary\nuse case is adapting functor middleware to work as http-interop middleware.\n\n\nAs an example:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this-\nprocess($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate-\nprocess($request);\n        return $response-\nwithHeader('X-Processed-Timestamp', time());\n    }\n}", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "The following make up the primary API of Stratigility.", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#middleware", 
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and\nhas been discussed previously. Its API is:  namespace Zend\\Stratigility;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\MiddlewareInterface as InteropMiddlewareInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements MiddlewareInterface, ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|InteropMiddlewareInterface|ServerRequestInterface $path,\n        callable|InteropMiddlewareInterface|ServerRequestInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface,\n        ResponseInterface $response,\n        callable $out = null\n    ) :  ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  pipe()  takes up to two arguments. If only one argument is provided, $middleware  will be assigned that value, and  $path  will be re-assigned to\nthe value  / ; this is an indication that the  $middleware  should be invoked\nfor any path. If  $path  is provided, the  $middleware  will only be executed\nfor that path and any subpaths.  Middleware is executed in the order in which it is piped to the MiddlewarePipe  instance.  The  MiddlewarePipe  is itself middleware, and can be executed in stacks that\nexpect the  __invoke()  signature (via the  __invoke()  signature), or stacks\nexpecting http-interop middleware signatures (via the  process()  method).  When executing the  MiddlewarePipe  via its  __invoke()  method, if  $out  is\nnot provided, an instance of  Zend\\Stratigility\\FinalHandler  will be created\nand used in the event that the pipe stack is exhausted ( MiddlewarePipe  passes\nthe  $response  instance it receives to  FinalHandler  as well, so that the\nlatter can determine if the response it receives is new).", 
            "title": "Middleware"
        }, 
        {
            "location": "/api/#out-is-no-longer-optional", 
            "text": "Starting in version 1.3.0, we now raise a deprecation notice if no argument is\npassed for the  $out  argument to  __invoke() ; starting in version 2.0.0,\nthe argument will be required.  Always pass a  Next  instance, a Zend\\Stratigility\\NoopFinalHandler  instance, or a custom callback; we no\nlonger recommend the  FinalHandler  implementation.   When using  __invoke() , the callable  $out  argument should use the signature:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Within Stratigility,  Zend\\Stratigility\\Next  provides such an implementation.  Starting in version 1.3.0,  MiddlewarePipe  also implements the http-interop ServerMiddlewareInterface , and thus provides a  process()  method. This\nmethod requires a  ServerRequestInterface  instance and an Interop\\Http\\Middleware\\DelegateInterface  instance on invocation; the latter\ncan be a  Next  instance, as it also implements that interface.  Internally, for both  __invoke()  and  process() ,  MiddlewarePipe  creates an\ninstance of  Zend\\Stratigility\\Next , feeding it its queue, executes it, and\nreturns its response.", 
            "title": "$out is no longer optional"
        }, 
        {
            "location": "/api/#response-prototype", 
            "text": "Starting in version 1.3.0, you can compose a \"response prototype\" in the MiddlewarePipe . When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the  section on middleware\ndecorators , below) such that it will now conform to\nhttp-interop middleware interfaces.  To use this functionality, inject the prototype before piping middleware:  $pipeline = new MiddlewarePipe();\n$pipeline- setResponsePrototype(new Response());", 
            "title": "Response prototype"
        }, 
        {
            "location": "/api/#next", 
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an  Interop\\Http\\Middleware\\DelegateInterface .", 
            "title": "Next"
        }, 
        {
            "location": "/api/#functor-invocation", 
            "text": "Because  Psr\\Http\\Message 's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain.  Next  expects\nthese arguments for every invocation. Additionally, if an error condition has\noccurred, you may pass an optional third argument,  $err , representing the\nerror condition.  class Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}  You should  always  either capture or return the return value of  $next()  when calling it in your\napplication. The expected return value is a response instance, but if it is not, you may want to\nreturn the response provided to you.", 
            "title": "Functor invocation"
        }, 
        {
            "location": "/api/#err-argument", 
            "text": "Technically,  Next::__invoke()  accepts a third, optional argument,  $err .\nHowever, as of version 1.3.0, this argument is deprecated, and usage will\nraise a deprecation notice during runtime. We will be removing the argument\nentirely starting with version 2.0.0.", 
            "title": "$err argument"
        }, 
        {
            "location": "/api/#response-argument", 
            "text": "Using the  $response  argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.  As such, we recommend ignoring the  $response  argument and doing one of the\nfollowing:   For innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance.  Diactoros provides a number of convenient custom responses .  For middleware delegating to another layer, operate on the  returned \n  response instead:   $response = $next($request, $response);\nreturn $response- withHeader('X-Foo', 'Bar');", 
            "title": "$response argument"
        }, 
        {
            "location": "/api/#delegate-invocation", 
            "text": "Since 1.3.0.   When invoked as a  DelegateInterface , the  process()  method will be invoked, and\npassed a  ServerRequestInterface  instance  only . If you need to return a response,\nyou will need to:   Compose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR  Create and return a concrete response type, OR  Operate on a response returned by invoking the delegate.", 
            "title": "Delegate invocation"
        }, 
        {
            "location": "/api/#providing-an-altered-request", 
            "text": "// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request- withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate- process(\n        $request- withBodyParams($bodyParams)\n    );\n}", 
            "title": "Providing an altered request:"
        }, 
        {
            "location": "/api/#returning-a-response-to-complete-the-request", 
            "text": "If your middleware does not need to delegate to another layer, it's time to\nreturn a response.  While we pass a response when using  Next  as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response;\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype- withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype- withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}", 
            "title": "Returning a response to complete the request"
        }, 
        {
            "location": "/api/#delegation", 
            "text": "If your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.  If using the legacy middleware signature, invoke the  $next  argument:  return $next($request, $response);  If using a  DelegateInterface , invoke its  process()  method:  return $delegate- process($request);  Middleware should always return a response, and, if it cannot, return the\nresult of delegation.", 
            "title": "Delegation"
        }, 
        {
            "location": "/api/#raising-an-error-condition", 
            "text": "Deprecated as of 1.3.0; please use exceptions and a error handling middleware\n  such as the  ErrorHandler \n  to handle error conditions in your application instead.   To raise an error condition, pass a non-null value as the third argument to  $next() :  function ($request, $response, $next)\n{\n    try {\n        // try some operation...\n    } catch (Exception $e) {\n        return $next($request, $response, $e); // Next registered error middleware will be invoked\n    }\n}", 
            "title": "Raising an error condition"
        }, 
        {
            "location": "/api/#finalhandler", 
            "text": "Deprecated starting with 1.3.0. Use  Zend\\Stratigility\\NoopFinalHandler  or a\n  custom handler guaranteed to return a response instead.   Zend\\Stratigility\\FinalHandler  is a default implementation of middleware to execute when the stack\nexhausts itself. It expects three arguments when invoked: a request instance, a response instance,\nand an error condition (or  null  for no error). It returns a response.  FinalHandler  allows two optional arguments during instantiation   $options , an array of options with which to configure itself. These options currently include:  env , the application environment. If set to \"production\", no stack traces will be provided.  onerror , a callable to execute if an error is passed when  FinalHandler  is invoked. The\n    callable is invoked with the error (which will be  null  in the absence of an error), the request,\n    and the response, in that order.  Psr\\Http\\Message\\ResponseInterface $response ; if passed, it will compare the response passed\n  during invocation against this instance; if they are different, it will return the response from\n  the invocation, as this indicates that one or more middleware provided a new response instance.   Internally,  FinalHandler  does the following on invocation:   If  $error  is non- null , it creates an error response from the response provided at invocation,\n  ensuring a 400 or 500 series response is returned.  If the response at invocation matches the response provided at instantiation, it returns it\n  without further changes. This is an indication that some middleware at some point in the execution\n  chain called  $next()  with a new response instance.  If the response at invocation does not match the response provided at instantiation, or if no\n  response was provided at instantiation, it creates a 404 response, as the assumption is that no\n  middleware was capable of handling the request.", 
            "title": "FinalHandler"
        }, 
        {
            "location": "/api/#http-messages", 
            "text": "", 
            "title": "HTTP Messages"
        }, 
        {
            "location": "/api/#zendstratigilityhttprequest", 
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Request  acts as a decorator for a  Psr\\Http\\Message\\ServerRequestInterface \ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.  As an example, consider the following:  $app1 = new Middleware();\n$app1- pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2- pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);  In the above, if the URI of the original incoming request is  /root/foo , what  $fooCallback  will\nreceive is a URI with a past consisting of only  /foo . This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.  If you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014  Zend\\Stratigility\\Http\\Request  contains a method,  getOriginalRequest() ,\nwhich will always return the original request provided to the application:  function ($request, $response, $next)\n{\n    $location = $request- getOriginalRequest()- getUri()- getPath() . '/[:id]';\n    $response = $response- setHeader('Location', $location);\n    $response = $response- setStatus(302);\n    return $response;\n}", 
            "title": "Zend\\Stratigility\\Http\\Request"
        }, 
        {
            "location": "/api/#zendstratigilityhttpresponse", 
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Response  acts as a decorator for a  Psr\\Http\\Message\\ResponseInterface \ninstance, and also implements  Zend\\Stratigility\\Http\\ResponseInterface , which provides the\nfollowing convenience methods:   write() , which proxies to the  write()  method of the composed response stream.  end() , which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the  write()  method. Once  end()  has been called, the response is\n  immutable and will throw an exception if a state mutating method like  withHeader  is called.  isComplete()  indicates whether or not  end()  has been called.   Additionally, it provides access to the original response created by the server via the method getOriginalResponse() .", 
            "title": "Zend\\Stratigility\\Http\\Response"
        }, 
        {
            "location": "/api/#middleware_1", 
            "text": "Stratigility provides several concrete middleware implementations.", 
            "title": "Middleware"
        }, 
        {
            "location": "/api/#errorhandler-and-notfoundhandler", 
            "text": "These two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the error handling chapter .", 
            "title": "ErrorHandler and NotFoundHandler"
        }, 
        {
            "location": "/api/#originalmessages", 
            "text": "This callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the  migration chapter \nfor more details.", 
            "title": "OriginalMessages"
        }, 
        {
            "location": "/api/#middleware-decorators", 
            "text": "Starting in version 1.3.0, we offer the ability to work with http-interop\nmiddleware. Internally, if a response prototype is composed in the MiddlewarePipe , callable middleware piped to the  MiddlewarePipe  will be\nwrapped in one of these decorators.  Two versions exist:   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:   $middleware = new CallableMiddlewareWrapper($middleware, $response);   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on\n   Interop\\Http\\Middleware\\DelegateInterface :   $middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ... \n  }\n);  You can manually decorate callable middleware using these decorators, or simply\nlet  MiddlewarePipe  do the work for you. To let  MiddlewarePipe  handle this,\nhowever, you  must  compose a response prototype prior to piping middleware\nusing the legacy middleware signature.", 
            "title": "Middleware Decorators"
        }, 
        {
            "location": "/api/#delegates", 
            "text": "In addition to  Zend\\Stratigility\\Next , Stratigility provides another Interop\\Http\\Middleware\\DelegateInterface  implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator .  This class can be used to wrap a callable  $next  instance for use in passing\nto a  ServerMiddlewareInterface::process()  method as a delegate; the primary\nuse case is adapting functor middleware to work as http-interop middleware.  As an example:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this- process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate- process($request);\n        return $response- withHeader('X-Processed-Timestamp', time());\n    }\n}", 
            "title": "Delegates"
        }, 
        {
            "location": "/migration/to-v2/", 
            "text": "Migrating to version 2\n\n\nVersion 2 of Stratigility will be making several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.\n\n\nTo help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.\n\n\nOriginal request, response, and URI\n\n\nIn the original 1.X releases, Stratigility would decorate the request and\nresponse instances with \nZend\\Stratigility\\Http\\Request\n and\n\nZend\\Stratigility\\Http\\Response\n, respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated (\nNext\n truncates matched paths when executing a layer\nif a path was provided when piping the middleware).\n\n\nInternally, prior to 1.3, only \nZend\\Stratigility\\FinalHandler\n was still using\nthis functionality:\n\n\n\n\nIt would query the original request to get the original URI when creating a\n  404 response message.\n\n\nIt passes the decorated request and response instances to \nonerror\n handlers.\n\n\n\n\nStarting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.\n\n\nIf you still need access to the original request, response, or URI instance, we\nrecommend the following:\n\n\n\n\nPipe \nZend\\Stratigility\\Middleware\\OriginalMessages\n as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:\n\n\noriginalRequest\n, mapping to the request provided to it at invocation.\n\n\noriginalResponse\n, mapping to the response provided to it at invocation.\n\n\noriginalUri\n, mapping to the URI composed by the request provided to it at\n  invocation.\n\n\n\n\n\n\n\n\nYou can then access these values within other middleware:\n\n\n$originalRequest = $request-\ngetAttribute('originalRequest');\n$originalResponse = $request-\ngetAttribute('originalResponse');\n$originalUri = $request-\ngetAttribute('originalUri');\n\n\n\n\nInternally, starting with 1.3.0, we have updated the request decorator to add\nthe \noriginalRequest\n attribute, and the \nFinalHandler\n to check for this,\ninstead of the decorated instance.\n\n\nFinally, if you are creating an \nonerror\n handler for the \nFinalHandler\n, update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.\n\n\nThe \nZend\\Stratigility\\Http\n classes, interfaces, and namespace will be removed\nin version 2.0.0.\n\n\nError handling\n\n\nPrior to version 1.3, the recommended way to handle errors was via\n\nerror middleware\n, special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the \nNext\n implementation when the middleware stack is exhausted,\nbut no response has been returned.\n\n\nThese approaches, however, have several shortcomings:\n\n\n\n\nNo other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls \n$next()\n with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.\n\n\nThe \nFinalHandler\n implementation hits edge cases when empty responses are\n  intended.\n\n\nNeither combination works well with error or exception handlers.\n\n\n\n\nStarting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.\n\n\nThe first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the \nMiddlewarePipe::raiseThrowables()\n method:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline-\nraiseThrowables();\n\n\n\n\nOnce you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:\n\n\n\n\nNotFoundHandler middleware\n\n\nErrorHandler middleware\n\n\nZend\\Stratigility\\NoopFinalHandler\n (see next section)\n\n\n\n\nUpdating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.\n\n\nNo-op final handler\n\n\nWhen using the \nNotFoundHandler\n and \nErrorHandler\n middleware (or custom\nmiddleware you drop in place of them), the \nFinalHandler\n implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.\n\n\nHowever, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form\nof \"final\" handler that can do so. (In fact, starting in version 2, the \n$out\n\nargument will be renamed to \n$delegate\n, and will be a required argument for\ninvoking the \nMiddlewarePipe\n.)\n\n\nStarting in version 1.3, we now offer a \nZend\\Stratigility\\NoopFinalHandler\n\nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:\n\n\n\n\nBy passing it explicitly when invoking the middleware pipeline.\n\n\nBy passing it to \nZend\\Diactoros\\Server::listen()\n.\n\n\n\n\nIf you are not using \nZend\\Diactoros\\Server\n to execute your application, but\ninstead invoking your pipeline manually, use the following:\n\n\n$response = $app($request, $response, new NoopFinalHandler());\n\n\n\n\nIf you are using \nZend\\Diactoros\\Server\n, you will need to pass the final\nhandler you wish to use as an argument to the \nlisten()\n method; that method\nwill then pass that value as the third argument to \nMiddlewarePipe\n as shown\nabove:\n\n\n$server-\nlisten(new NoopFinalHandler());\n\n\n\n\nBoth approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.\n\n\n(You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)\n\n\nTo summarize:\n\n\n\n\nCall the \nraiseThrowables()\n method of your \nMiddlewarePipe\n instance to\n  opt-in to the new error handling strategy.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\NotFoundHandler\n as the innermost\n  layer of your application pipeline in order to provide 404 responses.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\ErrorHandler\n middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.\n\n\nUse the \nZend\\Stratigility\\NoopFinalHandler\n as the \n$out\n argument when\n  dispatching your application pipeline.\n\n\n\n\nhttp-interop compatibility\n\n\nStarting in version 1.3.0, we offer compatibility with\n\nhttp-interop middleware 0.2.0\n.\nThat version of the specification defines the following interfaces:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\n\n\n\nThe support in version 1.3.0 consists of the following:\n\n\n\n\nMiddlewarePipe\n now also implements \nServerMiddlewareInterface\n, and allows\n  piping either type of http-interop middleware.\n\n\nNext\n now also implements \nDelegateInterface\n.\n\n\nDispatch\n is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.\n\n\n\n\nAdditionally, \nMiddlewarePipe\n will now allow composing a \nresponse prototype\n;\nthis is a PSR-7 \nResponseInterface\n instance. If not set, the first time the\npipeline is invoked via its \n__invoke()\n method, it will set the prototype from\nthe provided \n$response\n argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.\n\n\nStarting in version 2.0.0, \nMiddlewarePipe\n \nwill no longer implement\n\nZend\\Stratigility\\MiddlewareInterface\n, and only implement the http-interop\n\nServerMiddlewareInterface\n. This has several repercussions.\n\n\nCallable middleware in version 1.3.0\n\n\nCallable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.\n\n\nFirst, \nwe recommend \nnever\n using the \n$response\n argument provided to\nmiddleware.\n\n\nThe reason for this recommendation is two-fold. First, the http-interop\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.\n\n\nAs an example, consider the following:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return $next($request, $response-\nwithHeader('X-Foo', 'Bar'));\n});\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =\n time()]);\n});\n\n\n\n\nThe first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware, \ncreates and returns an entirely new response\n,\nmaking the new header disappear.\n\n\nAs such, we recommend rewriting such middleware to modify the \nreturned\n\nresponse instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response-\nwithHeader('X-Foo', 'Bar');\n});\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =\n time()]);\n});\n\n\n\n\nThe above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.\n\n\nSecond, either wrap your middleware in \nCallableMiddlewareWrapper\n, or ensure\nyour pipeline composes a \nresponse prototype\n (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop delegators.\n\n\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-interop:\n$pipeline-\npipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline-\nsetResponsePrototype($response);\n$pipeline-\npipe($middleware);\n\n\n\n\nThird, and optionally, you can make one or both of the following changes to\nyour callable middleware:\n\n\n\n\nTypehint the final \n$next\n argument against \nPsr\\Http\\Middleware\\DelegateInterface\n;\n  optionally, rename it to \n$delegate\n. This will require a slight change to\n  how you invoke the next layer as well; see below.    \n\n\nRemove the \n$response\n argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.\n\n\n\n\nAs an example of the first:\n\n\nfunction ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate-\nprocess($request);\n    return $response-\nwithHeader('X-Foo', 'Bar');\n}\n\n\n\n\nAs an example of adopting both practices:\n\n\nfunction ($request, DelegateInterface $delegate) {\n    $response = $delegate-\nprocess($request);\n    return $response-\nwithHeader('X-Foo', 'Bar');\n}\n\n\n\n\nAt this point, you have essentially implemented \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n\n(with the notable exception of not type-hinting the \n$request\n argument).\nWhen you pipe such callable middleware to \nMiddlewarePipeline\n, it will be\nwrapped in a \nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n,\nwhich simply proxies to the middleware when processed.\n\n\nFinally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.\n\n\nAs an example, consider the following middleware class:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\n\nThis could be rewritten as follows:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\n\nIf we were dealing with callable middleware instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =\n time()]);\n});\n\n\n\n\nwe could wrap this in an anonymous class instead:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n});\n\n\n\n\n\n\nUsing anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.\n\n\n\n\nIf you want your middleware to work with either http-interop or with the\npre-1.3.0 middleware signature, you can do that as well. To accomplish this, we\nprovide \nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n, which will wrap\na \ncallable $next\n such that it may be used as a \nDelegateInterface\n implementation:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this-\nprocess($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\n\nTo summarize:\n\n\n\n\nNever work with the provided \n$response\n argument, but instead manipulate the\n  response returned from calling \n$next\n.\n\n\nEnsure your pipeline can decorate callable middleware as http-interop\n  middleware. Do this by injecting a response prototype in the pipeline prior\n  to piping any middleware. (\nNote: this is not necessary if all callable\n  middleware defines exactly two parameters, with the second type-hinting on\n  the http-interop \nDelegateInterface\n.)\n\n\nConsider adapting your callable middleware to follow the http-interop middleware\n  signature (\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n);\n  this will make it forward-compatible.\n\n\nConsider updating your class-based middleware to implement one of the\n  http-interop middleware interfaces, potentially keeping the \n__invoke()\n method\n  for interoperability with existing callable-based middleware runners.\n\n\n\n\nThe first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-interop, and to ensure your middleware works\nproperly across middleware stacks.\n\n\nCallable middleware in version 2.0.0\n\n\nCallable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:\n\n\n\n\n\n\nInject a \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory\n\n  instance via the pipeline's \nsetCallableMiddlewareDecorator()\n method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a \nResponseInterface\n in its constructor, and will use that\n  response when creating \nCallableMiddlewareWrapper\n instances.\n\n\n$factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline-\nsetCallableMiddlewareDecorator($factory);\n\n\n\n\n\n\n\n\nPass a response prototype before piping the callable middleware. If no\n  \nCallableMiddlewareWrapperFactory\n is present, this prototype will be\n  used to seed one for use with decorating callable middleware.\n\n\n$pipeline-\nsetResponsePrototype(new Response());\n\n\n\n\n\n\n\n\nManually decorate your middleware prior to passing it to the pipeline:\n\n\n$pipeline-\npipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-interop signature already.\n\n\n\n\n\n\n\n\nInvoking MiddlewarePipe instances in version 2.0.0\n\n\nInvocation of the outermost middleware can now be done in two ways:\n\n\n\n\nUsing \n__invoke()\n. This now requires a third argument, \n$delegate\n, which\n  may be one of a \ncallable\n accepting \nServerRequestInterface\n and \nResponseInterface\n\n  arguments, or a \nDelegateInterface\n instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the \nMiddlewarePipe\n's internal queue is exhausted without returning\n  a response, and \nmust\n return a response itself. A good candidate for this\n  is the \nNoopFinalHandler\n.\n\n\nUsing \nprocess()\n. This argument requires a request and \nDelegateInterface\n\n  instance; again, the \nDelegateInterface\n instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.\n\n\n\n\nAs examples:\n\n\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline-\nprocess($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));\n\n\n\n\nOnce you have done so, you can process the returned request via an\n\nemitter\n.\n\n\nDeprecated functionality\n\n\nThe following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\Dispatch\n (class); this class is marked internal already,\n  but anybody extending \nNext\n and/or this class should be aware of its removal.\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (interface); error middleware\n  should now be implemented per the \nerror handling section above\n.\n\n\nThe \n$response\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n  \nCallableMiddlewareWrapper\n also ensures that a response argument is populated\n  and present when invoking callable middleware.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an \nE_USER_DEPRECATED\n notice, referencing this documentation.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\nThe \n$response\n argument to middleware is deprecated; please see the\n  \nsection on callable middleware\n\n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop middleware interface.", 
            "title": "To Version 2"
        }, 
        {
            "location": "/migration/to-v2/#migrating-to-version-2", 
            "text": "Version 2 of Stratigility will be making several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.  To help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.", 
            "title": "Migrating to version 2"
        }, 
        {
            "location": "/migration/to-v2/#original-request-response-and-uri", 
            "text": "In the original 1.X releases, Stratigility would decorate the request and\nresponse instances with  Zend\\Stratigility\\Http\\Request  and Zend\\Stratigility\\Http\\Response , respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated ( Next  truncates matched paths when executing a layer\nif a path was provided when piping the middleware).  Internally, prior to 1.3, only  Zend\\Stratigility\\FinalHandler  was still using\nthis functionality:   It would query the original request to get the original URI when creating a\n  404 response message.  It passes the decorated request and response instances to  onerror  handlers.   Starting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.  If you still need access to the original request, response, or URI instance, we\nrecommend the following:   Pipe  Zend\\Stratigility\\Middleware\\OriginalMessages  as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:  originalRequest , mapping to the request provided to it at invocation.  originalResponse , mapping to the response provided to it at invocation.  originalUri , mapping to the URI composed by the request provided to it at\n  invocation.     You can then access these values within other middleware:  $originalRequest = $request- getAttribute('originalRequest');\n$originalResponse = $request- getAttribute('originalResponse');\n$originalUri = $request- getAttribute('originalUri');  Internally, starting with 1.3.0, we have updated the request decorator to add\nthe  originalRequest  attribute, and the  FinalHandler  to check for this,\ninstead of the decorated instance.  Finally, if you are creating an  onerror  handler for the  FinalHandler , update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.  The  Zend\\Stratigility\\Http  classes, interfaces, and namespace will be removed\nin version 2.0.0.", 
            "title": "Original request, response, and URI"
        }, 
        {
            "location": "/migration/to-v2/#error-handling", 
            "text": "Prior to version 1.3, the recommended way to handle errors was via error middleware , special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the  Next  implementation when the middleware stack is exhausted,\nbut no response has been returned.  These approaches, however, have several shortcomings:   No other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls  $next()  with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.  The  FinalHandler  implementation hits edge cases when empty responses are\n  intended.  Neither combination works well with error or exception handlers.   Starting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.  The first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the  MiddlewarePipe::raiseThrowables()  method:  $pipeline = new MiddlewarePipe();\n$pipeline- raiseThrowables();  Once you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:   NotFoundHandler middleware  ErrorHandler middleware  Zend\\Stratigility\\NoopFinalHandler  (see next section)   Updating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.", 
            "title": "Error handling"
        }, 
        {
            "location": "/migration/to-v2/#no-op-final-handler", 
            "text": "When using the  NotFoundHandler  and  ErrorHandler  middleware (or custom\nmiddleware you drop in place of them), the  FinalHandler  implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.  However, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form\nof \"final\" handler that can do so. (In fact, starting in version 2, the  $out \nargument will be renamed to  $delegate , and will be a required argument for\ninvoking the  MiddlewarePipe .)  Starting in version 1.3, we now offer a  Zend\\Stratigility\\NoopFinalHandler \nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:   By passing it explicitly when invoking the middleware pipeline.  By passing it to  Zend\\Diactoros\\Server::listen() .   If you are not using  Zend\\Diactoros\\Server  to execute your application, but\ninstead invoking your pipeline manually, use the following:  $response = $app($request, $response, new NoopFinalHandler());  If you are using  Zend\\Diactoros\\Server , you will need to pass the final\nhandler you wish to use as an argument to the  listen()  method; that method\nwill then pass that value as the third argument to  MiddlewarePipe  as shown\nabove:  $server- listen(new NoopFinalHandler());  Both approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.  (You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)  To summarize:   Call the  raiseThrowables()  method of your  MiddlewarePipe  instance to\n  opt-in to the new error handling strategy.  Use the new  Zend\\Stratigility\\Middleware\\NotFoundHandler  as the innermost\n  layer of your application pipeline in order to provide 404 responses.  Use the new  Zend\\Stratigility\\Middleware\\ErrorHandler  middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.  Use the  Zend\\Stratigility\\NoopFinalHandler  as the  $out  argument when\n  dispatching your application pipeline.", 
            "title": "No-op final handler"
        }, 
        {
            "location": "/migration/to-v2/#http-interop-compatibility", 
            "text": "Starting in version 1.3.0, we offer compatibility with http-interop middleware 0.2.0 .\nThat version of the specification defines the following interfaces:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}  The support in version 1.3.0 consists of the following:   MiddlewarePipe  now also implements  ServerMiddlewareInterface , and allows\n  piping either type of http-interop middleware.  Next  now also implements  DelegateInterface .  Dispatch  is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.   Additionally,  MiddlewarePipe  will now allow composing a  response prototype ;\nthis is a PSR-7  ResponseInterface  instance. If not set, the first time the\npipeline is invoked via its  __invoke()  method, it will set the prototype from\nthe provided  $response  argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.  Starting in version 2.0.0,  MiddlewarePipe   will no longer implement Zend\\Stratigility\\MiddlewareInterface , and only implement the http-interop ServerMiddlewareInterface . This has several repercussions.", 
            "title": "http-interop compatibility"
        }, 
        {
            "location": "/migration/to-v2/#callable-middleware-in-version-130", 
            "text": "Callable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.  First,  we recommend  never  using the  $response  argument provided to\nmiddleware.  The reason for this recommendation is two-fold. First, the http-interop\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.  As an example, consider the following:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return $next($request, $response- withHeader('X-Foo', 'Bar'));\n});\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =  time()]);\n});  The first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware,  creates and returns an entirely new response ,\nmaking the new header disappear.  As such, we recommend rewriting such middleware to modify the  returned \nresponse instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response- withHeader('X-Foo', 'Bar');\n});\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =  time()]);\n});  The above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.  Second, either wrap your middleware in  CallableMiddlewareWrapper , or ensure\nyour pipeline composes a  response prototype  (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop delegators.  use Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-interop:\n$pipeline- pipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline- setResponsePrototype($response);\n$pipeline- pipe($middleware);  Third, and optionally, you can make one or both of the following changes to\nyour callable middleware:   Typehint the final  $next  argument against  Psr\\Http\\Middleware\\DelegateInterface ;\n  optionally, rename it to  $delegate . This will require a slight change to\n  how you invoke the next layer as well; see below.      Remove the  $response  argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.   As an example of the first:  function ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate- process($request);\n    return $response- withHeader('X-Foo', 'Bar');\n}  As an example of adopting both practices:  function ($request, DelegateInterface $delegate) {\n    $response = $delegate- process($request);\n    return $response- withHeader('X-Foo', 'Bar');\n}  At this point, you have essentially implemented  Interop\\Http\\Middleware\\ServerMiddlewareInterface \n(with the notable exception of not type-hinting the  $request  argument).\nWhen you pipe such callable middleware to  MiddlewarePipeline , it will be\nwrapped in a  Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper ,\nwhich simply proxies to the middleware when processed.  Finally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.  As an example, consider the following middleware class:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}  This could be rewritten as follows:  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}  If we were dealing with callable middleware instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =  time()]);\n});  we could wrap this in an anonymous class instead:  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n});   Using anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.   If you want your middleware to work with either http-interop or with the\npre-1.3.0 middleware signature, you can do that as well. To accomplish this, we\nprovide  Zend\\Stratigility\\Delegate\\CallableDelegateDecorator , which will wrap\na  callable $next  such that it may be used as a  DelegateInterface  implementation:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this- process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}  To summarize:   Never work with the provided  $response  argument, but instead manipulate the\n  response returned from calling  $next .  Ensure your pipeline can decorate callable middleware as http-interop\n  middleware. Do this by injecting a response prototype in the pipeline prior\n  to piping any middleware. ( Note: this is not necessary if all callable\n  middleware defines exactly two parameters, with the second type-hinting on\n  the http-interop  DelegateInterface .)  Consider adapting your callable middleware to follow the http-interop middleware\n  signature ( function (ServerRequestInterface $request, DelegateInterface $delegate) );\n  this will make it forward-compatible.  Consider updating your class-based middleware to implement one of the\n  http-interop middleware interfaces, potentially keeping the  __invoke()  method\n  for interoperability with existing callable-based middleware runners.   The first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-interop, and to ensure your middleware works\nproperly across middleware stacks.", 
            "title": "Callable middleware in version 1.3.0"
        }, 
        {
            "location": "/migration/to-v2/#callable-middleware-in-version-200", 
            "text": "Callable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:    Inject a  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory \n  instance via the pipeline's  setCallableMiddlewareDecorator()  method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a  ResponseInterface  in its constructor, and will use that\n  response when creating  CallableMiddlewareWrapper  instances.  $factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline- setCallableMiddlewareDecorator($factory);    Pass a response prototype before piping the callable middleware. If no\n   CallableMiddlewareWrapperFactory  is present, this prototype will be\n  used to seed one for use with decorating callable middleware.  $pipeline- setResponsePrototype(new Response());    Manually decorate your middleware prior to passing it to the pipeline:  $pipeline- pipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-interop signature already.", 
            "title": "Callable middleware in version 2.0.0"
        }, 
        {
            "location": "/migration/to-v2/#invoking-middlewarepipe-instances-in-version-200", 
            "text": "Invocation of the outermost middleware can now be done in two ways:   Using  __invoke() . This now requires a third argument,  $delegate , which\n  may be one of a  callable  accepting  ServerRequestInterface  and  ResponseInterface \n  arguments, or a  DelegateInterface  instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the  MiddlewarePipe 's internal queue is exhausted without returning\n  a response, and  must  return a response itself. A good candidate for this\n  is the  NoopFinalHandler .  Using  process() . This argument requires a request and  DelegateInterface \n  instance; again, the  DelegateInterface  instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.   As examples:  use Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline- process($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));  Once you have done so, you can process the returned request via an emitter .", 
            "title": "Invoking MiddlewarePipe instances in version 2.0.0"
        }, 
        {
            "location": "/migration/to-v2/#deprecated-functionality", 
            "text": "The following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.   Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\Dispatch  (class); this class is marked internal already,\n  but anybody extending  Next  and/or this class should be aware of its removal.  Zend\\Stratigility\\ErrorMiddlewareInterface  (interface); error middleware\n  should now be implemented per the  error handling section above .  The  $response  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n   CallableMiddlewareWrapper  also ensures that a response argument is populated\n  and present when invoking callable middleware.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an  E_USER_DEPRECATED  notice, referencing this documentation.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)  The  $response  argument to middleware is deprecated; please see the\n   section on callable middleware \n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop middleware interface.", 
            "title": "Deprecated functionality"
        }
    ]
}