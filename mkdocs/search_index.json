{
    "docs": [
        {
            "location": "/", 
            "text": "../../README.md", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "Stratigility\n\n\n\n\nFrom \"Strata\", Latin for \"layer\", and \"agility\".\n\n\n\n\nStratigility started as a port of \nSencha Connect\n\nto PHP. It allows you to build applications out of \nmiddleware\n.", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#stratigility", 
            "text": "From \"Strata\", Latin for \"layer\", and \"agility\".   Stratigility started as a port of  Sencha Connect \nto PHP. It allows you to build applications out of  middleware .", 
            "title": "Stratigility"
        }, 
        {
            "location": "/install/", 
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\nhttp-interop/http-middleware\n,\n  which provides the interfaces that will become PSR-15. In Stratigility 1.3,\n  this is pinned to the 0.2 series; in Stratigility 2.0, this is pinned to\n  0.4.1+.\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nErrorHandler\n middleware and the\n  (legacy) \nFinalHandler\n implementation for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.", 
            "title": "Installation and Requirements"
        }, 
        {
            "location": "/install/#installation-and-requirements", 
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n   Diactoros .    http-interop/http-middleware ,\n  which provides the interfaces that will become PSR-15. In Stratigility 1.3,\n  this is pinned to the 0.2 series; in Stratigility 2.0, this is pinned to\n  0.4.1+.    zendframework/zend-escaper , used by the  ErrorHandler  middleware and the\n  (legacy)  FinalHandler  implementation for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.", 
            "title": "Installation and Requirements"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server-\nlisten(new NoopFinalHandler());\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server- listen(new NoopFinalHandler());  The above example is useless by itself until you pipe middleware into the application.", 
            "title": "Usage"
        }, 
        {
            "location": "/middleware/", 
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app-\nsetResponsePrototype(new Response());\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app-\npipe('/', function ($req, $res, $next) {\n    if (! in_array($req-\ngetUri()-\ngetPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    $res-\ngetBody()-\nwrite('Hello world!');\n    return $res;\n});\n\n// Another page\n$app-\npipe('/foo', function ($req, $res, $next) {\n    $res-\ngetBody()-\nwrite('FOO!');\n    return $res;\n});\n\n$server-\nlisten();\n\n\n\nIn the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or\n\n/\n, it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path \n/foo\n\n\n meaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.\n\n\nSo, concisely put, \nmiddleware are PHP callables that accept a request and\nresponse object, and do something with it\n.\n\n\n\n\nhttp-interop middleware\n\n\nThe above example demonstrates the legacy (pre-1.3.0) signature for\nmiddleware, which is also widely used across other middleware frameworks\nsuch as Slim, Relay, Adroit, etc.\n\n\nhttp-interop is a project attempting to standardize middleware signatures.\nThe signature until the 0.4.0 series for server-side middleware is:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface ServerMiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\nwhere \nDelegateInterface\n is defined as:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface DelegateInterface\n{\n    public function process(\n        RequestInterface $request\n    ) : ResponseInterface;\n}\n\n\n\nStarting in http-interop/http-middleware 0.4.1, these become:\n\n\nnamespace Interop\\Http\\ServerMiddleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\ninterface DelegateInterface\n{\n    public function process(\n        ServerRequestInterface $request\n    ) : ResponseInterface;\n}\n\n\n\n(Note the namespace change, the change in the middleware interface name, and\nthe change in the \nDelegateInterface\n signature.)\n\n\nStratigility allows you to implement the http-interop/http-middleware\nmiddleware interface to provide middleware.  Additionally, you can define\n\ncallable\n middleware with the following signature, and it will be dispatched\nas http-interop middleware:\n\n\nfunction(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;\n\n\n\n(The \n$request\n argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)\n\n\nAs such, the above example can also be written as follows:\n\n\n$app-\npipe('/', function ($request, DelegateInterface $delegate) {\n    if (! in_array($request-\ngetUri()-\ngetPath(), ['/', ''], true)) {\n        return $delegate-\nprocess($request);\n    }\n    return new TextResponse('Hello world!');\n});\n\n\n\n\n\nMiddleware can decide more processing can be performed by calling the \n$next\n\ncallable (or, when defining http-interop middleware, \n$delegate\n) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests \n for instance, you could have middleware perform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:\n\n\n$app-\npipe('/api', $apiMiddleware);\n$app-\npipe('/docs', $apiDocMiddleware);\n$app-\npipe('/files', $filesMiddleware);\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.\n\n\nWithin Stratigility, middleware can be:\n\n\n\n\nAny PHP callable that accepts, minimally, a\n  \nPSR-7\n\n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).\n\n\nAny \nhttp-interop 0.2.0 - middleware\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements\n  \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n. (Stratigility 1.3.0 series.)\n\n\nAny \nhttp-interop 0.4.1 - middleware\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements\n  \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n. (Stratigility 2.0 series.)\n\n\nAn object implementing \nZend\\Stratigility\\MiddlewareInterface\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements this interface.\n  (Legacy; this interface is deprecated starting in 1.3.0.)", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#middleware", 
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.  use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app- setResponsePrototype(new Response());\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app- pipe('/', function ($req, $res, $next) {\n    if (! in_array($req- getUri()- getPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    $res- getBody()- write('Hello world!');\n    return $res;\n});\n\n// Another page\n$app- pipe('/foo', function ($req, $res, $next) {\n    $res- getBody()- write('FOO!');\n    return $res;\n});\n\n$server- listen();  In the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path  /foo   meaning it will match  /foo ,  /foo/ , and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.  So, concisely put,  middleware are PHP callables that accept a request and\nresponse object, and do something with it .", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#http-interop-middleware", 
            "text": "The above example demonstrates the legacy (pre-1.3.0) signature for\nmiddleware, which is also widely used across other middleware frameworks\nsuch as Slim, Relay, Adroit, etc.  http-interop is a project attempting to standardize middleware signatures.\nThe signature until the 0.4.0 series for server-side middleware is:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface ServerMiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  where  DelegateInterface  is defined as:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface DelegateInterface\n{\n    public function process(\n        RequestInterface $request\n    ) : ResponseInterface;\n}  Starting in http-interop/http-middleware 0.4.1, these become:  namespace Interop\\Http\\ServerMiddleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\ninterface DelegateInterface\n{\n    public function process(\n        ServerRequestInterface $request\n    ) : ResponseInterface;\n}  (Note the namespace change, the change in the middleware interface name, and\nthe change in the  DelegateInterface  signature.)  Stratigility allows you to implement the http-interop/http-middleware\nmiddleware interface to provide middleware.  Additionally, you can define callable  middleware with the following signature, and it will be dispatched\nas http-interop middleware:  function(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;  (The  $request  argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)  As such, the above example can also be written as follows:  $app- pipe('/', function ($request, DelegateInterface $delegate) {\n    if (! in_array($request- getUri()- getPath(), ['/', ''], true)) {\n        return $delegate- process($request);\n    }\n    return new TextResponse('Hello world!');\n});   Middleware can decide more processing can be performed by calling the  $next \ncallable (or, when defining http-interop middleware,  $delegate ) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests   for instance, you could have middleware perform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:  $app- pipe('/api', $apiMiddleware);\n$app- pipe('/docs', $apiDocMiddleware);\n$app- pipe('/files', $filesMiddleware);  The handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.  Within Stratigility, middleware can be:   Any PHP callable that accepts, minimally, a\n   PSR-7 \n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).  Any  http-interop 0.2.0 - middleware .\n   Zend\\Stratigility\\MiddlewarePipe  implements\n   Interop\\Http\\Middleware\\ServerMiddlewareInterface . (Stratigility 1.3.0 series.)  Any  http-interop 0.4.1 - middleware .\n   Zend\\Stratigility\\MiddlewarePipe  implements\n   Interop\\Http\\Middleware\\ServerMiddlewareInterface . (Stratigility 2.0 series.)  An object implementing  Zend\\Stratigility\\MiddlewareInterface .\n   Zend\\Stratigility\\MiddlewarePipe  implements this interface.\n  (Legacy; this interface is deprecated starting in 1.3.0.)", 
            "title": "http-interop middleware"
        }, 
        {
            "location": "/error-handlers/", 
            "text": "Error Handlers\n\n\nIn your application, you may need to handle error conditions:\n\n\n\n\nErrors raised by PHP itself (e.g., inability to open a file or database\n  connection).\n\n\nExceptions/throwables raised by PHP and/or code you write or consume.\n\n\nInability of any middleware to handle a request.\n\n\n\n\nYou can typically handle these conditions via middleware itself.\n\n\nHandling 404 conditions\n\n\n\n\nSince 1.3.0\n\n\n\n\nIf no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition, \nZend\\Stratigility\\Middleware\\NotFoundHandler\n. The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:\n\n\n// setup layers\n$app-\npipe(/* ... */);\n$app-\npipe(/* ... */);\n$app-\npipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nNote that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.\n\n\nIf you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this-\nrenderer = $renderer;\n        $this-\nresponse = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this-\nresponse-\nwithStatus(404);\n        $response-\ngetBody()-\nwrite(\n            $this-\nrenderer-\nrender('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\nHandling PHP errors and exceptions\n\n\n\n\nSince 1.3.0\n\n\n\n\n\n\nOpting in to error middleware\n\n\nIf you have upgraded from Expressive 1.0.0, you will have been using the\n\nFinalHandler\n implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in \ntry/catch\n blocks.\n\n\nStarting in 1.3.0, we provide a new way to handle errors via middleware.\n\n\nTo opt-in to the new system, you must call \nraiseThrowables()\n on your\nmiddleware pipeline:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline-\nraiseThrowables();\n\n\n\n(Starting in 2.0.0, this will no longer be necessary, but until then, this is\nhow you opt-in to the system described below.)\n\n\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n is a middleware implementation to\nregister as the \noutermost layer\n of your application (or close to the outermost\nlayer). It does the following:\n\n\n\n\nCreates a PHP error handler that catches any errors in the \nerror_handling()\n\n  mask and throws them as \nErrorException\n instances.\n\n\nWraps the invocation of the delegate in a try/catch block:\n\n\nif no exception is caught, and the result is a response, it returns it.\n\n\nif no exception is caught, it raises an exception, which will be caught.\n\n\nany caught exception is transformed into an error response.\n\n\n\n\nTo generate the error response, we provide the ability to inject a callable with\nthe following signature into the \nErrorHandler\n during instantiation:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe provide a default implementation, \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n,\nwhich generates an error response with a \n5XX\n series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.\n\n\nIn order to work, the \nErrorHandler\n needs a prototype response instance, and,\noptionally, an error response generator (if none is provided,\n\nErrorResponseGenerator\n is used, in production mode):\n\n\n// setup error handling\n$app-\npipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app-\npipe(/* ... */);\n$app-\npipe(/* ... */);\n\n\n\nAs a full example, you can combine the two middleware into the same application\nas separate layers:\n\n\n// setup error handling\n$app-\npipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app-\npipe(/* ... */);\n$app-\npipe(/* ... */);\n\n// setup 404 handling\n$app-\npipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nThe \nErrorResponseGenerator\n provides no templating facilities, and only\nresponds as \ntext/html\n. If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.\n\n\nAs an example:\n\n\nuse ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this-\nrenderer = $renderer;\n        $this-\nisDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response-\nwithStatus(500);\n        $response-\ngetBody()-\nwrite($this-\nrenderer-\nrender('error::error', [\n            'exception'        =\n $e,\n            'development_mode' =\n $this-\nisDevelopmentMode,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou would then pass this to the \nErrorHandler\n:\n\n\n$app-\npipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));\n\n\n\nErrorHandler Listeners\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n provides the ability to attach\n\nlisteners\n; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.\n\n\nListeners must implement the following signature:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nAttach listeners using \nErrorHandler::attachListener()\n:\n\n\n$errorHandler-\nattachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request-\ngetMethod(),\n        (string) $request-\ngetUri(),\n        $throwable-\ngetMessage()\n    );\n    $logger-\nerror($message);\n});\n\n\n\nLegacy error middleware\n\n\n\n\nDeprecated starting in 1.3.0, to be removed in 2.0.0. Please see the\n  \nmigration guide\n for more details, as well\n  as the preceding section.\n\n\n\n\nTo handle errors, you can write middleware that accepts \nexactly\n four arguments:\n\n\nfunction ($error, $request, $response, $next) { }\n\n\n\nAlternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nWhen using \nMiddlewarePipe\n, as the queue is executed, if \n$next()\n is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call \n$next()\n.\n\nError handlers that call \n$next()\n SHOULD call it with the error it received itself, or with\nanother error.\n\n\nError handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.", 
            "title": "Error Handlers"
        }, 
        {
            "location": "/error-handlers/#error-handlers", 
            "text": "In your application, you may need to handle error conditions:   Errors raised by PHP itself (e.g., inability to open a file or database\n  connection).  Exceptions/throwables raised by PHP and/or code you write or consume.  Inability of any middleware to handle a request.   You can typically handle these conditions via middleware itself.", 
            "title": "Error Handlers"
        }, 
        {
            "location": "/error-handlers/#handling-404-conditions", 
            "text": "Since 1.3.0   If no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition,  Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:  // setup layers\n$app- pipe(/* ... */);\n$app- pipe(/* ... */);\n$app- pipe(new NotFoundHandler(new Response());\n\n// execute application  Note that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.  If you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this- renderer = $renderer;\n        $this- response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this- response- withStatus(404);\n        $response- getBody()- write(\n            $this- renderer- render('error::404')\n        );\n        return $response;\n    }\n}", 
            "title": "Handling 404 conditions"
        }, 
        {
            "location": "/error-handlers/#handling-php-errors-and-exceptions", 
            "text": "Since 1.3.0", 
            "title": "Handling PHP errors and exceptions"
        }, 
        {
            "location": "/error-handlers/#opting-in-to-error-middleware", 
            "text": "If you have upgraded from Expressive 1.0.0, you will have been using the FinalHandler  implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in  try/catch  blocks.  Starting in 1.3.0, we provide a new way to handle errors via middleware.  To opt-in to the new system, you must call  raiseThrowables()  on your\nmiddleware pipeline:  $pipeline = new MiddlewarePipe();\n$pipeline- raiseThrowables();  (Starting in 2.0.0, this will no longer be necessary, but until then, this is\nhow you opt-in to the system described below.)   Zend\\Stratigility\\Middleware\\ErrorHandler  is a middleware implementation to\nregister as the  outermost layer  of your application (or close to the outermost\nlayer). It does the following:   Creates a PHP error handler that catches any errors in the  error_handling() \n  mask and throws them as  ErrorException  instances.  Wraps the invocation of the delegate in a try/catch block:  if no exception is caught, and the result is a response, it returns it.  if no exception is caught, it raises an exception, which will be caught.  any caught exception is transformed into an error response.   To generate the error response, we provide the ability to inject a callable with\nthe following signature into the  ErrorHandler  during instantiation:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We provide a default implementation,  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator ,\nwhich generates an error response with a  5XX  series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.  In order to work, the  ErrorHandler  needs a prototype response instance, and,\noptionally, an error response generator (if none is provided, ErrorResponseGenerator  is used, in production mode):  // setup error handling\n$app- pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app- pipe(/* ... */);\n$app- pipe(/* ... */);  As a full example, you can combine the two middleware into the same application\nas separate layers:  // setup error handling\n$app- pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app- pipe(/* ... */);\n$app- pipe(/* ... */);\n\n// setup 404 handling\n$app- pipe(new NotFoundHandler(new Response());\n\n// execute application  The  ErrorResponseGenerator  provides no templating facilities, and only\nresponds as  text/html . If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.  As an example:  use ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this- renderer = $renderer;\n        $this- isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response- withStatus(500);\n        $response- getBody()- write($this- renderer- render('error::error', [\n            'exception'        =  $e,\n            'development_mode' =  $this- isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}  You would then pass this to the  ErrorHandler :  $app- pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));", 
            "title": "Opting in to error middleware"
        }, 
        {
            "location": "/error-handlers/#errorhandler-listeners", 
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  provides the ability to attach listeners ; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.  Listeners must implement the following signature:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  Attach listeners using  ErrorHandler::attachListener() :  $errorHandler- attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request- getMethod(),\n        (string) $request- getUri(),\n        $throwable- getMessage()\n    );\n    $logger- error($message);\n});", 
            "title": "ErrorHandler Listeners"
        }, 
        {
            "location": "/error-handlers/#legacy-error-middleware", 
            "text": "Deprecated starting in 1.3.0, to be removed in 2.0.0. Please see the\n   migration guide  for more details, as well\n  as the preceding section.   To handle errors, you can write middleware that accepts  exactly  four arguments:  function ($error, $request, $response, $next) { }  Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .  When using  MiddlewarePipe , as the queue is executed, if  $next()  is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call  $next() . Error handlers that call  $next()  SHOULD call it with the error it received itself, or with\nanother error.  Error handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.", 
            "title": "Legacy error middleware"
        }, 
        {
            "location": "/creating-middleware/", 
            "text": "Creating Middleware\n\n\nTo create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware. By accepting the\nthird argument, \n$next\n, it can allow further processing via invoking that\nargument, or return handling to the parent middleware by returning a response.\n\n\nAs an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.\n\n\nfunction ($req, $res, $next) use ($router) {\n    $path = $req-\ngetUri()-\ngetPath();\n\n    // Route the path\n    $route = $router-\nroute($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route-\ngetHandler();\n    return $handler($req, $res, $next);\n}\n\n\n\nMiddleware written in this way can be any of the following:\n\n\n\n\nClosures (as shown above)\n\n\nFunctions\n\n\nStatic class methods\n\n\nPHP array callbacks (e.g., \n[ $dispatcher, 'dispatch' ]\n, where \n$dispatcher\n is a class instance)\n\n\nInvokable PHP objects (i.e., instances of classes implementing \n__invoke()\n)\n\n\nObjects implementing \nZend\\Stratigility\\MiddlewareInterface\n (including\n  \nZend\\Stratigility\\MiddlewarePipe\n)\n\n\n\n\nIn all cases, if you wish to implement typehinting, the signature is:\n\n\nfunction (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface", 
            "title": "Creating Middleware"
        }, 
        {
            "location": "/creating-middleware/#creating-middleware", 
            "text": "To create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware. By accepting the\nthird argument,  $next , it can allow further processing via invoking that\nargument, or return handling to the parent middleware by returning a response.  As an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.  function ($req, $res, $next) use ($router) {\n    $path = $req- getUri()- getPath();\n\n    // Route the path\n    $route = $router- route($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route- getHandler();\n    return $handler($req, $res, $next);\n}  Middleware written in this way can be any of the following:   Closures (as shown above)  Functions  Static class methods  PHP array callbacks (e.g.,  [ $dispatcher, 'dispatch' ] , where  $dispatcher  is a class instance)  Invokable PHP objects (i.e., instances of classes implementing  __invoke() )  Objects implementing  Zend\\Stratigility\\MiddlewareInterface  (including\n   Zend\\Stratigility\\MiddlewarePipe )   In all cases, if you wish to implement typehinting, the signature is:  function (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface", 
            "title": "Creating Middleware"
        }, 
        {
            "location": "/executing-middleware/", 
            "text": "Executing and composing middleware\n\n\nThe easiest way to execute middleware is to write closures and attach them to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest \nMiddlewarePipe\n\ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api-\npipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app-\npipe('/api', $api);     // API middleware attached to the path \n/api\n\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path. Using the previous example, if the path \n/api/users/foo\n is\nmatched, the \n$api\n middleware will receive a request with the path\n\n/users/foo\n. This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.\n\n\n\n\nHandling errors\n\n\nWhile the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n class:\n\n\nuse Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app-\npipe(new ErrorHandler(new Response());\n// Add more middleware...\n\n\n\nYou can learn how to customize the error handler to your needs in the\n\nchapter on error handlers\n.\n\n\nExtending the MiddlewarePipe\n\n\nAnother approach is to extend the \nZend\\Stratigility\\MiddlewarePipe\n class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the \nprocess()\n\nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:\n\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}\n\n\n\nAnother approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call \nparent::__construct()\n to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this-\npipe(/* some middleware */);\n    }\n}\n\n\n\nThese approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.", 
            "title": "Executing and composing middleware"
        }, 
        {
            "location": "/executing-middleware/#executing-and-composing-middleware", 
            "text": "The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe  instance. You can nest  MiddlewarePipe \ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.  $api = new MiddlewarePipe();  // API middleware collection\n$api- pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app- pipe('/api', $api);     // API middleware attached to the path  /api", 
            "title": "Executing and composing middleware"
        }, 
        {
            "location": "/executing-middleware/#request-path-changes-when-path-matched", 
            "text": "When you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path. Using the previous example, if the path  /api/users/foo  is\nmatched, the  $api  middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.", 
            "title": "Request path changes when path matched"
        }, 
        {
            "location": "/executing-middleware/#handling-errors", 
            "text": "While the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler  class:  use Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app- pipe(new ErrorHandler(new Response());\n// Add more middleware...  You can learn how to customize the error handler to your needs in the chapter on error handlers .", 
            "title": "Handling errors"
        }, 
        {
            "location": "/executing-middleware/#extending-the-middlewarepipe", 
            "text": "Another approach is to extend the  Zend\\Stratigility\\MiddlewarePipe  class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the  process() \nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:  class CustomMiddleware extends MiddlewarePipe\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call  parent::__construct()  to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.  use Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this- pipe(/* some middleware */);\n    }\n}  These approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.", 
            "title": "Extending the MiddlewarePipe"
        }, 
        {
            "location": "/api/", 
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and\nhas been discussed previously. Its API is:\n\n\nnamespace Zend\\Stratigility;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|ServerMiddlewareInterface $path,\n        callable|ServerMiddlewareInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        $delegate\n    ) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\npipe()\n takes up to two arguments. If only one argument is provided,\n\n$middleware\n will be assigned that value, and \n$path\n will be re-assigned to\nthe value \n/\n; this is an indication that the \n$middleware\n should be invoked\nfor any path. If \n$path\n is provided, the \n$middleware\n will only be executed\nfor that path and any subpaths.\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.\n\n\nIf, for example, you executed \n$pipeline-\npipe('/api', $api)\n, and this was\nmatched via a URI with the path \n/api/users/foo\n, the \n$api\n middleware will\nreceive a request with the path \n/users/foo\n. This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.\n\n\n\n\nMiddleware is executed in the order in which it is piped to the\n\nMiddlewarePipe\n instance.\n\n\nThe \nMiddlewarePipe\n is itself middleware, and can be executed in stacks that\nexpect the \n__invoke()\n signature (via the \n__invoke()\n signature), or stacks\nexpecting http-interop middleware signatures (via the \nprocess()\n method).\n\n\nWhen using \n__invoke()\n, the callable \n$out\n argument should either be an\n\nInterop\\Http\\Middleware\\DelegateInterface\n, or use the signature:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nMost often, you can pass an instance of \nZend\\Stratigility\\NoopFinalHandler\n for\n\n$out\n if invoking a middleware pipeline manually; otherwise, a suitable\ncallback will be provided for you (typically an instance of\n\nZend\\Stratigility\\Next\n, which \nMiddlewarePipe\n creates internally before\ndispatching to the various middleware in its pipeline).\n\n\nMiddleware should either return a response, or the result of\n\n$next()/DelegateInterface::process()\n (which should eventually evaluate to a\nresponse instance).\n\n\nWithin Stratigility, \nZend\\Stratigility\\Next\n provides an implementation\ncompatible with either usage.\n\n\nStarting in version 1.3.0, \nMiddlewarePipe\n implements the\nhttp-interop/http-middleware server-side middleware interface, and thus provides\na \nprocess()\n method. This method requires a \nServerRequestInterface\n instance\nand an http-interop/http-middleware \nDelegateInterface\n instance on invocation;\nthe latter can be a \nNext\n instance, as it also implements that interface.\n\n\nInternally, for both \n__invoke()\n and \nprocess()\n, \nMiddlewarePipe\n creates an\ninstance of \nZend\\Stratigility\\Next\n (feeding it its queue), executes it, and\nreturns its response.\n\n\nResponse prototype\n\n\nStarting in version 1.3.0, you can compose a \"response prototype\" in the\n\nMiddlewarePipe\n. When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the \nsection on middleware\ndecorators\n, below) such that it will now conform to\nhttp-interop middleware interfaces.\n\n\nTo use this functionality, inject the prototype before piping middleware:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline-\nsetResponsePrototype(new Response());\n\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an http-interop/http-middleware\n\nDelegateInterface\n.\n\n\nFunctor invocation\n\n\nBecause \nPsr\\Http\\Message\n's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain. \nNext\n expects\nthese arguments for every invocation.\n\n\nclass Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\nYou should \nalways\n either capture or return the return value of \n$next()\n\nwhen calling it in your application, or return a response yourself.\n\n\n\n\n$response argument\n\n\nUsing the \n$response\n argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.\n\n\nAs such, we recommend ignoring the \n$response\n argument and doing one of the\nfollowing:\n\n\n\n\nFor innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance. \nDiactoros provides a number of convenient custom responses\n.\n\n\nFor middleware delegating to another layer, operate on the \nreturned\n\n  response instead:\n\n\n\n\n$response = $next($request, $response);\nreturn $response-\nwithHeader('X-Foo', 'Bar');\n\n\n\n\n\nDelegate invocation\n\n\n\n\nSince 1.3.0.\n\n\n\n\nWhen invoked as a \nDelegateInterface\n, the \nprocess()\n method will be invoked, and\npassed a \nServerRequestInterface\n instance \nonly\n. If you need to return a response,\nyou will need to:\n\n\n\n\nCompose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR\n\n\nCreate and return a concrete response type, OR\n\n\nOperate on a response returned by invoking the delegate.\n\n\n\n\nProviding an altered request:\n\n\n// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request-\nwithBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $delegate-\nprocess(\n        $request-\nwithBodyParams($bodyParams)\n    );\n}\n\n\n\nProviding an altered request and operating on the returned response:\n\n\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $response = $next(\n        $request-\nwithBodyParams($bodyParser($request)),\n        $response\n    );\n\n    return $response-\nwithAddedHeader('Cache-Control', [\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate-\nprocess(\n        $request-\nwithBodyParams($bodyParams)\n    );\n}\n\n\n\nReturning a response to complete the request\n\n\nIf your middleware does not need to delegate to another layer, it's time to\nreturn a response.\n\n\nWhile we pass a response when using \nNext\n as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.\n\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype-\nwithAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype-\nwithAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}\n\n\n\nDelegation\n\n\nIf your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.\n\n\nIf using the legacy middleware signature, invoke the \n$next\n argument:\n\n\nreturn $next($request, $response);\n\n\n\nIf using a \nDelegateInterface\n, invoke its \nprocess()\n method:\n\n\nreturn $delegate-\nprocess($request);\n\n\n\nMiddleware should always return a response, and, if it cannot, return the\nresult of delegation.\n\n\nRaising an error condition\n\n\nIf your middleware cannot complete \n perhaps a database error occurred, a\nservice was unreachable, etc. \n how can you report the error?\n\n\nRaise an exception!\n\n\nfunction ($request, $response, $next) use ($service)\n{\n    $result = $service-\nfetchSomething();\n    if (! $result-\nisSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}\n\n\n\nUse the \nErrorHandler middleware\n\nto handle exceptions thrown by your middleware and report the error condition to\nyour users.\n\n\nHTTP Messages\n\n\nZend\\Stratigility\\Http\\Request\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Request\n acts as a decorator for a \nPsr\\Http\\Message\\ServerRequestInterface\n\ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.\n\n\nAs an example, consider the following:\n\n\n$app1 = new Middleware();\n$app1-\npipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2-\npipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);\n\n\n\nIn the above, if the URI of the original incoming request is \n/root/foo\n, what \n$fooCallback\n will\nreceive is a URI with a past consisting of only \n/foo\n. This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.\n\n\nIf you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014 \nZend\\Stratigility\\Http\\Request\n contains a method, \ngetOriginalRequest()\n,\nwhich will always return the original request provided to the application:\n\n\nfunction ($request, $response, $next)\n{\n    $location = $request-\ngetOriginalRequest()-\ngetUri()-\ngetPath() . '/[:id]';\n    $response = $response-\nsetHeader('Location', $location);\n    $response = $response-\nsetStatus(302);\n    return $response;\n}\n\n\n\nZend\\Stratigility\\Http\\Response\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Response\n acts as a decorator for a \nPsr\\Http\\Message\\ResponseInterface\n\ninstance, and also implements \nZend\\Stratigility\\Http\\ResponseInterface\n, which provides the\nfollowing convenience methods:\n\n\n\n\nwrite()\n, which proxies to the \nwrite()\n method of the composed response stream.\n\n\nend()\n, which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the \nwrite()\n method. Once \nend()\n has been called, the response is\n  immutable and will throw an exception if a state mutating method like \nwithHeader\n is called.\n\n\nisComplete()\n indicates whether or not \nend()\n has been called.\n\n\n\n\nAdditionally, it provides access to the original response created by the server via the method\n\ngetOriginalResponse()\n.\n\n\nMiddleware\n\n\nStratigility provides several concrete middleware implementations.\n\n\nErrorHandler and NotFoundHandler\n\n\nThese two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the\n\nerror handling chapter\n.\n\n\nOriginalMessages\n\n\nThis callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the \nmigration chapter\n\nfor more details.\n\n\nMiddleware Decorators\n\n\nStarting in version 1.3.0, we offer the ability to work with\nhttp-interop/http-middleware. Internally, if a response prototype is composed in\nthe \nMiddlewarePipe\n, callable middleware piped to the \nMiddlewarePipe\n will be\nwrapped in one of these decorators.\n\n\nTwo versions exist:\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper($middleware, $response);\n\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on the\n  http-interop/http-middleware \nDelegateInterface\n:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ... \n  }\n);\n\n\n\nYou can manually decorate callable middleware using these decorators, or simply\nlet \nMiddlewarePipe\n do the work for you. To let \nMiddlewarePipe\n handle this,\nhowever, you \nmust\n compose a response prototype prior to piping middleware\nusing the legacy middleware signature.\n\n\nDelegates\n\n\nIn addition to \nZend\\Stratigility\\Next\n, Stratigility provides another\nhttp-interop/http-middleware \nDelegateInterface\n implementation,\n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n.\n\n\nThis class can be used to wrap a callable \n$next\n instance for use in passing to\nan http-interop/http-middleware middleware interface \nprocess()\n method as a\ndelegate; the primary use case is adapting functor middleware to work as\nhttp-interop middleware.\n\n\nAs an example:\n\n\n// http-interop/http-middleware 0.2:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.4.1:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this-\nprocess($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate-\nprocess($request);\n        return $response-\nwithHeader('X-Processed-Timestamp', time());\n    }\n}", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "The following make up the primary API of Stratigility.", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#middleware", 
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and\nhas been discussed previously. Its API is:  namespace Zend\\Stratigility;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|ServerMiddlewareInterface $path,\n        callable|ServerMiddlewareInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        $delegate\n    ) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  pipe()  takes up to two arguments. If only one argument is provided, $middleware  will be assigned that value, and  $path  will be re-assigned to\nthe value  / ; this is an indication that the  $middleware  should be invoked\nfor any path. If  $path  is provided, the  $middleware  will only be executed\nfor that path and any subpaths.", 
            "title": "Middleware"
        }, 
        {
            "location": "/api/#request-path-changes-when-path-matched", 
            "text": "When you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.  If, for example, you executed  $pipeline- pipe('/api', $api) , and this was\nmatched via a URI with the path  /api/users/foo , the  $api  middleware will\nreceive a request with the path  /users/foo . This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.   Middleware is executed in the order in which it is piped to the MiddlewarePipe  instance.  The  MiddlewarePipe  is itself middleware, and can be executed in stacks that\nexpect the  __invoke()  signature (via the  __invoke()  signature), or stacks\nexpecting http-interop middleware signatures (via the  process()  method).  When using  __invoke() , the callable  $out  argument should either be an Interop\\Http\\Middleware\\DelegateInterface , or use the signature:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Most often, you can pass an instance of  Zend\\Stratigility\\NoopFinalHandler  for $out  if invoking a middleware pipeline manually; otherwise, a suitable\ncallback will be provided for you (typically an instance of Zend\\Stratigility\\Next , which  MiddlewarePipe  creates internally before\ndispatching to the various middleware in its pipeline).  Middleware should either return a response, or the result of $next()/DelegateInterface::process()  (which should eventually evaluate to a\nresponse instance).  Within Stratigility,  Zend\\Stratigility\\Next  provides an implementation\ncompatible with either usage.  Starting in version 1.3.0,  MiddlewarePipe  implements the\nhttp-interop/http-middleware server-side middleware interface, and thus provides\na  process()  method. This method requires a  ServerRequestInterface  instance\nand an http-interop/http-middleware  DelegateInterface  instance on invocation;\nthe latter can be a  Next  instance, as it also implements that interface.  Internally, for both  __invoke()  and  process() ,  MiddlewarePipe  creates an\ninstance of  Zend\\Stratigility\\Next  (feeding it its queue), executes it, and\nreturns its response.", 
            "title": "Request path changes when path matched"
        }, 
        {
            "location": "/api/#response-prototype", 
            "text": "Starting in version 1.3.0, you can compose a \"response prototype\" in the MiddlewarePipe . When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the  section on middleware\ndecorators , below) such that it will now conform to\nhttp-interop middleware interfaces.  To use this functionality, inject the prototype before piping middleware:  $pipeline = new MiddlewarePipe();\n$pipeline- setResponsePrototype(new Response());", 
            "title": "Response prototype"
        }, 
        {
            "location": "/api/#next", 
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an http-interop/http-middleware DelegateInterface .", 
            "title": "Next"
        }, 
        {
            "location": "/api/#functor-invocation", 
            "text": "Because  Psr\\Http\\Message 's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain.  Next  expects\nthese arguments for every invocation.  class Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}  You should  always  either capture or return the return value of  $next() \nwhen calling it in your application, or return a response yourself.", 
            "title": "Functor invocation"
        }, 
        {
            "location": "/api/#response-argument", 
            "text": "Using the  $response  argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.  As such, we recommend ignoring the  $response  argument and doing one of the\nfollowing:   For innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance.  Diactoros provides a number of convenient custom responses .  For middleware delegating to another layer, operate on the  returned \n  response instead:   $response = $next($request, $response);\nreturn $response- withHeader('X-Foo', 'Bar');", 
            "title": "$response argument"
        }, 
        {
            "location": "/api/#delegate-invocation", 
            "text": "Since 1.3.0.   When invoked as a  DelegateInterface , the  process()  method will be invoked, and\npassed a  ServerRequestInterface  instance  only . If you need to return a response,\nyou will need to:   Compose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR  Create and return a concrete response type, OR  Operate on a response returned by invoking the delegate.", 
            "title": "Delegate invocation"
        }, 
        {
            "location": "/api/#providing-an-altered-request", 
            "text": "// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request- withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $delegate- process(\n        $request- withBodyParams($bodyParams)\n    );\n}", 
            "title": "Providing an altered request:"
        }, 
        {
            "location": "/api/#providing-an-altered-request-and-operating-on-the-returned-response", 
            "text": "function ($request, $response, $next) use ($bodyParser)\n{\n    $response = $next(\n        $request- withBodyParams($bodyParser($request)),\n        $response\n    );\n\n    return $response- withAddedHeader('Cache-Control', [\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate- process(\n        $request- withBodyParams($bodyParams)\n    );\n}", 
            "title": "Providing an altered request and operating on the returned response:"
        }, 
        {
            "location": "/api/#returning-a-response-to-complete-the-request", 
            "text": "If your middleware does not need to delegate to another layer, it's time to\nreturn a response.  While we pass a response when using  Next  as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.  $prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype- withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype- withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}", 
            "title": "Returning a response to complete the request"
        }, 
        {
            "location": "/api/#delegation", 
            "text": "If your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.  If using the legacy middleware signature, invoke the  $next  argument:  return $next($request, $response);  If using a  DelegateInterface , invoke its  process()  method:  return $delegate- process($request);  Middleware should always return a response, and, if it cannot, return the\nresult of delegation.", 
            "title": "Delegation"
        }, 
        {
            "location": "/api/#raising-an-error-condition", 
            "text": "If your middleware cannot complete   perhaps a database error occurred, a\nservice was unreachable, etc.   how can you report the error?  Raise an exception!  function ($request, $response, $next) use ($service)\n{\n    $result = $service- fetchSomething();\n    if (! $result- isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}  Use the  ErrorHandler middleware \nto handle exceptions thrown by your middleware and report the error condition to\nyour users.", 
            "title": "Raising an error condition"
        }, 
        {
            "location": "/api/#http-messages", 
            "text": "", 
            "title": "HTTP Messages"
        }, 
        {
            "location": "/api/#zendstratigilityhttprequest", 
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Request  acts as a decorator for a  Psr\\Http\\Message\\ServerRequestInterface \ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.  As an example, consider the following:  $app1 = new Middleware();\n$app1- pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2- pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);  In the above, if the URI of the original incoming request is  /root/foo , what  $fooCallback  will\nreceive is a URI with a past consisting of only  /foo . This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.  If you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014  Zend\\Stratigility\\Http\\Request  contains a method,  getOriginalRequest() ,\nwhich will always return the original request provided to the application:  function ($request, $response, $next)\n{\n    $location = $request- getOriginalRequest()- getUri()- getPath() . '/[:id]';\n    $response = $response- setHeader('Location', $location);\n    $response = $response- setStatus(302);\n    return $response;\n}", 
            "title": "Zend\\Stratigility\\Http\\Request"
        }, 
        {
            "location": "/api/#zendstratigilityhttpresponse", 
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Response  acts as a decorator for a  Psr\\Http\\Message\\ResponseInterface \ninstance, and also implements  Zend\\Stratigility\\Http\\ResponseInterface , which provides the\nfollowing convenience methods:   write() , which proxies to the  write()  method of the composed response stream.  end() , which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the  write()  method. Once  end()  has been called, the response is\n  immutable and will throw an exception if a state mutating method like  withHeader  is called.  isComplete()  indicates whether or not  end()  has been called.   Additionally, it provides access to the original response created by the server via the method getOriginalResponse() .", 
            "title": "Zend\\Stratigility\\Http\\Response"
        }, 
        {
            "location": "/api/#middleware_1", 
            "text": "Stratigility provides several concrete middleware implementations.", 
            "title": "Middleware"
        }, 
        {
            "location": "/api/#errorhandler-and-notfoundhandler", 
            "text": "These two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the error handling chapter .", 
            "title": "ErrorHandler and NotFoundHandler"
        }, 
        {
            "location": "/api/#originalmessages", 
            "text": "This callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the  migration chapter \nfor more details.", 
            "title": "OriginalMessages"
        }, 
        {
            "location": "/api/#middleware-decorators", 
            "text": "Starting in version 1.3.0, we offer the ability to work with\nhttp-interop/http-middleware. Internally, if a response prototype is composed in\nthe  MiddlewarePipe , callable middleware piped to the  MiddlewarePipe  will be\nwrapped in one of these decorators.  Two versions exist:   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:   $middleware = new CallableMiddlewareWrapper($middleware, $response);   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on the\n  http-interop/http-middleware  DelegateInterface :   $middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ... \n  }\n);  You can manually decorate callable middleware using these decorators, or simply\nlet  MiddlewarePipe  do the work for you. To let  MiddlewarePipe  handle this,\nhowever, you  must  compose a response prototype prior to piping middleware\nusing the legacy middleware signature.", 
            "title": "Middleware Decorators"
        }, 
        {
            "location": "/api/#delegates", 
            "text": "In addition to  Zend\\Stratigility\\Next , Stratigility provides another\nhttp-interop/http-middleware  DelegateInterface  implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator .  This class can be used to wrap a callable  $next  instance for use in passing to\nan http-interop/http-middleware middleware interface  process()  method as a\ndelegate; the primary use case is adapting functor middleware to work as\nhttp-interop middleware.  As an example:  // http-interop/http-middleware 0.2:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.4.1:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this- process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate- process($request);\n        return $response- withHeader('X-Processed-Timestamp', time());\n    }\n}", 
            "title": "Delegates"
        }, 
        {
            "location": "/migration/to-v2/", 
            "text": "Migrating to version 2\n\n\nVersion 2 of Stratigility makes several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.\n\n\nTo help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.\n\n\nOriginal request, response, and URI\n\n\nIn the original 1.X releases, Stratigility would decorate the request and\nresponse instances with \nZend\\Stratigility\\Http\\Request\n and\n\nZend\\Stratigility\\Http\\Response\n, respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated (\nNext\n truncates matched paths when executing a layer\nif a path was provided when piping the middleware).\n\n\nInternally, prior to 1.3, only \nZend\\Stratigility\\FinalHandler\n was still using\nthis functionality:\n\n\n\n\nIt would query the original request to get the original URI when creating a\n  404 response message.\n\n\nIt passes the decorated request and response instances to \nonerror\n handlers.\n\n\n\n\nStarting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.\n\n\nIf you still need access to the original request, response, or URI instance, we\nrecommend the following:\n\n\n\n\nPipe \nZend\\Stratigility\\Middleware\\OriginalMessages\n as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:\n\n\noriginalRequest\n, mapping to the request provided to it at invocation.\n\n\noriginalResponse\n, mapping to the response provided to it at invocation.\n\n\noriginalUri\n, mapping to the URI composed by the request provided to it at\n  invocation.\n\n\n\n\n\n\n\n\nYou can then access these values within other middleware:\n\n\n$originalRequest = $request-\ngetAttribute('originalRequest');\n$originalResponse = $request-\ngetAttribute('originalResponse');\n$originalUri = $request-\ngetAttribute('originalUri');\n\n\n\nInternally, starting with 1.3.0, we have updated the request decorator to add\nthe \noriginalRequest\n attribute, and the \nFinalHandler\n to check for this,\ninstead of the decorated instance.\n\n\nFinally, if you are creating an \nonerror\n handler for the \nFinalHandler\n, update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.\n\n\nThe \nZend\\Stratigility\\Http\n classes, interfaces, and namespace are removed\nin version 2.0.0.\n\n\nError handling\n\n\nPrior to version 1.3, the recommended way to handle errors was via\n\nerror middleware\n, special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the \nNext\n implementation when the middleware stack is exhausted,\nbut no response has been returned.\n\n\nThese approaches, however, have several shortcomings:\n\n\n\n\nNo other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls \n$next()\n with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.\n\n\nThe \nFinalHandler\n implementation hits edge cases when empty responses are\n  intended.\n\n\nNeither combination works well with error or exception handlers.\n\n\n\n\nStarting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.\n\n\nThe first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the \nMiddlewarePipe::raiseThrowables()\n method:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline-\nraiseThrowables();\n\n\n\nOnce you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:\n\n\n\n\nNotFoundHandler middleware\n\n\nErrorHandler middleware\n\n\nZend\\Stratigility\\NoopFinalHandler\n (see next section)\n\n\n\n\nUpdating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.\n\n\nNo-op final handler\n\n\nWhen using the \nNotFoundHandler\n and \nErrorHandler\n middleware (or custom\nmiddleware you drop in place of them), the \nFinalHandler\n implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.\n\n\nHowever, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form of\n\"final\" handler that can do so. (In fact, starting in version 2, the \n$out\n\nargument is renamed to \n$delegate\n, and is a \nrequired\n argument of the\n\nMiddlewarePipe\n.)\n\n\nStarting in version 1.3, we now offer a \nZend\\Stratigility\\NoopFinalHandler\n\nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:\n\n\n\n\nBy passing it explicitly when invoking the middleware pipeline.\n\n\nBy passing it to \nZend\\Diactoros\\Server::listen()\n.\n\n\n\n\nIf you are not using \nZend\\Diactoros\\Server\n to execute your application, but\ninstead invoking your pipeline manually, use the following:\n\n\n$response = $app($request, $response, new NoopFinalHandler());\n\n\n\nIf you are using \nZend\\Diactoros\\Server\n, you will need to pass the final\nhandler you wish to use as an argument to the \nlisten()\n method; that method\nwill then pass that value as the third argument to \nMiddlewarePipe\n as shown\nabove:\n\n\n$server-\nlisten(new NoopFinalHandler());\n\n\n\nBoth approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.\n\n\n(You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)\n\n\nTo summarize:\n\n\n\n\nCall the \nraiseThrowables()\n method of your \nMiddlewarePipe\n instance to\n  opt-in to the new error handling strategy.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\NotFoundHandler\n as the innermost\n  layer of your application pipeline in order to provide 404 responses.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\ErrorHandler\n middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.\n\n\nUse the \nZend\\Stratigility\\NoopFinalHandler\n as the \n$out\n argument when\n  dispatching your application pipeline.\n\n\n\n\nhttp-interop compatibility\n\n\nhttp-middleware 0.2.0 and Stratigility 1.3\n\n\nStarting in version 1.3.0, we offer compatibility with\n\nhttp-interop/http-middleware 0.2.0\n.\nThat version of the specification defines the following interfaces:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\n\n\nThe support in version 1.3.0 consists of the following:\n\n\n\n\nMiddlewarePipe\n now also implements \nServerMiddlewareInterface\n, and allows\n  piping either type of http-interop middleware.\n\n\nNext\n now also implements \nDelegateInterface\n.\n\n\nDispatch\n is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.\n\n\n\n\nAdditionally, \nMiddlewarePipe\n will now allow composing a \nresponse prototype\n;\nthis is a PSR-7 \nResponseInterface\n instance. If not set, the first time the\npipeline is invoked via its \n__invoke()\n method, it will set the prototype from\nthe provided \n$response\n argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.\n\n\nhttp-middleware 0.4.1 and Stratigility 2.0\n\n\nhttp-interop/http-middleware 0.4.1 introduces breaking changes in the\ninterfaces, including the following:\n\n\n\n\n\n\nThe namespace changes from \nInterop\\Http\\Middleware\n to\n  \nInterop\\Http\\ServerMiddleware\n, signaling a change indicating that the project\n  now only targets server-side middleware.\n\n\n\n\n\n\nThe interface \nServerMiddlewareInterface\n is now more simply\n  \nMiddlewareInterface\n, as the namespace indicates its usage in server-side\n  applications. \nInterop\\Http\\Middleware\\MiddlewareInterface\n, which targeted\n  client-side middleware, was removed entirely.\n\n\n\n\n\n\nThe method \nDelegateInterface::process\n now accepts specifically a\n  \nPsr\\Http\\Message\\ServerRequestInterface\n, and not the more general\n  \nRequestInterface\n.\n\n\n\n\n\n\nThe first two changes required only a change in import statements to\naccommodate, and could have been imported in parallel to the 0.2.0 interfaces.\nHowever, the second represents a signature change, which has necessitated a\nmajor version bump in Stratigility in order to remain compatible.\n\n\nStratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that\nversion (and compatible versions) only.\n\n\nAdditionally, starting in version 2.0.0, \nMiddlewarePipe\n \nwill no longer implement\n\nZend\\Stratigility\\MiddlewareInterface\n, and only implement the\nhttp-interop/http-middleware \nMiddlewareInterface\n. This has several\nrepercussions.\n\n\nCallable middleware in version 1.3.0\n\n\nCallable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.\n\n\nFirst, \nwe recommend \nnever\n using the \n$response\n argument provided to\nmiddleware.\n\n\nThe reason for this recommendation is two-fold. First, the http-interop/http-middleware\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.\n\n\nAs an example, consider the following:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return $next($request, $response-\nwithHeader('X-Foo', 'Bar'));\n});\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =\n time()]);\n});\n\n\n\nThe first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware, \ncreates and returns an entirely new response\n,\nmaking the new header disappear.\n\n\nAs such, we recommend rewriting such middleware to modify the \nreturned\n\nresponse instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response-\nwithHeader('X-Foo', 'Bar');\n});\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =\n time()]);\n});\n\n\n\nThe above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.\n\n\nSecond, either wrap your middleware in \nCallableMiddlewareWrapper\n, or ensure\nyour pipeline composes a \nresponse prototype\n (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop/http-middleware delegators.\n\n\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-middleware:\n$pipeline-\npipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline-\nsetResponsePrototype($response);\n$pipeline-\npipe($middleware);\n\n\n\n\n\nCallableMiddlewareWrapper and Stratigility 2.0\n\n\nAs noted above, version 2 of Stratigility is incompatible with version 1.3 due\nto signature changes in the http-middleware project. However, if you wrap your\ncallable middleware using \nCallableMiddlewareWrapper\n, you will need to make\nno changes in your application to make it forwards compatible.\n\n\nWe recommend using this strategy if you need to do a stepped transition to\nStratigility 2.0.\n\n\n\n\nThird, and optionally, you can make one or both of the following changes to\nyour callable middleware:\n\n\n\n\nTypehint the final \n$next\n argument against \nInterop\\Http\\Middleware\\DelegateInterface\n;\n  optionally, rename it to \n$delegate\n. This will require a slight change to\n  how you invoke the next layer as well; see below.    \n\n\nRemove the \n$response\n argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.\n\n\n\n\nAs an example of the first:\n\n\nfunction ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate-\nprocess($request);\n    return $response-\nwithHeader('X-Foo', 'Bar');\n}\n\n\n\nAs an example of adopting both practices:\n\n\nfunction ($request, DelegateInterface $delegate) {\n    $response = $delegate-\nprocess($request);\n    return $response-\nwithHeader('X-Foo', 'Bar');\n}\n\n\n\nAt this point, you have essentially implemented \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n\n(with the notable exception of not type-hinting the \n$request\n argument).\nWhen you pipe such callable middleware to \nMiddlewarePipeline\n, it will be\nwrapped in a \nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n,\nwhich simply proxies to the middleware when processed.\n\n\n\n\nDelegateInterface and Stratigility 2.0\n\n\nSince the namespace within http-interop/http-middleware changes between\nversion 0.2.0 and 0.4.1, the above strategy will require making changes\nmultiple times: once when upgrading to Stratigility 1.3, and another when\nupgrading to 2.0. As such, we recommend instead decorating your callable\nmiddleware using the \nCallableMiddlewareWrapper\n, until such time as you can\nrewrite your middleware to implement the http-middleware 0.4.1 interfaces.\n\n\n\n\nFinally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop/http-middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.\n\n\nAs an example, consider the following middleware class:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\nThis could be rewritten as follows:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\nIf we were dealing with callable middleware instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =\n time()]);\n});\n\n\n\nwe could wrap this in an anonymous class instead:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline-\npipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n});\n\n\n\n\n\nUsing anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.\n\n\n\n\nIf you want your middleware to work with either http-interop/http-middleware or\nwith the pre-1.3.0 middleware signature, you can do that as well. To accomplish\nthis, we provide \nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n, which\nwill wrap a \ncallable $next\n such that it may be used as a \nDelegateInterface\n\nimplementation:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this-\nprocess($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\n\n\nImplementing http-interop between Stratigility 1.3 and 2.0\n\n\nWhile you \ncan\n write your middleware to implement the\nhttp-interop/http-middleware middleware interface, please be aware that if you\ndo so, you will need to take additional steps when upgrading from 1.3 to 2.0.\n\n\nIn most cases, you should be able to simply change the import statements\nwithin your class file. As an example, if you have the following in your\nStratigility 1.3-based project:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n\n\nThe imports would become:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n\n\n\n\nTo summarize:\n\n\n\n\n\n\nNever work with the provided \n$response\n argument, but instead manipulate the\n  response returned from calling \n$next\n.\n\n\n\n\n\n\nEnsure your pipeline can decorate callable middleware as http-interop/http-middleware.\n  Do this by injecting a response prototype in the pipeline prior to piping any\n  middleware. (\nNote: this is not necessary if all callable middleware defines\n  exactly two parameters, with the second type-hinting on the http-interop\n  \nDelegateInterface\n.)\n\n\n\n\n\n\nConsider adapting your callable middleware to follow the http-interop middleware\n  signature (\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n);\n  this will make it forward-compatible. (Be aware that this may require changes\n  in import statements between Stratigility 1.3 and 2.0.)\n\n\n\n\n\n\nConsider updating your class-based middleware to implement the\n  http-interop/http-middleware server middleware interface, potentially keeping\n  the \n__invoke()\n method for interoperability with existing callable-based\n  middleware runners. (Be aware that this may require changes in import\n  statements between Stratigility\n  1.3 and 2.0.)\n\n\n\n\n\n\nThe first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-middleware, and to ensure your middleware works\nproperly across middleware stacks.\n\n\nCallable middleware in version 2.0.0\n\n\nCallable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:\n\n\n\n\n\n\nInject a \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory\n\n  instance via the pipeline's \nsetCallableMiddlewareDecorator()\n method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a \nResponseInterface\n in its constructor, and will use that\n  response when creating \nCallableMiddlewareWrapper\n instances.\n\n\n$factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline-\nsetCallableMiddlewareDecorator($factory);\n\n\n\n\n\n\n\nPass a response prototype before piping the callable middleware. If no\n  \nCallableMiddlewareWrapperFactory\n is present, this prototype will be\n  used to seed one for use with decorating callable middleware.\n\n\n$pipeline-\nsetResponsePrototype(new Response());\n\n\n\n\n\n\n\nManually decorate your middleware prior to passing it to the pipeline:\n\n\n$pipeline-\npipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-middleware signature already.\n\n\n\n\n\n\n\nInvoking MiddlewarePipe instances in version 2.0.0\n\n\nInvocation of the outermost middleware can now be done in two ways:\n\n\n\n\nUsing \n__invoke()\n. This now requires a third argument, \n$delegate\n, which\n  may be one of a \ncallable\n accepting \nServerRequestInterface\n and \nResponseInterface\n\n  arguments, or a \nDelegateInterface\n instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the \nMiddlewarePipe\n's internal queue is exhausted without returning\n  a response, and \nmust\n return a response itself. A good candidate for this\n  is the \nNoopFinalHandler\n.\n\n\nUsing \nprocess()\n. This argument requires a request and \nDelegateInterface\n\n  instance; again, the \nDelegateInterface\n instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.\n\n\n\n\nAs examples:\n\n\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline-\nprocess($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));\n\n\n\nOnce you have done so, you can process the returned request via an\n\nemitter\n.\n\n\nDeprecated functionality\n\n\nThe following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\Dispatch\n (class); this class is marked internal already,\n  but anybody extending \nNext\n and/or this class should be aware of its removal.\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (interface); error middleware\n  should now be implemented per the \nerror handling section above\n.\n\n\nThe \n$response\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n  \nCallableMiddlewareWrapper\n also ensures that a response argument is populated\n  and present when invoking callable middleware.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an \nE_USER_DEPRECATED\n notice, referencing this documentation.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\n\n\nInterface/signature changes\n\n\nThe following signature changes were made with the 2.0.0 release:\n\n\n\n\nZend\\Stratigility\\Next\n:\n\n\nThe \n$done\n constructor argument was renamed to \n$nextDelegate\n, and now\n    allows either \ncallable\n or \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n\n    arguments.\n\n\nThe \n$response\n argument to \n__invoke()\n was removed.\n\n\nThe (optional) \n$err\n argument to \n__invoke()\n was removed.\n\n\n\n\nRemoved functionality\n\n\nThe following classes, methods, and arguments are removed starting in version\n2.0.0.\n\n\n\n\nZend\\Stratigility\\Dispatch\n (class)\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (class)\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\MiddlewareInterface\n. Define your middleware as callables,\n  or using http-interop/http-middleware interfaces instead.\n\n\nZend\\Stratigility\\Utils::getArity()\n (static method); no longer used\n  internally.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method. If\n  passed, it will now be ignored.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\nThe \n$response\n argument to middleware is deprecated; please see the\n  \nsection on callable middleware\n\n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop/http-middleware interface.", 
            "title": "To Version 2"
        }, 
        {
            "location": "/migration/to-v2/#migrating-to-version-2", 
            "text": "Version 2 of Stratigility makes several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.  To help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.", 
            "title": "Migrating to version 2"
        }, 
        {
            "location": "/migration/to-v2/#original-request-response-and-uri", 
            "text": "In the original 1.X releases, Stratigility would decorate the request and\nresponse instances with  Zend\\Stratigility\\Http\\Request  and Zend\\Stratigility\\Http\\Response , respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated ( Next  truncates matched paths when executing a layer\nif a path was provided when piping the middleware).  Internally, prior to 1.3, only  Zend\\Stratigility\\FinalHandler  was still using\nthis functionality:   It would query the original request to get the original URI when creating a\n  404 response message.  It passes the decorated request and response instances to  onerror  handlers.   Starting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.  If you still need access to the original request, response, or URI instance, we\nrecommend the following:   Pipe  Zend\\Stratigility\\Middleware\\OriginalMessages  as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:  originalRequest , mapping to the request provided to it at invocation.  originalResponse , mapping to the response provided to it at invocation.  originalUri , mapping to the URI composed by the request provided to it at\n  invocation.     You can then access these values within other middleware:  $originalRequest = $request- getAttribute('originalRequest');\n$originalResponse = $request- getAttribute('originalResponse');\n$originalUri = $request- getAttribute('originalUri');  Internally, starting with 1.3.0, we have updated the request decorator to add\nthe  originalRequest  attribute, and the  FinalHandler  to check for this,\ninstead of the decorated instance.  Finally, if you are creating an  onerror  handler for the  FinalHandler , update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.  The  Zend\\Stratigility\\Http  classes, interfaces, and namespace are removed\nin version 2.0.0.", 
            "title": "Original request, response, and URI"
        }, 
        {
            "location": "/migration/to-v2/#error-handling", 
            "text": "Prior to version 1.3, the recommended way to handle errors was via error middleware , special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the  Next  implementation when the middleware stack is exhausted,\nbut no response has been returned.  These approaches, however, have several shortcomings:   No other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls  $next()  with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.  The  FinalHandler  implementation hits edge cases when empty responses are\n  intended.  Neither combination works well with error or exception handlers.   Starting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.  The first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the  MiddlewarePipe::raiseThrowables()  method:  $pipeline = new MiddlewarePipe();\n$pipeline- raiseThrowables();  Once you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:   NotFoundHandler middleware  ErrorHandler middleware  Zend\\Stratigility\\NoopFinalHandler  (see next section)   Updating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.", 
            "title": "Error handling"
        }, 
        {
            "location": "/migration/to-v2/#no-op-final-handler", 
            "text": "When using the  NotFoundHandler  and  ErrorHandler  middleware (or custom\nmiddleware you drop in place of them), the  FinalHandler  implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.  However, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form of\n\"final\" handler that can do so. (In fact, starting in version 2, the  $out \nargument is renamed to  $delegate , and is a  required  argument of the MiddlewarePipe .)  Starting in version 1.3, we now offer a  Zend\\Stratigility\\NoopFinalHandler \nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:   By passing it explicitly when invoking the middleware pipeline.  By passing it to  Zend\\Diactoros\\Server::listen() .   If you are not using  Zend\\Diactoros\\Server  to execute your application, but\ninstead invoking your pipeline manually, use the following:  $response = $app($request, $response, new NoopFinalHandler());  If you are using  Zend\\Diactoros\\Server , you will need to pass the final\nhandler you wish to use as an argument to the  listen()  method; that method\nwill then pass that value as the third argument to  MiddlewarePipe  as shown\nabove:  $server- listen(new NoopFinalHandler());  Both approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.  (You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)  To summarize:   Call the  raiseThrowables()  method of your  MiddlewarePipe  instance to\n  opt-in to the new error handling strategy.  Use the new  Zend\\Stratigility\\Middleware\\NotFoundHandler  as the innermost\n  layer of your application pipeline in order to provide 404 responses.  Use the new  Zend\\Stratigility\\Middleware\\ErrorHandler  middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.  Use the  Zend\\Stratigility\\NoopFinalHandler  as the  $out  argument when\n  dispatching your application pipeline.", 
            "title": "No-op final handler"
        }, 
        {
            "location": "/migration/to-v2/#http-interop-compatibility", 
            "text": "", 
            "title": "http-interop compatibility"
        }, 
        {
            "location": "/migration/to-v2/#http-middleware-020-and-stratigility-13", 
            "text": "Starting in version 1.3.0, we offer compatibility with http-interop/http-middleware 0.2.0 .\nThat version of the specification defines the following interfaces:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}  The support in version 1.3.0 consists of the following:   MiddlewarePipe  now also implements  ServerMiddlewareInterface , and allows\n  piping either type of http-interop middleware.  Next  now also implements  DelegateInterface .  Dispatch  is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.   Additionally,  MiddlewarePipe  will now allow composing a  response prototype ;\nthis is a PSR-7  ResponseInterface  instance. If not set, the first time the\npipeline is invoked via its  __invoke()  method, it will set the prototype from\nthe provided  $response  argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.", 
            "title": "http-middleware 0.2.0 and Stratigility 1.3"
        }, 
        {
            "location": "/migration/to-v2/#http-middleware-041-and-stratigility-20", 
            "text": "http-interop/http-middleware 0.4.1 introduces breaking changes in the\ninterfaces, including the following:    The namespace changes from  Interop\\Http\\Middleware  to\n   Interop\\Http\\ServerMiddleware , signaling a change indicating that the project\n  now only targets server-side middleware.    The interface  ServerMiddlewareInterface  is now more simply\n   MiddlewareInterface , as the namespace indicates its usage in server-side\n  applications.  Interop\\Http\\Middleware\\MiddlewareInterface , which targeted\n  client-side middleware, was removed entirely.    The method  DelegateInterface::process  now accepts specifically a\n   Psr\\Http\\Message\\ServerRequestInterface , and not the more general\n   RequestInterface .    The first two changes required only a change in import statements to\naccommodate, and could have been imported in parallel to the 0.2.0 interfaces.\nHowever, the second represents a signature change, which has necessitated a\nmajor version bump in Stratigility in order to remain compatible.  Stratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that\nversion (and compatible versions) only.  Additionally, starting in version 2.0.0,  MiddlewarePipe   will no longer implement Zend\\Stratigility\\MiddlewareInterface , and only implement the\nhttp-interop/http-middleware  MiddlewareInterface . This has several\nrepercussions.", 
            "title": "http-middleware 0.4.1 and Stratigility 2.0"
        }, 
        {
            "location": "/migration/to-v2/#callable-middleware-in-version-130", 
            "text": "Callable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.  First,  we recommend  never  using the  $response  argument provided to\nmiddleware.  The reason for this recommendation is two-fold. First, the http-interop/http-middleware\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.  As an example, consider the following:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return $next($request, $response- withHeader('X-Foo', 'Bar'));\n});\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =  time()]);\n});  The first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware,  creates and returns an entirely new response ,\nmaking the new header disappear.  As such, we recommend rewriting such middleware to modify the  returned \nresponse instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response- withHeader('X-Foo', 'Bar');\n});\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =  time()]);\n});  The above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.  Second, either wrap your middleware in  CallableMiddlewareWrapper , or ensure\nyour pipeline composes a  response prototype  (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop/http-middleware delegators.  use Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-middleware:\n$pipeline- pipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline- setResponsePrototype($response);\n$pipeline- pipe($middleware);", 
            "title": "Callable middleware in version 1.3.0"
        }, 
        {
            "location": "/migration/to-v2/#callablemiddlewarewrapper-and-stratigility-20", 
            "text": "As noted above, version 2 of Stratigility is incompatible with version 1.3 due\nto signature changes in the http-middleware project. However, if you wrap your\ncallable middleware using  CallableMiddlewareWrapper , you will need to make\nno changes in your application to make it forwards compatible.  We recommend using this strategy if you need to do a stepped transition to\nStratigility 2.0.   Third, and optionally, you can make one or both of the following changes to\nyour callable middleware:   Typehint the final  $next  argument against  Interop\\Http\\Middleware\\DelegateInterface ;\n  optionally, rename it to  $delegate . This will require a slight change to\n  how you invoke the next layer as well; see below.      Remove the  $response  argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.   As an example of the first:  function ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate- process($request);\n    return $response- withHeader('X-Foo', 'Bar');\n}  As an example of adopting both practices:  function ($request, DelegateInterface $delegate) {\n    $response = $delegate- process($request);\n    return $response- withHeader('X-Foo', 'Bar');\n}  At this point, you have essentially implemented  Interop\\Http\\Middleware\\ServerMiddlewareInterface \n(with the notable exception of not type-hinting the  $request  argument).\nWhen you pipe such callable middleware to  MiddlewarePipeline , it will be\nwrapped in a  Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper ,\nwhich simply proxies to the middleware when processed.", 
            "title": "CallableMiddlewareWrapper and Stratigility 2.0"
        }, 
        {
            "location": "/migration/to-v2/#delegateinterface-and-stratigility-20", 
            "text": "Since the namespace within http-interop/http-middleware changes between\nversion 0.2.0 and 0.4.1, the above strategy will require making changes\nmultiple times: once when upgrading to Stratigility 1.3, and another when\nupgrading to 2.0. As such, we recommend instead decorating your callable\nmiddleware using the  CallableMiddlewareWrapper , until such time as you can\nrewrite your middleware to implement the http-middleware 0.4.1 interfaces.   Finally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop/http-middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.  As an example, consider the following middleware class:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}  This could be rewritten as follows:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}  If we were dealing with callable middleware instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' =  time()]);\n});  we could wrap this in an anonymous class instead:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline- pipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n});   Using anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.   If you want your middleware to work with either http-interop/http-middleware or\nwith the pre-1.3.0 middleware signature, you can do that as well. To accomplish\nthis, we provide  Zend\\Stratigility\\Delegate\\CallableDelegateDecorator , which\nwill wrap a  callable $next  such that it may be used as a  DelegateInterface \nimplementation:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this- process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}", 
            "title": "DelegateInterface and Stratigility 2.0"
        }, 
        {
            "location": "/migration/to-v2/#implementing-http-interop-between-stratigility-13-and-20", 
            "text": "While you  can  write your middleware to implement the\nhttp-interop/http-middleware middleware interface, please be aware that if you\ndo so, you will need to take additional steps when upgrading from 1.3 to 2.0.  In most cases, you should be able to simply change the import statements\nwithin your class file. As an example, if you have the following in your\nStratigility 1.3-based project:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;  The imports would become:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;   To summarize:    Never work with the provided  $response  argument, but instead manipulate the\n  response returned from calling  $next .    Ensure your pipeline can decorate callable middleware as http-interop/http-middleware.\n  Do this by injecting a response prototype in the pipeline prior to piping any\n  middleware. ( Note: this is not necessary if all callable middleware defines\n  exactly two parameters, with the second type-hinting on the http-interop\n   DelegateInterface .)    Consider adapting your callable middleware to follow the http-interop middleware\n  signature ( function (ServerRequestInterface $request, DelegateInterface $delegate) );\n  this will make it forward-compatible. (Be aware that this may require changes\n  in import statements between Stratigility 1.3 and 2.0.)    Consider updating your class-based middleware to implement the\n  http-interop/http-middleware server middleware interface, potentially keeping\n  the  __invoke()  method for interoperability with existing callable-based\n  middleware runners. (Be aware that this may require changes in import\n  statements between Stratigility\n  1.3 and 2.0.)    The first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-middleware, and to ensure your middleware works\nproperly across middleware stacks.", 
            "title": "Implementing http-interop between Stratigility 1.3 and 2.0"
        }, 
        {
            "location": "/migration/to-v2/#callable-middleware-in-version-200", 
            "text": "Callable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:    Inject a  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory \n  instance via the pipeline's  setCallableMiddlewareDecorator()  method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a  ResponseInterface  in its constructor, and will use that\n  response when creating  CallableMiddlewareWrapper  instances.  $factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline- setCallableMiddlewareDecorator($factory);    Pass a response prototype before piping the callable middleware. If no\n   CallableMiddlewareWrapperFactory  is present, this prototype will be\n  used to seed one for use with decorating callable middleware.  $pipeline- setResponsePrototype(new Response());    Manually decorate your middleware prior to passing it to the pipeline:  $pipeline- pipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-middleware signature already.", 
            "title": "Callable middleware in version 2.0.0"
        }, 
        {
            "location": "/migration/to-v2/#invoking-middlewarepipe-instances-in-version-200", 
            "text": "Invocation of the outermost middleware can now be done in two ways:   Using  __invoke() . This now requires a third argument,  $delegate , which\n  may be one of a  callable  accepting  ServerRequestInterface  and  ResponseInterface \n  arguments, or a  DelegateInterface  instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the  MiddlewarePipe 's internal queue is exhausted without returning\n  a response, and  must  return a response itself. A good candidate for this\n  is the  NoopFinalHandler .  Using  process() . This argument requires a request and  DelegateInterface \n  instance; again, the  DelegateInterface  instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.   As examples:  use Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline- process($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));  Once you have done so, you can process the returned request via an emitter .", 
            "title": "Invoking MiddlewarePipe instances in version 2.0.0"
        }, 
        {
            "location": "/migration/to-v2/#deprecated-functionality", 
            "text": "The following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.   Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\Dispatch  (class); this class is marked internal already,\n  but anybody extending  Next  and/or this class should be aware of its removal.  Zend\\Stratigility\\ErrorMiddlewareInterface  (interface); error middleware\n  should now be implemented per the  error handling section above .  The  $response  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n   CallableMiddlewareWrapper  also ensures that a response argument is populated\n  and present when invoking callable middleware.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an  E_USER_DEPRECATED  notice, referencing this documentation.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)", 
            "title": "Deprecated functionality"
        }, 
        {
            "location": "/migration/to-v2/#interfacesignature-changes", 
            "text": "The following signature changes were made with the 2.0.0 release:   Zend\\Stratigility\\Next :  The  $done  constructor argument was renamed to  $nextDelegate , and now\n    allows either  callable  or  Interop\\Http\\ServerMiddleware\\DelegateInterface \n    arguments.  The  $response  argument to  __invoke()  was removed.  The (optional)  $err  argument to  __invoke()  was removed.", 
            "title": "Interface/signature changes"
        }, 
        {
            "location": "/migration/to-v2/#removed-functionality", 
            "text": "The following classes, methods, and arguments are removed starting in version\n2.0.0.   Zend\\Stratigility\\Dispatch  (class)  Zend\\Stratigility\\ErrorMiddlewareInterface  (class)  Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\MiddlewareInterface . Define your middleware as callables,\n  or using http-interop/http-middleware interfaces instead.  Zend\\Stratigility\\Utils::getArity()  (static method); no longer used\n  internally.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method. If\n  passed, it will now be ignored.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)  The  $response  argument to middleware is deprecated; please see the\n   section on callable middleware \n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop/http-middleware interface.", 
            "title": "Removed functionality"
        }
    ]
}