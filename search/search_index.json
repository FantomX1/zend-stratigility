{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Stratigility\n\n\n\n\nFrom \"Strata\", Latin for \"layer\", and \"agility\".\n\n\n\n\nStratigility started as a port of \nSencha Connect\n\nto PHP. It allows you to build applications out of \nmiddleware\n.",
            "title": "Intro"
        },
        {
            "location": "/intro/#stratigility",
            "text": "From \"Strata\", Latin for \"layer\", and \"agility\".   Stratigility started as a port of  Sencha Connect \nto PHP. It allows you to build applications out of  middleware .",
            "title": "Stratigility"
        },
        {
            "location": "/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides\n  the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\nhttp-interop/http-middleware\n,\n  which provides the interfaces that will become PSR-15. In Stratigility 1.3,\n  this is pinned to the 0.2 series; in Stratigility 2.0, this is pinned to\n  0.4.1+. Since Stratigility 2.1 you have to explicitly define an\n  http-interop/http-middleware dependency in your \ncomposer.json\n, and you can\n  use any version which is currently supported by the polyfill package\n  \nwebimpress/http-middleware-compatibility\n;\n  if you are creating a new project, we recommend version 0.5.0 (though current\n  versions of Expressive may only support 0.4.1).\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nErrorHandler\n middleware and the\n  (legacy) \nFinalHandler\n implementation for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides\n  the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n   Diactoros .    http-interop/http-middleware ,\n  which provides the interfaces that will become PSR-15. In Stratigility 1.3,\n  this is pinned to the 0.2 series; in Stratigility 2.0, this is pinned to\n  0.4.1+. Since Stratigility 2.1 you have to explicitly define an\n  http-interop/http-middleware dependency in your  composer.json , and you can\n  use any version which is currently supported by the polyfill package\n   webimpress/http-middleware-compatibility ;\n  if you are creating a new project, we recommend version 0.5.0 (though current\n  versions of Expressive may only support 0.4.1).    zendframework/zend-escaper , used by the  ErrorHandler  middleware and the\n  (legacy)  FinalHandler  implementation for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/usage/",
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen(new NoopFinalHandler());\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen(new NoopFinalHandler());  The above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/middleware/",
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.\n\n\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\nuse Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator;\nuse Zend\\Stratigility\\NoopFinalHandler;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->setResponsePrototype(new Response());\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n$response = new Response();\n\n// Landing page\n$app->pipe(new CallableMiddlewareDecorator(\n    function ($request, $handler) use ($response) {\n        if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n            return $handler->handle($request);\n        }\n        $response->getBody()->write('Hello world!');\n        return $response;\n    }\n));\n\n// Another page\n$app->pipe(new PathMiddlewareDecorator(\n    '/foo', \n    new CallableMiddlewareDecorator(function ($request, $handler) use ($response) {\n        $response->getBody()->write('FOO!');\n        return $response;\n    })\n));\n\n$server->listen(new NoopFinalHandler());\n\n\n\nIn the above example, we have two examples of middleware. The first is a landing\npage, and listens to every request. If the request path is empty or \n/\n, it\ncompletes the response. If it is not, it passes off request handling to the\nmiddleware in the stack. The second middleware matches only on the path \n/foo\n\n\u2014 meaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report a 404 status.\n\n\nSo, concisely put, \nmiddleware accept a request, and decide if they can handle\nit and return a response, or need to delegate to another handler\n.\n\n\n\n\nMiddleware types\n\n\nStratigility allows a number of different types of middleware.\n\n\nThe type demonstrated above is callable middleware based on an\ninterface signature that forms the basis of the \nproposed PSR-15\nstandard\n.\n\n\nStratigility also supports:\n\n\n\n\nCallable \"double pass\" middleware.\n\n\nMiddleware implementing the proposed PSR-15 \nMiddlewareInterface\n.\n\n\n\n\nFor more details on the various middleware types accepted, including their\nsignatures, please read the \nchapter on creating middleware\n.\n\n\n\n\nMiddleware can decide more processing can be performed by calling on the\n\n$handler\n argument passed during invocation. With this paradigm, you can build\na workflow engine for handling requests \u2014 for instance, you could have\nmiddleware perform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:\n\n\n$app->pipe(new PathMiddlewareDecorator('/api', $apiMiddleware));\n$app->pipe(new PathMiddlewareDecorator('/docs', $apiDocMiddleware));\n$app->pipe(new PathMiddlewareDecorator('/files', $filesMiddleware));\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.",
            "title": "Middleware"
        },
        {
            "location": "/middleware/#middleware",
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.  use Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\nuse Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator;\nuse Zend\\Stratigility\\NoopFinalHandler;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->setResponsePrototype(new Response());\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n$response = new Response();\n\n// Landing page\n$app->pipe(new CallableMiddlewareDecorator(\n    function ($request, $handler) use ($response) {\n        if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n            return $handler->handle($request);\n        }\n        $response->getBody()->write('Hello world!');\n        return $response;\n    }\n));\n\n// Another page\n$app->pipe(new PathMiddlewareDecorator(\n    '/foo', \n    new CallableMiddlewareDecorator(function ($request, $handler) use ($response) {\n        $response->getBody()->write('FOO!');\n        return $response;\n    })\n));\n\n$server->listen(new NoopFinalHandler());  In the above example, we have two examples of middleware. The first is a landing\npage, and listens to every request. If the request path is empty or  / , it\ncompletes the response. If it is not, it passes off request handling to the\nmiddleware in the stack. The second middleware matches only on the path  /foo \n\u2014 meaning it will match  /foo ,  /foo/ , and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report a 404 status.  So, concisely put,  middleware accept a request, and decide if they can handle\nit and return a response, or need to delegate to another handler .",
            "title": "Middleware"
        },
        {
            "location": "/middleware/#middleware-types",
            "text": "Stratigility allows a number of different types of middleware.  The type demonstrated above is callable middleware based on an\ninterface signature that forms the basis of the  proposed PSR-15\nstandard .  Stratigility also supports:   Callable \"double pass\" middleware.  Middleware implementing the proposed PSR-15  MiddlewareInterface .   For more details on the various middleware types accepted, including their\nsignatures, please read the  chapter on creating middleware .   Middleware can decide more processing can be performed by calling on the $handler  argument passed during invocation. With this paradigm, you can build\na workflow engine for handling requests \u2014 for instance, you could have\nmiddleware perform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:  $app->pipe(new PathMiddlewareDecorator('/api', $apiMiddleware));\n$app->pipe(new PathMiddlewareDecorator('/docs', $apiDocMiddleware));\n$app->pipe(new PathMiddlewareDecorator('/files', $filesMiddleware));  The handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.",
            "title": "Middleware types"
        },
        {
            "location": "/error-handlers/",
            "text": "Error Handlers\n\n\nIn your application, you may need to handle error conditions:\n\n\n\n\nErrors raised by PHP itself (e.g., inability to open a file or database\n  connection).\n\n\nExceptions/throwables raised by PHP and/or code you write or consume.\n\n\nInability of any middleware to handle a request.\n\n\n\n\nYou can typically handle these conditions via middleware itself.\n\n\nHandling 404 conditions\n\n\n\n\nSince 1.3.0\n\n\n\n\nIf no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition, \nZend\\Stratigility\\Middleware\\NotFoundHandler\n. The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:\n\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nNote that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.\n\n\nIf you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\n\n\nMiddleware interface\n\n\nThe interfaces you implement and consume will vary based on the version of\nhttp-interop/http-middleware you have installed.\n\n\nIf you have version 0.4.1 installed, you will write middleware as noted above.\n\n\nFor 0.5.0, the above becomes:\n\n\nuse Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\n\n\nHandling PHP errors and exceptions\n\n\n\n\nSince 1.3.0\n\n\n\n\n\n\nOpting in to error middleware\n\n\nIf you have upgraded from Expressive 1.0.0, you will have been using the\n\nFinalHandler\n implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in \ntry/catch\n blocks.\n\n\nStarting in 1.3.0, we provide a new way to handle errors via middleware.\n\n\nIn version 1.3.0 and later v1 releases, you must opt-in to the system by\ncalling \nraiseThrowables()\n on your middleware pipeline:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();\n\n\n\nStarting in version 2, the new system is enabled by default, and the\n\nFinalHandler\n implementation no longer catches exceptions.\n\n\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n is a middleware implementation to\nregister as the \noutermost layer\n of your application (or close to the outermost\nlayer). It does the following:\n\n\n\n\nCreates a PHP error handler that catches any errors in the \nerror_handling()\n\n  mask and throws them as \nErrorException\n instances.\n\n\nWraps the invocation of the delegate in a try/catch block:\n\n\nif no exception is caught, and the result is a response, it returns it.\n\n\nif no exception is caught, it raises an exception, which will be caught.\n\n\nany caught exception is transformed into an error response.\n\n\n\n\nTo generate the error response, we provide the ability to inject a callable with\nthe following signature into the \nErrorHandler\n during instantiation:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe provide a default implementation, \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n,\nwhich generates an error response with a \n5XX\n series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.\n\n\nIn order to work, the \nErrorHandler\n needs a prototype response instance, and,\noptionally, an error response generator (if none is provided,\n\nErrorResponseGenerator\n is used, in production mode):\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n\n\nAs a full example, you can combine the two middleware into the same application\nas separate layers:\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nThe \nErrorResponseGenerator\n provides no templating facilities, and only\nresponds as \ntext/html\n. If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.\n\n\nAs an example:\n\n\nuse ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou would then pass this to the \nErrorHandler\n:\n\n\n$app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));\n\n\n\nErrorHandler Listeners\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n provides the ability to attach\n\nlisteners\n; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.\n\n\nListeners must implement the following signature:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nAttach listeners using \nErrorHandler::attachListener()\n:\n\n\n$errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});\n\n\n\nLegacy error middleware\n\n\n\n\nDeprecated starting in 1.3.0, removed in 2.0.0. Please see the\n  \nmigration guide\n for more details, as well\n  as the preceding section.\n\n\n\n\nTo handle errors, you can write middleware that accepts \nexactly\n four arguments:\n\n\nfunction ($error, $request, $response, $next) { }\n\n\n\nAlternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nWhen using \nMiddlewarePipe\n, as the queue is executed, if \n$next()\n is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call \n$next()\n.\n\nError handlers that call \n$next()\n SHOULD call it with the error it received itself, or with\nanother error.\n\n\nError handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.",
            "title": "Error Handlers"
        },
        {
            "location": "/error-handlers/#error-handlers",
            "text": "In your application, you may need to handle error conditions:   Errors raised by PHP itself (e.g., inability to open a file or database\n  connection).  Exceptions/throwables raised by PHP and/or code you write or consume.  Inability of any middleware to handle a request.   You can typically handle these conditions via middleware itself.",
            "title": "Error Handlers"
        },
        {
            "location": "/error-handlers/#handling-404-conditions",
            "text": "Since 1.3.0   If no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition,  Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:  // setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  Note that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.  If you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}",
            "title": "Handling 404 conditions"
        },
        {
            "location": "/error-handlers/#middleware-interface",
            "text": "The interfaces you implement and consume will vary based on the version of\nhttp-interop/http-middleware you have installed.  If you have version 0.4.1 installed, you will write middleware as noted above.  For 0.5.0, the above becomes:  use Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}",
            "title": "Middleware interface"
        },
        {
            "location": "/error-handlers/#handling-php-errors-and-exceptions",
            "text": "Since 1.3.0",
            "title": "Handling PHP errors and exceptions"
        },
        {
            "location": "/error-handlers/#opting-in-to-error-middleware",
            "text": "If you have upgraded from Expressive 1.0.0, you will have been using the FinalHandler  implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in  try/catch  blocks.  Starting in 1.3.0, we provide a new way to handle errors via middleware.  In version 1.3.0 and later v1 releases, you must opt-in to the system by\ncalling  raiseThrowables()  on your middleware pipeline:  $pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();  Starting in version 2, the new system is enabled by default, and the FinalHandler  implementation no longer catches exceptions.   Zend\\Stratigility\\Middleware\\ErrorHandler  is a middleware implementation to\nregister as the  outermost layer  of your application (or close to the outermost\nlayer). It does the following:   Creates a PHP error handler that catches any errors in the  error_handling() \n  mask and throws them as  ErrorException  instances.  Wraps the invocation of the delegate in a try/catch block:  if no exception is caught, and the result is a response, it returns it.  if no exception is caught, it raises an exception, which will be caught.  any caught exception is transformed into an error response.   To generate the error response, we provide the ability to inject a callable with\nthe following signature into the  ErrorHandler  during instantiation:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We provide a default implementation,  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator ,\nwhich generates an error response with a  5XX  series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.  In order to work, the  ErrorHandler  needs a prototype response instance, and,\noptionally, an error response generator (if none is provided, ErrorResponseGenerator  is used, in production mode):  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);  As a full example, you can combine the two middleware into the same application\nas separate layers:  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  The  ErrorResponseGenerator  provides no templating facilities, and only\nresponds as  text/html . If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.  As an example:  use ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}  You would then pass this to the  ErrorHandler :  $app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));",
            "title": "Opting in to error middleware"
        },
        {
            "location": "/error-handlers/#errorhandler-listeners",
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  provides the ability to attach listeners ; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.  Listeners must implement the following signature:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  Attach listeners using  ErrorHandler::attachListener() :  $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});",
            "title": "ErrorHandler Listeners"
        },
        {
            "location": "/error-handlers/#legacy-error-middleware",
            "text": "Deprecated starting in 1.3.0, removed in 2.0.0. Please see the\n   migration guide  for more details, as well\n  as the preceding section.   To handle errors, you can write middleware that accepts  exactly  four arguments:  function ($error, $request, $response, $next) { }  Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .  When using  MiddlewarePipe , as the queue is executed, if  $next()  is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call  $next() . Error handlers that call  $next()  SHOULD call it with the error it received itself, or with\nanother error.  Error handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.",
            "title": "Legacy error middleware"
        },
        {
            "location": "/creating-middleware/",
            "text": "Creating Middleware\n\n\nStratigility provides several ways to write middleware:\n\n\n\n\nBy implementing a standard interface.\n\n\nBy writing a PHP callable that uses the same signature as the standard\n  interface.\n\n\nBy writing a PHP callable accepting standard PSR-7 messages.\n\n\n\n\nThis document catalogs each of these, and includes pros and cons for each\npattern.\n\n\nIn all cases, middleware can do each (or all!) of the following:\n\n\n\n\nExamine a request, and return a response if certain requirements\n  are (or are not!) met.\n\n\nDelegate handling (and thus response generation) to the next layer.\n\n\nManipulate the response returned by a lower layer, and return the modified\n  version.\n\n\n\n\nWith each of the types below, we will demonstrate the same example: using an\nexternal router instance to attempt to route a request and delegate to the\nmiddleware matched.\n\n\nMiddlewareInterface\n\n\n\n\nSince 1.3.0\n\n\n\n\nThe \nPHP-FIG standards body\n identifies and ratifies\nstandards for community use. One of these,\n\nPSR-7\n is used by Stratigility to provide\nstandard HTTP message interfaces.\n\n\nAnother, the proposed \nPSR-15 (HTTP Server Request\nHandlers)\n,\ndefines interfaces for handling and producing these messages.\n\n\nThe specification has undergone several revisions via its working group, and\nthis version of Stratigility supports the following:\n\n\n\n\nhttp-interop/http-middleware v0.4.1\n\n\nhttp-interop/http-middleware v0.5.0\n\n\n\n\nThe two use different namespaces, and the intermediary interface is named\ndifferently between the two (and defines a different method).\n\n\nIf you are new to Stratigility, we suggest using the latest version of the spec,\nas it is closest to how the final PSR-15 specificaion defines the interfaces,\nand will only require changing the namespace from which you import the\ninterfaces later. If you are upgrading, however, choose the 0.4.1 version to\nretain existing compatibility.\n\n\nWhen writing middleware targeting http-middleware 0.4.1, define your middleware\nas follows:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MyMiddleware implements MiddlewareInterface\n{\n    private $router;\n\n    public function __construct($router)\n    {\n        $this->router = $router;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $this->router->route($path);\n        if (! $route) {\n            return $delegate->process($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n}\n\n\n\nUnder http-middleware 0.5.0, the example becomes the following:\n\n\nuse Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MyMiddleware implements MiddlewareInterface\n{\n    private $router;\n\n    public function __construct($router)\n    {\n        $this->router = $router;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $this->router->route($path);\n        if (! $route) {\n            return $handler->handle($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n}\n\n\n\nNote that the primary difference is the change from \nDelegateInterface\n to\n\nRequestHandlerInterface\n; also note that the method each defines is different\n(\nprocess\n vs \nhandle\n).\n\n\nCallable standards-signature middleware\n\n\n\n\nSince 1.3.0: \nCallableInteropMiddlewareWrapper\n\n\nSince 2.2.0: \nCallableMiddlewareDecorator\n\n\nDeprecated since 2.2.0: \nCallableInteropMiddlewareWrapper\n\n\n\n\nYou may also write PHP callables that fulfill the http-middleware interface\nsignatures as defined in the previous section.\n\n\nIf your middleware satisfies the http-interop 0.4.1 signature (which, in this\ncase, means that it expects a \nDelegateInterface\n, and will call its \nprocess()\n\nmethod), use \nCallableInteropMiddlewareWrapper\n:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper;\n\n$pipeline->pipe(new CallableInteropMiddlewareWrapper(\n    function ($request, $delegate) use ($router) {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $router->route($path);\n        if (! $route) {\n            return $delegate->process($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n))\n\n\n\nStarting in 2.0, when you pipe such middleware directly to \nMiddlewarePipe\n, it\ninternally decorates it for you using this class.\n\n\n\n\nCallableInteropMiddlewareWrapper deprecated\n\n\nThe \nCallableInteropMiddlewareWrapper\n is deprecated starting in version\n2.2.0, and will be removed entirely for version 3.0.0. We recommend updating\nyour code to use the \nCallableMiddlewareDecorator\n to make your code\nfuture-proof.\n\n\nIf possible, also upgrade to http-interop/http-middleware 0.5.0, and use the\n\nhandle()\n method of the \n$handler\n argument. \n\n\n\n\nIf your middleware satisfies the http-interop 0.5.0 signature (which, in this\ncase, means that it expects a \nRequestHandlerInterface\n, and will call its\n\nhandle()\n method), use \nCallableMiddlewareDecorator\n:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\n\n$pipeline->pipe(new CallableMiddlewareDecorator(\n    function ($request, $handler) use ($router) {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $router->route($path);\n        if (! $route) {\n            return $handler->handle($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n))\n\n\n\nStarting in 2.2.0, when you pipe such middleware directly to \nMiddlewarePipe\n,\nit internally decorates it for you using this class.\n\n\nDouble Pass Middleware\n\n\n\n\nSince 1.0.0: piping double-pass middleware directly\n\n\nSince 1.3.0: \nCallableMiddlewareWrapper\n since 1.3.0; deprecated in 2.2.0\n\n\nSince 2.2.0: \nDoublePassMiddlewareDecorator\n\n\nDeprecated since 2.2.0: piping double-pass middleware directly\n\n\nDeprecated since 2.2.0: \nCallableMiddlewareWrapper\n\n\n\n\nThe last style of middleware is called \"double pass\" middleware.\n\n\nThe signature of such middleware is as follows:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n)\n\n\n\nwhere the callable is expected to return a PSR-7 \nResponseInterface\n, and where\n\n$next\n has the following signature:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n)\n\n\n\nand is also expected to return a response.\n\n\nThis latter function is the basis for the name \"double pass\"; you pass \nboth\n a\nrequest \nand\n a response to the next layer.\n\n\nNeither the callable arguments nor the return value need typehints, though we\nrecommend them for type safety.\n\n\nIn versions prior to 2.0, you could pipe double-pass middleware directly to the\npipeline:\n\n\n$pipeline->pipe(function ($request, $response, $next) {});\n\n\n\nWhile this usage is still possible in the v2 series, we recommend against using\nit for two reasons:\n\n\n\n\nVersion 3 will no longer support direct piping of such middleware.\n\n\nThe signature does not follow the PSR-15 standards, making the middleware\n  non-portable to other PSR-15 middleware dispatcher stacks.\n\n\n\n\nAs such, we provide options for you to decorate such middleware.\n\n\n\n\nDo not operate on the response\n\n\nIf you are creating double pass middleware, do not use the \n$response\n\nargument passed to the middleware as anything other than a prototype\nfrom which to build a response to return from the method.\n\n\nIf you manipulate the response before passing it to the next layer, the next\nlayer may choose to return a completely different response; in the case of\nstandards-based middleware, it will never even receive the instance!\n\n\nIf changes to the response are necessary, operate only on the response\n\nreturned\n by the next layer.\n\n\n\n\nCallableMiddlewareWrapper\n\n\n\n\nSince 1.3.0\n\n\nDeprecated since 2.2.0\n\n\n\n\nOur first double-pass middleware decorator is\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n, which implements\neither the http-middleware 0.4.1 or 0.5.0 \nMiddlewareInterface\n, depending on\nwhat is installed:\n\n\n$pipeline->pipe(new CallableMiddlewareWrapper(\n    function ($request, $response, $next) {},\n    $responsePrototype\n));\n\n\n\nThe \n$responsePrototype\n argument is required, as without it, there is no\nresponse instance to pipe to the decorated middleware.\n\n\nStarting in 2.0, if you pipe such middleware directly to \nMiddlewarePipe\n, it\ninternally decorates it for you, as long as the pipeline also composes a\nresponse prototype:\n\n\n$pipeline->setResponsePrototype(new Response());\n$pipeline->pipe($doublePassMiddleware);\n\n\n\nWe recommend always decorating the middleware manually. We also recommend\nmigrating to the \nDoublePassMiddlewareDecorator\n to make your code forwards\ncompatible with version 3.\n\n\nDoublePassMiddlewareDecorator\n\n\n\n\nSince 2.2.0\n\n\n\n\nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n implements the\nhttp-middleware 0.5.0 \nMiddlewareInterface\n, and will be updated in version 3 to\nimplement the PSR-15 \nMiddlewareInterface\n:\n\n\n$pipeline->pipe(new CallableMiddlewareWrapper(\n    function ($request, $response, $next) {},\n    $responsePrototype\n));\n\n\n\nAs with the \nCallableMiddlewareWrapper\n, the \n$responsePrototype\n argument is\nrequired, as without it, there is no response instance to pipe to the decorated\nmiddleware.\n\n\nStarting in version 2.2.0, piping double pass middleware directly to\n\nMiddlewarePipe\n internally decorates it using the\n\nDoublePassMiddlewareDecorator\n internally, so long as you have also already\ncomposed a response prototype in the \nMiddlewarePipe\n instance.",
            "title": "Creating Middleware"
        },
        {
            "location": "/creating-middleware/#creating-middleware",
            "text": "Stratigility provides several ways to write middleware:   By implementing a standard interface.  By writing a PHP callable that uses the same signature as the standard\n  interface.  By writing a PHP callable accepting standard PSR-7 messages.   This document catalogs each of these, and includes pros and cons for each\npattern.  In all cases, middleware can do each (or all!) of the following:   Examine a request, and return a response if certain requirements\n  are (or are not!) met.  Delegate handling (and thus response generation) to the next layer.  Manipulate the response returned by a lower layer, and return the modified\n  version.   With each of the types below, we will demonstrate the same example: using an\nexternal router instance to attempt to route a request and delegate to the\nmiddleware matched.",
            "title": "Creating Middleware"
        },
        {
            "location": "/creating-middleware/#middlewareinterface",
            "text": "Since 1.3.0   The  PHP-FIG standards body  identifies and ratifies\nstandards for community use. One of these, PSR-7  is used by Stratigility to provide\nstandard HTTP message interfaces.  Another, the proposed  PSR-15 (HTTP Server Request\nHandlers) ,\ndefines interfaces for handling and producing these messages.  The specification has undergone several revisions via its working group, and\nthis version of Stratigility supports the following:   http-interop/http-middleware v0.4.1  http-interop/http-middleware v0.5.0   The two use different namespaces, and the intermediary interface is named\ndifferently between the two (and defines a different method).  If you are new to Stratigility, we suggest using the latest version of the spec,\nas it is closest to how the final PSR-15 specificaion defines the interfaces,\nand will only require changing the namespace from which you import the\ninterfaces later. If you are upgrading, however, choose the 0.4.1 version to\nretain existing compatibility.  When writing middleware targeting http-middleware 0.4.1, define your middleware\nas follows:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MyMiddleware implements MiddlewareInterface\n{\n    private $router;\n\n    public function __construct($router)\n    {\n        $this->router = $router;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $this->router->route($path);\n        if (! $route) {\n            return $delegate->process($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n}  Under http-middleware 0.5.0, the example becomes the following:  use Interop\\Http\\Server\\MiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MyMiddleware implements MiddlewareInterface\n{\n    private $router;\n\n    public function __construct($router)\n    {\n        $this->router = $router;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $this->router->route($path);\n        if (! $route) {\n            return $handler->handle($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n}  Note that the primary difference is the change from  DelegateInterface  to RequestHandlerInterface ; also note that the method each defines is different\n( process  vs  handle ).",
            "title": "MiddlewareInterface"
        },
        {
            "location": "/creating-middleware/#callable-standards-signature-middleware",
            "text": "Since 1.3.0:  CallableInteropMiddlewareWrapper  Since 2.2.0:  CallableMiddlewareDecorator  Deprecated since 2.2.0:  CallableInteropMiddlewareWrapper   You may also write PHP callables that fulfill the http-middleware interface\nsignatures as defined in the previous section.  If your middleware satisfies the http-interop 0.4.1 signature (which, in this\ncase, means that it expects a  DelegateInterface , and will call its  process() \nmethod), use  CallableInteropMiddlewareWrapper :  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper;\n\n$pipeline->pipe(new CallableInteropMiddlewareWrapper(\n    function ($request, $delegate) use ($router) {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $router->route($path);\n        if (! $route) {\n            return $delegate->process($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n))  Starting in 2.0, when you pipe such middleware directly to  MiddlewarePipe , it\ninternally decorates it for you using this class.",
            "title": "Callable standards-signature middleware"
        },
        {
            "location": "/creating-middleware/#callableinteropmiddlewarewrapper-deprecated",
            "text": "The  CallableInteropMiddlewareWrapper  is deprecated starting in version\n2.2.0, and will be removed entirely for version 3.0.0. We recommend updating\nyour code to use the  CallableMiddlewareDecorator  to make your code\nfuture-proof.  If possible, also upgrade to http-interop/http-middleware 0.5.0, and use the handle()  method of the  $handler  argument.    If your middleware satisfies the http-interop 0.5.0 signature (which, in this\ncase, means that it expects a  RequestHandlerInterface , and will call its handle()  method), use  CallableMiddlewareDecorator :  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\n\n$pipeline->pipe(new CallableMiddlewareDecorator(\n    function ($request, $handler) use ($router) {\n        $path = $request->getUri()->getPath();\n\n        // Route the path\n        $route = $router->route($path);\n        if (! $route) {\n            return $handler->handle($request);\n        }\n\n        $middleware = $route->getHandler();\n        return $middleware->process($request, $delegate);\n    }\n))  Starting in 2.2.0, when you pipe such middleware directly to  MiddlewarePipe ,\nit internally decorates it for you using this class.",
            "title": "CallableInteropMiddlewareWrapper deprecated"
        },
        {
            "location": "/creating-middleware/#double-pass-middleware",
            "text": "Since 1.0.0: piping double-pass middleware directly  Since 1.3.0:  CallableMiddlewareWrapper  since 1.3.0; deprecated in 2.2.0  Since 2.2.0:  DoublePassMiddlewareDecorator  Deprecated since 2.2.0: piping double-pass middleware directly  Deprecated since 2.2.0:  CallableMiddlewareWrapper   The last style of middleware is called \"double pass\" middleware.  The signature of such middleware is as follows:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n)  where the callable is expected to return a PSR-7  ResponseInterface , and where $next  has the following signature:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n)  and is also expected to return a response.  This latter function is the basis for the name \"double pass\"; you pass  both  a\nrequest  and  a response to the next layer.  Neither the callable arguments nor the return value need typehints, though we\nrecommend them for type safety.  In versions prior to 2.0, you could pipe double-pass middleware directly to the\npipeline:  $pipeline->pipe(function ($request, $response, $next) {});  While this usage is still possible in the v2 series, we recommend against using\nit for two reasons:   Version 3 will no longer support direct piping of such middleware.  The signature does not follow the PSR-15 standards, making the middleware\n  non-portable to other PSR-15 middleware dispatcher stacks.   As such, we provide options for you to decorate such middleware.",
            "title": "Double Pass Middleware"
        },
        {
            "location": "/creating-middleware/#do-not-operate-on-the-response",
            "text": "If you are creating double pass middleware, do not use the  $response \nargument passed to the middleware as anything other than a prototype\nfrom which to build a response to return from the method.  If you manipulate the response before passing it to the next layer, the next\nlayer may choose to return a completely different response; in the case of\nstandards-based middleware, it will never even receive the instance!  If changes to the response are necessary, operate only on the response returned  by the next layer.",
            "title": "Do not operate on the response"
        },
        {
            "location": "/creating-middleware/#callablemiddlewarewrapper",
            "text": "Since 1.3.0  Deprecated since 2.2.0   Our first double-pass middleware decorator is Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper , which implements\neither the http-middleware 0.4.1 or 0.5.0  MiddlewareInterface , depending on\nwhat is installed:  $pipeline->pipe(new CallableMiddlewareWrapper(\n    function ($request, $response, $next) {},\n    $responsePrototype\n));  The  $responsePrototype  argument is required, as without it, there is no\nresponse instance to pipe to the decorated middleware.  Starting in 2.0, if you pipe such middleware directly to  MiddlewarePipe , it\ninternally decorates it for you, as long as the pipeline also composes a\nresponse prototype:  $pipeline->setResponsePrototype(new Response());\n$pipeline->pipe($doublePassMiddleware);  We recommend always decorating the middleware manually. We also recommend\nmigrating to the  DoublePassMiddlewareDecorator  to make your code forwards\ncompatible with version 3.",
            "title": "CallableMiddlewareWrapper"
        },
        {
            "location": "/creating-middleware/#doublepassmiddlewaredecorator",
            "text": "Since 2.2.0   Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  implements the\nhttp-middleware 0.5.0  MiddlewareInterface , and will be updated in version 3 to\nimplement the PSR-15  MiddlewareInterface :  $pipeline->pipe(new CallableMiddlewareWrapper(\n    function ($request, $response, $next) {},\n    $responsePrototype\n));  As with the  CallableMiddlewareWrapper , the  $responsePrototype  argument is\nrequired, as without it, there is no response instance to pipe to the decorated\nmiddleware.  Starting in version 2.2.0, piping double pass middleware directly to MiddlewarePipe  internally decorates it using the DoublePassMiddlewareDecorator  internally, so long as you have also already\ncomposed a response prototype in the  MiddlewarePipe  instance.",
            "title": "DoublePassMiddlewareDecorator"
        },
        {
            "location": "/executing-middleware/",
            "text": "Composing middleware\n\n\nThe easiest way to compose middleware is to write closures or middleware classes\nand attach them to a \nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest\n\nMiddlewarePipe\n instances to create groups of related middleware, and attach\nthem using a base path so they only execute if that path is matched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"\n\n\n\n\n\nUse PathMiddlewareDecorator\n\n\n\n\nSince 2.2.0\n\n\n\n\nStarting in 2.2.0, the two argument form of \npipe()\n is deprecated in favor of\npiping a \nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n instance\ninstead. The above example would then become:\n\n\n$app->pipe(new PathMiddlewareDecorator('/api', $api));\n\n\n\nThis form is forwards compatible with the version 3 release.\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/') or use the\n\nPathMiddlewareDecorator\n, the middleware is dispatched with a request that\nstrips the matched segment(s) from the start of the path before dispatching\nthe middleware. Using the previous example, if the path \n/api/users/foo\n is\nmatched, the \n$api\n middleware will receive a request with the path\n\n/users/foo\n. This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.\n\n\n\n\nHandling errors\n\n\nWhile the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n class:\n\n\nuse Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(new ErrorHandler(new Response());\n// Add more middleware...\n\n\n\nYou can learn how to customize the error handler to your needs in the\n\nchapter on error handlers\n.\n\n\nExtending the MiddlewarePipe\n\n\nAnother approach is to extend the \nZend\\Stratigility\\MiddlewarePipe\n class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the \nprocess()\n\nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:\n\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}\n\n\n\nAnother approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call \nparent::__construct()\n to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}\n\n\n\nThese approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.\n\n\n\n\nExtension is deprecated\n\n\nStarting in version 2.2.0, extension of the \nMiddlewarePipe\n class is\ndeprecated, as version 3.0.0 will mark the class `final.\n\n\nInstead of extension, we thus recommend composition.\n\n\nWhen doing so, you will implement the http-interop \nMiddlewareInterface\n (and,\nin v3, the PSR-15 \nMiddlewareInterface\n), and compose the \nMiddlewarePipe\n\ninstance internally, delegating to it.\n\n\nAs a complete example, combining the previous two examples:\n\n\nclass CustomMiddleware imlements MiddlewareInterface\n{\n    private $pipeline;\n\n    public function __construct($configuration)\n    {\n        // Do something with configuration ...\n\n        // Create the pipeline:\n        $this->pipeline = new MiddlewarePipe();\n\n        // Attach some middleware ...\n        $this->pipeline->pipe(/* some middleware */);\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // perform some work...\n\n        // delegate to parent\n        $this->pipeline->process($request, $handler);\n\n        // maybe do more work?\n    }\n}",
            "title": "Composing middleware"
        },
        {
            "location": "/executing-middleware/#composing-middleware",
            "text": "The easiest way to compose middleware is to write closures or middleware classes\nand attach them to a  Zend\\Stratigility\\MiddlewarePipe  instance. You can nest MiddlewarePipe  instances to create groups of related middleware, and attach\nthem using a base path so they only execute if that path is matched.  $api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"",
            "title": "Composing middleware"
        },
        {
            "location": "/executing-middleware/#use-pathmiddlewaredecorator",
            "text": "Since 2.2.0   Starting in 2.2.0, the two argument form of  pipe()  is deprecated in favor of\npiping a  Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  instance\ninstead. The above example would then become:  $app->pipe(new PathMiddlewareDecorator('/api', $api));  This form is forwards compatible with the version 3 release.",
            "title": "Use PathMiddlewareDecorator"
        },
        {
            "location": "/executing-middleware/#request-path-changes-when-path-matched",
            "text": "When you pipe middleware using a path (other than '' or '/') or use the PathMiddlewareDecorator , the middleware is dispatched with a request that\nstrips the matched segment(s) from the start of the path before dispatching\nthe middleware. Using the previous example, if the path  /api/users/foo  is\nmatched, the  $api  middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/executing-middleware/#handling-errors",
            "text": "While the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler  class:  use Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(new ErrorHandler(new Response());\n// Add more middleware...  You can learn how to customize the error handler to your needs in the chapter on error handlers .",
            "title": "Handling errors"
        },
        {
            "location": "/executing-middleware/#extending-the-middlewarepipe",
            "text": "Another approach is to extend the  Zend\\Stratigility\\MiddlewarePipe  class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the  process() \nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:  class CustomMiddleware extends MiddlewarePipe\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call  parent::__construct()  to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.  use Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}  These approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Extending the MiddlewarePipe"
        },
        {
            "location": "/executing-middleware/#extension-is-deprecated",
            "text": "Starting in version 2.2.0, extension of the  MiddlewarePipe  class is\ndeprecated, as version 3.0.0 will mark the class `final.  Instead of extension, we thus recommend composition.  When doing so, you will implement the http-interop  MiddlewareInterface  (and,\nin v3, the PSR-15  MiddlewareInterface ), and compose the  MiddlewarePipe \ninstance internally, delegating to it.  As a complete example, combining the previous two examples:  class CustomMiddleware imlements MiddlewareInterface\n{\n    private $pipeline;\n\n    public function __construct($configuration)\n    {\n        // Do something with configuration ...\n\n        // Create the pipeline:\n        $this->pipeline = new MiddlewarePipe();\n\n        // Attach some middleware ...\n        $this->pipeline->pipe(/* some middleware */);\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // perform some work...\n\n        // delegate to parent\n        $this->pipeline->process($request, $handler);\n\n        // maybe do more work?\n    }\n}",
            "title": "Extension is deprecated"
        },
        {
            "location": "/api/",
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\n\n\nhttp-middleware\n\n\nStratigility has supported http-interop/http-middleware since version 2.0.0,\noriginally pinning to the 0.4.1 specification.\n\n\nStarting with version 2.1.0, we also support the 0.5.0 specification. In\noperation, they work identically. However, the namespace has changed, \n\nDelegateInterface\n was renamed to \nRequestHandlerInterface\n, and the\ndelegate/handler's \nprocess()\n method was renamed to \nhandle()\n.\n\n\nInternally, we use the package\n\nwebimpress/http-middleware-compatility\n\nto adapt middleware to work with any http-middleware version.  This package\nprovides polyfills for the various http-middleware versions, and a \"trick\" for\ncalling on the delegate/handler in a way that will work with any http-middleware\nversion that library supports.\n\n\nWhen you write your application, you will need to be aware of what version of\nhttp-middleware you have installed, and write your middleware to target it.\n\n\nAlternately, you can use the interfaces defined in\nwebimpress/http-middleware-compatility; read that package's documentation to\nunderstand how you can do so.\n\n\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and\nhas been discussed previously. Its API is:\n\n\nnamespace Zend\\Stratigility;\n\n// If http-interop/http-middleware 0.2 is installed:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// If http-interop/http-middleware 0.4.1 is installed:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n// If http-interop/http-middleware 0.5.0 is installed:\nuse Interop\\Http\\Server\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface as DelegateInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|ServerMiddlewareInterface $path,\n        callable|ServerMiddlewareInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        $delegate\n    ) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\npipe()\n takes up to two arguments. If only one argument is provided,\n\n$middleware\n will be assigned that value, and \n$path\n will be re-assigned to\nthe value \n/\n; this is an indication that the \n$middleware\n should be invoked\nfor any path. If \n$path\n is provided, the \n$middleware\n will only be executed\nfor that path and any subpaths.\n\n\n\n\nUse the PathMiddlewareDecorator to segregate middleware by path\n\n\n\n\nSince 2.2.0\n\n\n\n\nStarting in 2.2.0, we have deprecated the 2-argument form of \npipe()\n, as\nversion 3 will use only one argument, typehinted against the PSR-15\n\nMiddlewareInterface\n. Version 2.2.0 introduces a decorator for accomplishing\nthe same functionality:\n\n\nuse Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator;\n\n$pipeline->pipe(new PathMiddlewareDecorator($path, $middleware));\n\n\n\nIf you continue to use the 2-argument form of \npipe()\n, internally it will\ndecorate your middleware regardless \u2014 and also trigger a deprecation\nerror. To avoid the deprecation error, update your code today!\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/') or use the\n\nPathMiddlewareDecorator\n (as outlined in the previous note), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.\n\n\nIf, for example, you executed \n$pipeline->pipe('/api', $api)\n, and this was\nmatched via a URI with the path \n/api/users/foo\n, the \n$api\n middleware will\nreceive a request with the path \n/users/foo\n. This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.\n\n\n\n\nMiddleware is executed in the order in which it is piped to the\n\nMiddlewarePipe\n instance.\n\n\nThe \nMiddlewarePipe\n is itself middleware, and can be executed in stacks that\nexpect the \n__invoke()\n signature (via the \n__invoke()\n signature), or stacks\nexpecting http-interop middleware signatures (via the \nprocess()\n method).\n\n\n\n\nInvocation is deprecated\n\n\nStarting in version 2.2.0, invocation via \n__invoke()\n is deprecated.\n\n\n\n\nWhen using \n__invoke()\n, the callable \n$out\n argument should either implement\ndelegator/request handler interface from \nhttp-interop/http-middleware\n\n(depends on version you are using), or use the signature:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nMost often, you can pass an instance of \nZend\\Stratigility\\NoopFinalHandler\n for\n\n$out\n if invoking a middleware pipeline manually; otherwise, a suitable\ncallback will be provided for you (typically an instance of\n\nZend\\Stratigility\\Next\n, which \nMiddlewarePipe\n creates internally before\ndispatching to the various middleware in its pipeline).\n\n\nMiddleware should either return a response, or the result of\n\n$next()/DelegateInterface::process()/RequestHandlerInterface::handle()\n\n(which should eventually evaluate to a response instance).\n\n\nWithin Stratigility, \nZend\\Stratigility\\Next\n provides an implementation\ncompatible with either usage.\n\n\nStarting in version 1.3.0, \nMiddlewarePipe\n implements the\nhttp-interop/http-middleware server-side middleware interface, and thus provides\na \nprocess()\n method. This method requires a \nServerRequestInterface\n instance\nand an http-interop/http-middleware \nDelegateInterface\n instance on invocation;\nthe latter can be a \nNext\n instance, as it also implements that interface.\n\n\nInternally, for both \n__invoke()\n and \nprocess()\n, \nMiddlewarePipe\n creates an\ninstance of \nZend\\Stratigility\\Next\n (feeding it its queue), executes it, and\nreturns its response.\n\n\nResponse prototype\n\n\nStarting in version 1.3.0, you can compose a \"response prototype\" in the\n\nMiddlewarePipe\n. When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the \nsection on middleware\ndecorators\n, below) such that it will now conform to\nhttp-interop middleware interfaces.\n\n\nTo use this functionality, inject the prototype before piping middleware:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->setResponsePrototype(new Response());\n\n\n\n\n\nResponse prototype deprecated\n\n\nStarting in version 2.2.0, the \nsetResponsePrototype()\n method is deprecated.\nThis is because version 3 will no longer accept non-PSR-15 middleware.\nCallable middleware will need to be decorated using one of\n\nCallableMiddlewareDecorator\n (for callable middleware implementing the PSR-15\nsignature) or \nDoublePassMiddlewareDecorator\n (for callable middleware expecting\na response and \n$next\n argument). The latter decorator expects a response\nprototype as its second argument.\n\n\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an http-interop/http-middleware\n\nDelegateInterface\n and http-interop/http-server-handler\n\nRequestHandlerInterface\n.\n\n\nFunctor invocation\n\n\nBecause \nPsr\\Http\\Message\n's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain. \nNext\n expects\nthese arguments for every invocation.\n\n\nclass Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\nYou should \nalways\n either capture or return the return value of \n$next()\n\nwhen calling it in your application, or return a response yourself.\n\n\n\n\n$response argument\n\n\nUsing the \n$response\n argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.\n\n\nAs such, we recommend ignoring the \n$response\n argument and doing one of the\nfollowing:\n\n\n\n\nFor innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance. \nDiactoros provides a number of convenient custom responses\n.\n\n\nFor middleware delegating to another layer, operate on the \nreturned\n\n  response instead:\n\n\n\n\n$response = $next($request, $response);\nreturn $response->withHeader('X-Foo', 'Bar');\n\n\n\n\n\nDelegate invocation\n\n\n\n\nSince 1.3.0.\n\n\n\n\nWhen invoked as a \nDelegateInterface\n, the \nprocess()\n method will be invoked, and\npassed a \nServerRequestInterface\n instance \nonly\n. If you need to return a response,\nyou will need to:\n\n\n\n\nCompose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR\n\n\nCreate and return a concrete response type, OR\n\n\nOperate on a response returned by invoking the delegate.\n\n\n\n\nRequestHandler invocation\n\n\n\n\nSince 2.1.0\n\n\n\n\nWhen invoked as a \nRequestHandlerInterface\n, the \nhandle()\n method will be invoked, and\npassed a \nServerRequestInterface\n instance \nonly\n. If you need to return a response,\nyou will need to:\n\n\n\n\nCompose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR\n\n\nCreate and return a concrete response type, OR\n\n\nOperate on a response returned by invoking the delegate.\n\n\n\n\nProviding an altered request:\n\n\n// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop/http-middleware < 0.5 invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n// http-interop/http-middleware 0.5.0 invokable:\nfunction ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n\n\nProviding an altered request and operating on the returned response:\n\n\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $response = $next(\n        $request->withBodyParams($bodyParser($request)),\n        $response\n    );\n\n    return $response->withAddedHeader('Cache-Control', [\n}\n\n// http-interop/http-middleware < 0.5 invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n// http-interop/http-middleware 0.5.0 invokable:\nfunction ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n\n\nReturning a response to complete the request\n\n\nIf your middleware does not need to delegate to another layer, it's time to\nreturn a response.\n\n\nWhile we pass a response when using \nNext\n as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.\n\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n\n    return $response;\n}\n\n// http-interop/http-middleware < 0.5 invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}\n\n// http-interop/http-middleware 0.5.0 invokable signature:\nfunction ($request, RequestHandlerInterface $handler) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}\n\n\n\nDelegation\n\n\nIf your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.\n\n\nWhen using the legacy middleware signature, invoke the \n$next\n argument:\n\n\nreturn $next($request, $response);\n\n\n\nIf you are using \nhttp-interop/http-middleware\n in versions lower than 0.5.0,\nthen the delegate implements \nDelegateInterface\n; invoke its \nprocess()\n method:\n\n\nreturn $delegate->process($request);\n\n\n\nIf you are using \nhttp-interop/http-middleware\n versions 0.5.0 or above, then\nthe delegate implements \nRequestHandlerInterface\n; invoke its \nhandle()\n method:\n\n\nreturn $handler->handle($request);\n\n\n\nMiddleware should always return a response, and, if it cannot, return the\nresult of delegation.\n\n\nRaising an error condition\n\n\nIf your middleware cannot complete \u2014 perhaps a database error occurred, a\nservice was unreachable, etc. \u2014 how can you report the error?\n\n\nRaise an exception!\n\n\nfunction ($request, $response, $next) use ($service)\n{\n    $result = $service->fetchSomething();\n    if (! $result->isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}\n\n\n\nUse the \nErrorHandler middleware\n\nto handle exceptions thrown by your middleware and report the error condition to\nyour users.\n\n\nHTTP Messages\n\n\nZend\\Stratigility\\Http\\Request\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Request\n acts as a decorator for a \nPsr\\Http\\Message\\ServerRequestInterface\n\ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.\n\n\nAs an example, consider the following:\n\n\n$app1 = new Middleware();\n$app1->pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2->pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);\n\n\n\nIn the above, if the URI of the original incoming request is \n/root/foo\n, what \n$fooCallback\n will\nreceive is a URI with a past consisting of only \n/foo\n. This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.\n\n\nIf you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014 \nZend\\Stratigility\\Http\\Request\n contains a method, \ngetOriginalRequest()\n,\nwhich will always return the original request provided to the application:\n\n\nfunction ($request, $response, $next)\n{\n    $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]';\n    $response = $response->setHeader('Location', $location);\n    $response = $response->setStatus(302);\n    return $response;\n}\n\n\n\nZend\\Stratigility\\Http\\Response\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Response\n acts as a decorator for a \nPsr\\Http\\Message\\ResponseInterface\n\ninstance, and also implements \nZend\\Stratigility\\Http\\ResponseInterface\n, which provides the\nfollowing convenience methods:\n\n\n\n\nwrite()\n, which proxies to the \nwrite()\n method of the composed response stream.\n\n\nend()\n, which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the \nwrite()\n method. Once \nend()\n has been called, the response is\n  immutable and will throw an exception if a state mutating method like \nwithHeader\n is called.\n\n\nisComplete()\n indicates whether or not \nend()\n has been called.\n\n\n\n\nAdditionally, it provides access to the original response created by the server via the method\n\ngetOriginalResponse()\n.\n\n\nMiddleware\n\n\nStratigility provides several concrete middleware implementations.\n\n\nErrorHandler and NotFoundHandler\n\n\nThese two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the\n\nerror handling chapter\n.\n\n\nOriginalMessages\n\n\nThis callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the \nmigration chapter\n\nfor more details.\n\n\nMiddleware Decorators\n\n\nThe following decorator classes are each in the \nZend\\Stratigility\\Middleware\n\nnamespace, and fulfill the installed \nMiddlewareInterface\n based on the\nhttp-interop/http-middleware version installed in your application.\n\n\nYou can manually decorate callable middleware using these decorators, or instead\nlet \nMiddlewarePipe\n do the work for you. To let \nMiddlewarePipe\n handle this,\nhowever, you \nmust\n compose a response prototype prior to piping middleware\nusing the double pass middleware signature.\n\n\nPathMiddlewareDecorator\n\n\n\n\nSince 2.2.0\n\n\n\n\nThe \nPathMiddlewareDecorator\n can be used to segregate middleware by request URI\npath prefix. This can be done for several purposes:\n\n\n\n\nTo execute such middleware only if a given path prefix is matched; e.g.,\n  if you have middleware you want to run for every URI that matches\n  \n/api\n (e.g., to run rate limiting middleware).\n\n\nTo re-use an existing middleware that has its own internal routing under a\n  specific path; e.g., a \"shopping cart\" middleware pipeline/application that\n  you wish to run under the path \n/store\n on one site, but under \n/shop\n on\n  another, while otherwise retaining the same functionality.\n\n\n\n\nThe \nPathMiddlewareDecorator\n constructor accepts two arguments: a string path\nprefix to match, and an http-interop \nMiddlewareInterface\n instance:\n\n\n$middleware = new PathMiddlewareDecorator('/api', $apiMiddleware);\n\n\n\nWhen the path prefix is matched in the current request, the decorator will\nstrip the path prefix from the request passed to the composed middleware.\n\n\nIf the middleware calls on the handler, the decorator will replace the request\nURI's path with the path from the original request before invoking the handler.\n\n\nCallableMiddlewareDecorator\n\n\n\n\nSince 2.2.0\n\n\n\n\nThis class will decorate any PHP callable middleware that follows the signatures\nof either of the \nMiddlewareInterface\n from either the 0.4.1 or 0.5.0 version of\nthe http-interop/http-middleware package.\n\n\nTypically, this looks like:\n\n\nfunction ($request, $handler) : Psr\\Http\\Message\\ResponseInterface\n\n\n\nwhere \n$handler\n will either be of the type\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n or\n\nInterop\\Http\\Server\\RequestHandlerInterface\n, depending on the http-interop\nversion used in your application.\n\n\nThe decorator receives the PHP callable as its sole constructor argument, and is\nthen suitable for piping into the application:\n\n\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\n\n$pipeine->pipe(new CallableMiddlewareDecorator(function ($request, $handler) {\n    // ...\n}));\n\n\n\nThis class is forwards compatible with version 3.\n\n\nDoublePassMiddlewareDecorator\n\n\n\n\nSince 2.2.0\n\n\n\n\nThis class will decorate any PHP callable middleware that follows the \"\ndouble\npass signature\ndouble-pass\"  as a\n\nMiddlewareInterface\n implementation of either the 0.4.1 or 0.5.0 version of\nhttp-interop.\n\n\nTypically, this looks like:\n\n\nfunction ($request, $response, $next) : Psr\\Http\\Message\\ResponseInterface\n\n\n\nwhere \n$next\n is a callable for invoking the next middleware layer, and expects\n\n\nThe decorator receives the PHP callable and a PSR-7 \nResponseInterface\n instance\nas its arguments, and is then suitable for piping into the application:\n\n\nuse Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator;\n\n$pipeine->pipe(new DoublePassMiddlewareDecorator(\n    function ($request, $response, $next) {\n        // ...\n    },\n    $responsePrototype\n));\n\n\n\nThis class is forwards compatible with version 3.\n\n\nCallableInteropMiddlewareWrapper\n\n\n\n\nSince 1.3.0\n\n\nDeprecated since 2.2.0\n\n\n\n\nThis is a middleware decorator for PHP callables that have a signature\ncompatible with http-interop/http-middleware version 0.4.1 or 0.5.0. Please see\nthe \nCreating Middleware standards-based callable middleware\ndocumentation\n.\n\n\nCallableMiddlewareWrapper\n\n\n\n\nSince 1.3.0\n\n\nDeprecated since 2.2.0\n\n\n\n\nThis is a middleware decorator for PHP callables that follow the \ndouble pass\nsignature\n. If you plan use\ndouble pass middleware in version 2.2.0 or later, we recommend using the\n\nDoublePassMiddlewareDecorator\n instead.\n\n\nDelegates\n\n\n\n\nSince 2.0.0\n\n\nDeprecated since 2.2.0\n\n\n\n\nIn addition to \nZend\\Stratigility\\Next\n, Stratigility provides another\ndelegate/request handler implementation via \n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n. This class will work\nwith either http-interop/http-middleware 0.4.1 or 0.5.0, implementing the\n\nDelegateInterface\n in the case of the former, or the \nRequestHandlerInterface\n\nin the case of the latter.\n\n\nThis class can be used to wrap a callable \n$next\n instance for use in passing to\nan http-interop/http-middleware middleware interface \nprocess()\n method as a\ndelegate; the primary use case is adapting functor middleware to work as\nhttp-interop middleware.\n\n\nAs an example:\n\n\n// http-interop/http-middleware 0.2:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.4.1:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.5.0:\nuse Interop\\Http\\Server\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface as DelegateInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        // http-interop/http-middleware < 0.5\n        $response = $delegate->process($request);\n\n        // http-interop/http-middleware 0.5.0\n        $response = $delegate->handle($request);\n\n        return $response->withHeader('X-Processed-Timestamp', time());\n    }\n}\n\n\n\nUtility Functions\n\n\nStratigility provides the following utility functions.\n\n\npath\n\n\nfunction Zend\\Stratigility\\path(\n    string $pathPrefix,\n    Interop\\Http\\Server\\MiddlewareInterface|Interop\\Http\\ServerMiddleware\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n```\n\n`path()` provides a convenient way to perform path segregation when piping your\nmiddleware.\n\n```php\n$pipeline->pipe(path('/foo', $middleware));\n```\n\n### middleware\n\n\nfunction Zend\\Stratigility\\middleware(\n    callable $middleware\n) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n\n\n`middleware()` provides a convenient way to decorate callable middleware that\nimplements the PSR-15 middleware signature when piping it to your application.\n\n```php\n$pipeline->pipe(middleware(function ($request, $handler) {\n  // ...\n});\n\n\ndoublePassMiddleware\n\n\n`\nfunction Zend\\Stratigility\\doublePassMiddleware(\n    callable $middleware,\n    Psr\\Http\\Message\\ResponseInterface $responsePrototype = null\n) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n\n\ndoublePassiddleware()\n provides a convenient way to decorate middleware that\nimplements the double pass middleware signature when piping it to your application.\n\n\nphp\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n});\n\n\nIf you are not using zend-diactoros as a PSR-7 implementation, you will need to\npass a response prototype as well:\n\n\nphp\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n}, $response);",
            "title": "API Reference"
        },
        {
            "location": "/api/#api-reference",
            "text": "The following make up the primary API of Stratigility.",
            "title": "API Reference"
        },
        {
            "location": "/api/#http-middleware",
            "text": "Stratigility has supported http-interop/http-middleware since version 2.0.0,\noriginally pinning to the 0.4.1 specification.  Starting with version 2.1.0, we also support the 0.5.0 specification. In\noperation, they work identically. However, the namespace has changed,  DelegateInterface  was renamed to  RequestHandlerInterface , and the\ndelegate/handler's  process()  method was renamed to  handle() .  Internally, we use the package webimpress/http-middleware-compatility \nto adapt middleware to work with any http-middleware version.  This package\nprovides polyfills for the various http-middleware versions, and a \"trick\" for\ncalling on the delegate/handler in a way that will work with any http-middleware\nversion that library supports.  When you write your application, you will need to be aware of what version of\nhttp-middleware you have installed, and write your middleware to target it.  Alternately, you can use the interfaces defined in\nwebimpress/http-middleware-compatility; read that package's documentation to\nunderstand how you can do so.",
            "title": "http-middleware"
        },
        {
            "location": "/api/#middleware",
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and\nhas been discussed previously. Its API is:  namespace Zend\\Stratigility;\n\n// If http-interop/http-middleware 0.2 is installed:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// If http-interop/http-middleware 0.4.1 is installed:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n// If http-interop/http-middleware 0.5.0 is installed:\nuse Interop\\Http\\Server\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface as DelegateInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|ServerMiddlewareInterface $path,\n        callable|ServerMiddlewareInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        $delegate\n    ) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  pipe()  takes up to two arguments. If only one argument is provided, $middleware  will be assigned that value, and  $path  will be re-assigned to\nthe value  / ; this is an indication that the  $middleware  should be invoked\nfor any path. If  $path  is provided, the  $middleware  will only be executed\nfor that path and any subpaths.",
            "title": "Middleware"
        },
        {
            "location": "/api/#use-the-pathmiddlewaredecorator-to-segregate-middleware-by-path",
            "text": "Since 2.2.0   Starting in 2.2.0, we have deprecated the 2-argument form of  pipe() , as\nversion 3 will use only one argument, typehinted against the PSR-15 MiddlewareInterface . Version 2.2.0 introduces a decorator for accomplishing\nthe same functionality:  use Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator;\n\n$pipeline->pipe(new PathMiddlewareDecorator($path, $middleware));  If you continue to use the 2-argument form of  pipe() , internally it will\ndecorate your middleware regardless \u2014 and also trigger a deprecation\nerror. To avoid the deprecation error, update your code today!",
            "title": "Use the PathMiddlewareDecorator to segregate middleware by path"
        },
        {
            "location": "/api/#request-path-changes-when-path-matched",
            "text": "When you pipe middleware using a path (other than '' or '/') or use the PathMiddlewareDecorator  (as outlined in the previous note), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.  If, for example, you executed  $pipeline->pipe('/api', $api) , and this was\nmatched via a URI with the path  /api/users/foo , the  $api  middleware will\nreceive a request with the path  /users/foo . This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.   Middleware is executed in the order in which it is piped to the MiddlewarePipe  instance.  The  MiddlewarePipe  is itself middleware, and can be executed in stacks that\nexpect the  __invoke()  signature (via the  __invoke()  signature), or stacks\nexpecting http-interop middleware signatures (via the  process()  method).",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/api/#invocation-is-deprecated",
            "text": "Starting in version 2.2.0, invocation via  __invoke()  is deprecated.   When using  __invoke() , the callable  $out  argument should either implement\ndelegator/request handler interface from  http-interop/http-middleware \n(depends on version you are using), or use the signature:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Most often, you can pass an instance of  Zend\\Stratigility\\NoopFinalHandler  for $out  if invoking a middleware pipeline manually; otherwise, a suitable\ncallback will be provided for you (typically an instance of Zend\\Stratigility\\Next , which  MiddlewarePipe  creates internally before\ndispatching to the various middleware in its pipeline).  Middleware should either return a response, or the result of $next()/DelegateInterface::process()/RequestHandlerInterface::handle() \n(which should eventually evaluate to a response instance).  Within Stratigility,  Zend\\Stratigility\\Next  provides an implementation\ncompatible with either usage.  Starting in version 1.3.0,  MiddlewarePipe  implements the\nhttp-interop/http-middleware server-side middleware interface, and thus provides\na  process()  method. This method requires a  ServerRequestInterface  instance\nand an http-interop/http-middleware  DelegateInterface  instance on invocation;\nthe latter can be a  Next  instance, as it also implements that interface.  Internally, for both  __invoke()  and  process() ,  MiddlewarePipe  creates an\ninstance of  Zend\\Stratigility\\Next  (feeding it its queue), executes it, and\nreturns its response.",
            "title": "Invocation is deprecated"
        },
        {
            "location": "/api/#response-prototype",
            "text": "Starting in version 1.3.0, you can compose a \"response prototype\" in the MiddlewarePipe . When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the  section on middleware\ndecorators , below) such that it will now conform to\nhttp-interop middleware interfaces.  To use this functionality, inject the prototype before piping middleware:  $pipeline = new MiddlewarePipe();\n$pipeline->setResponsePrototype(new Response());",
            "title": "Response prototype"
        },
        {
            "location": "/api/#response-prototype-deprecated",
            "text": "Starting in version 2.2.0, the  setResponsePrototype()  method is deprecated.\nThis is because version 3 will no longer accept non-PSR-15 middleware.\nCallable middleware will need to be decorated using one of CallableMiddlewareDecorator  (for callable middleware implementing the PSR-15\nsignature) or  DoublePassMiddlewareDecorator  (for callable middleware expecting\na response and  $next  argument). The latter decorator expects a response\nprototype as its second argument.",
            "title": "Response prototype deprecated"
        },
        {
            "location": "/api/#next",
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an http-interop/http-middleware DelegateInterface  and http-interop/http-server-handler RequestHandlerInterface .",
            "title": "Next"
        },
        {
            "location": "/api/#functor-invocation",
            "text": "Because  Psr\\Http\\Message 's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain.  Next  expects\nthese arguments for every invocation.  class Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}  You should  always  either capture or return the return value of  $next() \nwhen calling it in your application, or return a response yourself.",
            "title": "Functor invocation"
        },
        {
            "location": "/api/#response-argument",
            "text": "Using the  $response  argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.  As such, we recommend ignoring the  $response  argument and doing one of the\nfollowing:   For innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance.  Diactoros provides a number of convenient custom responses .  For middleware delegating to another layer, operate on the  returned \n  response instead:   $response = $next($request, $response);\nreturn $response->withHeader('X-Foo', 'Bar');",
            "title": "$response argument"
        },
        {
            "location": "/api/#delegate-invocation",
            "text": "Since 1.3.0.   When invoked as a  DelegateInterface , the  process()  method will be invoked, and\npassed a  ServerRequestInterface  instance  only . If you need to return a response,\nyou will need to:   Compose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR  Create and return a concrete response type, OR  Operate on a response returned by invoking the delegate.",
            "title": "Delegate invocation"
        },
        {
            "location": "/api/#requesthandler-invocation",
            "text": "Since 2.1.0   When invoked as a  RequestHandlerInterface , the  handle()  method will be invoked, and\npassed a  ServerRequestInterface  instance  only . If you need to return a response,\nyou will need to:   Compose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR  Create and return a concrete response type, OR  Operate on a response returned by invoking the delegate.",
            "title": "RequestHandler invocation"
        },
        {
            "location": "/api/#providing-an-altered-request",
            "text": "// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop/http-middleware < 0.5 invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n// http-interop/http-middleware 0.5.0 invokable:\nfunction ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n}",
            "title": "Providing an altered request:"
        },
        {
            "location": "/api/#providing-an-altered-request-and-operating-on-the-returned-response",
            "text": "function ($request, $response, $next) use ($bodyParser)\n{\n    $response = $next(\n        $request->withBodyParams($bodyParser($request)),\n        $response\n    );\n\n    return $response->withAddedHeader('Cache-Control', [\n}\n\n// http-interop/http-middleware < 0.5 invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n// http-interop/http-middleware 0.5.0 invokable:\nfunction ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n}",
            "title": "Providing an altered request and operating on the returned response:"
        },
        {
            "location": "/api/#returning-a-response-to-complete-the-request",
            "text": "If your middleware does not need to delegate to another layer, it's time to\nreturn a response.  While we pass a response when using  Next  as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.  $prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n\n    return $response;\n}\n\n// http-interop/http-middleware < 0.5 invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}\n\n// http-interop/http-middleware 0.5.0 invokable signature:\nfunction ($request, RequestHandlerInterface $handler) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}",
            "title": "Returning a response to complete the request"
        },
        {
            "location": "/api/#delegation",
            "text": "If your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.  When using the legacy middleware signature, invoke the  $next  argument:  return $next($request, $response);  If you are using  http-interop/http-middleware  in versions lower than 0.5.0,\nthen the delegate implements  DelegateInterface ; invoke its  process()  method:  return $delegate->process($request);  If you are using  http-interop/http-middleware  versions 0.5.0 or above, then\nthe delegate implements  RequestHandlerInterface ; invoke its  handle()  method:  return $handler->handle($request);  Middleware should always return a response, and, if it cannot, return the\nresult of delegation.",
            "title": "Delegation"
        },
        {
            "location": "/api/#raising-an-error-condition",
            "text": "If your middleware cannot complete \u2014 perhaps a database error occurred, a\nservice was unreachable, etc. \u2014 how can you report the error?  Raise an exception!  function ($request, $response, $next) use ($service)\n{\n    $result = $service->fetchSomething();\n    if (! $result->isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}  Use the  ErrorHandler middleware \nto handle exceptions thrown by your middleware and report the error condition to\nyour users.",
            "title": "Raising an error condition"
        },
        {
            "location": "/api/#http-messages",
            "text": "",
            "title": "HTTP Messages"
        },
        {
            "location": "/api/#zendstratigilityhttprequest",
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Request  acts as a decorator for a  Psr\\Http\\Message\\ServerRequestInterface \ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.  As an example, consider the following:  $app1 = new Middleware();\n$app1->pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2->pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);  In the above, if the URI of the original incoming request is  /root/foo , what  $fooCallback  will\nreceive is a URI with a past consisting of only  /foo . This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.  If you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014  Zend\\Stratigility\\Http\\Request  contains a method,  getOriginalRequest() ,\nwhich will always return the original request provided to the application:  function ($request, $response, $next)\n{\n    $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]';\n    $response = $response->setHeader('Location', $location);\n    $response = $response->setStatus(302);\n    return $response;\n}",
            "title": "Zend\\Stratigility\\Http\\Request"
        },
        {
            "location": "/api/#zendstratigilityhttpresponse",
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Response  acts as a decorator for a  Psr\\Http\\Message\\ResponseInterface \ninstance, and also implements  Zend\\Stratigility\\Http\\ResponseInterface , which provides the\nfollowing convenience methods:   write() , which proxies to the  write()  method of the composed response stream.  end() , which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the  write()  method. Once  end()  has been called, the response is\n  immutable and will throw an exception if a state mutating method like  withHeader  is called.  isComplete()  indicates whether or not  end()  has been called.   Additionally, it provides access to the original response created by the server via the method getOriginalResponse() .",
            "title": "Zend\\Stratigility\\Http\\Response"
        },
        {
            "location": "/api/#middleware_1",
            "text": "Stratigility provides several concrete middleware implementations.",
            "title": "Middleware"
        },
        {
            "location": "/api/#errorhandler-and-notfoundhandler",
            "text": "These two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the error handling chapter .",
            "title": "ErrorHandler and NotFoundHandler"
        },
        {
            "location": "/api/#originalmessages",
            "text": "This callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the  migration chapter \nfor more details.",
            "title": "OriginalMessages"
        },
        {
            "location": "/api/#middleware-decorators",
            "text": "The following decorator classes are each in the  Zend\\Stratigility\\Middleware \nnamespace, and fulfill the installed  MiddlewareInterface  based on the\nhttp-interop/http-middleware version installed in your application.  You can manually decorate callable middleware using these decorators, or instead\nlet  MiddlewarePipe  do the work for you. To let  MiddlewarePipe  handle this,\nhowever, you  must  compose a response prototype prior to piping middleware\nusing the double pass middleware signature.",
            "title": "Middleware Decorators"
        },
        {
            "location": "/api/#pathmiddlewaredecorator",
            "text": "Since 2.2.0   The  PathMiddlewareDecorator  can be used to segregate middleware by request URI\npath prefix. This can be done for several purposes:   To execute such middleware only if a given path prefix is matched; e.g.,\n  if you have middleware you want to run for every URI that matches\n   /api  (e.g., to run rate limiting middleware).  To re-use an existing middleware that has its own internal routing under a\n  specific path; e.g., a \"shopping cart\" middleware pipeline/application that\n  you wish to run under the path  /store  on one site, but under  /shop  on\n  another, while otherwise retaining the same functionality.   The  PathMiddlewareDecorator  constructor accepts two arguments: a string path\nprefix to match, and an http-interop  MiddlewareInterface  instance:  $middleware = new PathMiddlewareDecorator('/api', $apiMiddleware);  When the path prefix is matched in the current request, the decorator will\nstrip the path prefix from the request passed to the composed middleware.  If the middleware calls on the handler, the decorator will replace the request\nURI's path with the path from the original request before invoking the handler.",
            "title": "PathMiddlewareDecorator"
        },
        {
            "location": "/api/#callablemiddlewaredecorator",
            "text": "Since 2.2.0   This class will decorate any PHP callable middleware that follows the signatures\nof either of the  MiddlewareInterface  from either the 0.4.1 or 0.5.0 version of\nthe http-interop/http-middleware package.  Typically, this looks like:  function ($request, $handler) : Psr\\Http\\Message\\ResponseInterface  where  $handler  will either be of the type Interop\\Http\\ServerMiddleware\\DelegateInterface  or Interop\\Http\\Server\\RequestHandlerInterface , depending on the http-interop\nversion used in your application.  The decorator receives the PHP callable as its sole constructor argument, and is\nthen suitable for piping into the application:  use Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\n\n$pipeine->pipe(new CallableMiddlewareDecorator(function ($request, $handler) {\n    // ...\n}));  This class is forwards compatible with version 3.",
            "title": "CallableMiddlewareDecorator"
        },
        {
            "location": "/api/#doublepassmiddlewaredecorator",
            "text": "Since 2.2.0   This class will decorate any PHP callable middleware that follows the \" double\npass signature double-pass\"  as a MiddlewareInterface  implementation of either the 0.4.1 or 0.5.0 version of\nhttp-interop.  Typically, this looks like:  function ($request, $response, $next) : Psr\\Http\\Message\\ResponseInterface  where  $next  is a callable for invoking the next middleware layer, and expects  The decorator receives the PHP callable and a PSR-7  ResponseInterface  instance\nas its arguments, and is then suitable for piping into the application:  use Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator;\n\n$pipeine->pipe(new DoublePassMiddlewareDecorator(\n    function ($request, $response, $next) {\n        // ...\n    },\n    $responsePrototype\n));  This class is forwards compatible with version 3.",
            "title": "DoublePassMiddlewareDecorator"
        },
        {
            "location": "/api/#callableinteropmiddlewarewrapper",
            "text": "Since 1.3.0  Deprecated since 2.2.0   This is a middleware decorator for PHP callables that have a signature\ncompatible with http-interop/http-middleware version 0.4.1 or 0.5.0. Please see\nthe  Creating Middleware standards-based callable middleware\ndocumentation .",
            "title": "CallableInteropMiddlewareWrapper"
        },
        {
            "location": "/api/#callablemiddlewarewrapper",
            "text": "Since 1.3.0  Deprecated since 2.2.0   This is a middleware decorator for PHP callables that follow the  double pass\nsignature . If you plan use\ndouble pass middleware in version 2.2.0 or later, we recommend using the DoublePassMiddlewareDecorator  instead.",
            "title": "CallableMiddlewareWrapper"
        },
        {
            "location": "/api/#delegates",
            "text": "Since 2.0.0  Deprecated since 2.2.0   In addition to  Zend\\Stratigility\\Next , Stratigility provides another\ndelegate/request handler implementation via  Zend\\Stratigility\\Delegate\\CallableDelegateDecorator . This class will work\nwith either http-interop/http-middleware 0.4.1 or 0.5.0, implementing the DelegateInterface  in the case of the former, or the  RequestHandlerInterface \nin the case of the latter.  This class can be used to wrap a callable  $next  instance for use in passing to\nan http-interop/http-middleware middleware interface  process()  method as a\ndelegate; the primary use case is adapting functor middleware to work as\nhttp-interop middleware.  As an example:  // http-interop/http-middleware 0.2:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.4.1:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.5.0:\nuse Interop\\Http\\Server\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Interop\\Http\\Server\\RequestHandlerInterface as DelegateInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        // http-interop/http-middleware < 0.5\n        $response = $delegate->process($request);\n\n        // http-interop/http-middleware 0.5.0\n        $response = $delegate->handle($request);\n\n        return $response->withHeader('X-Processed-Timestamp', time());\n    }\n}",
            "title": "Delegates"
        },
        {
            "location": "/api/#utility-functions",
            "text": "Stratigility provides the following utility functions.",
            "title": "Utility Functions"
        },
        {
            "location": "/api/#path",
            "text": "function Zend\\Stratigility\\path(\n    string $pathPrefix,\n    Interop\\Http\\Server\\MiddlewareInterface|Interop\\Http\\ServerMiddleware\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n```\n\n`path()` provides a convenient way to perform path segregation when piping your\nmiddleware.\n\n```php\n$pipeline->pipe(path('/foo', $middleware));\n```\n\n### middleware \nfunction Zend\\Stratigility\\middleware(\n    callable $middleware\n) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator \n`middleware()` provides a convenient way to decorate callable middleware that\nimplements the PSR-15 middleware signature when piping it to your application.\n\n```php\n$pipeline->pipe(middleware(function ($request, $handler) {\n  // ...\n});",
            "title": "path"
        },
        {
            "location": "/api/#doublepassmiddleware",
            "text": "`\nfunction Zend\\Stratigility\\doublePassMiddleware(\n    callable $middleware,\n    Psr\\Http\\Message\\ResponseInterface $responsePrototype = null\n) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  doublePassiddleware()  provides a convenient way to decorate middleware that\nimplements the double pass middleware signature when piping it to your application.  php\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n});  If you are not using zend-diactoros as a PSR-7 implementation, you will need to\npass a response prototype as well:  php\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n}, $response);",
            "title": "doublePassMiddleware"
        },
        {
            "location": "/migration/to-v2/",
            "text": "Migrating to version 2\n\n\nVersion 2 of Stratigility makes several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.\n\n\nTo help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.\n\n\nOriginal request, response, and URI\n\n\nIn the original 1.X releases, Stratigility would decorate the request and\nresponse instances with \nZend\\Stratigility\\Http\\Request\n and\n\nZend\\Stratigility\\Http\\Response\n, respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated (\nNext\n truncates matched paths when executing a layer\nif a path was provided when piping the middleware).\n\n\nInternally, prior to 1.3, only \nZend\\Stratigility\\FinalHandler\n was still using\nthis functionality:\n\n\n\n\nIt would query the original request to get the original URI when creating a\n  404 response message.\n\n\nIt passes the decorated request and response instances to \nonerror\n handlers.\n\n\n\n\nStarting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.\n\n\nIf you still need access to the original request, response, or URI instance, we\nrecommend the following:\n\n\n\n\nPipe \nZend\\Stratigility\\Middleware\\OriginalMessages\n as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:\n\n\noriginalRequest\n, mapping to the request provided to it at invocation.\n\n\noriginalResponse\n, mapping to the response provided to it at invocation.\n\n\noriginalUri\n, mapping to the URI composed by the request provided to it at\n  invocation.\n\n\n\n\n\n\n\n\nYou can then access these values within other middleware:\n\n\n$originalRequest = $request->getAttribute('originalRequest');\n$originalResponse = $request->getAttribute('originalResponse');\n$originalUri = $request->getAttribute('originalUri');\n\n\n\nInternally, starting with 1.3.0, we have updated the request decorator to add\nthe \noriginalRequest\n attribute, and the \nFinalHandler\n to check for this,\ninstead of the decorated instance.\n\n\nFinally, if you are creating an \nonerror\n handler for the \nFinalHandler\n, update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.\n\n\nThe \nZend\\Stratigility\\Http\n classes, interfaces, and namespace are removed\nin version 2.0.0.\n\n\nError handling\n\n\nPrior to version 1.3, the recommended way to handle errors was via\n\nerror middleware\n, special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the \nNext\n implementation when the middleware stack is exhausted,\nbut no response has been returned.\n\n\nThese approaches, however, have several shortcomings:\n\n\n\n\nNo other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls \n$next()\n with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.\n\n\nThe \nFinalHandler\n implementation hits edge cases when empty responses are\n  intended.\n\n\nNeither combination works well with error or exception handlers.\n\n\n\n\nStarting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.\n\n\nThe first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the \nMiddlewarePipe::raiseThrowables()\n method:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();\n\n\n\nOnce you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:\n\n\n\n\nNotFoundHandler middleware\n\n\nErrorHandler middleware\n\n\nZend\\Stratigility\\NoopFinalHandler\n (see next section)\n\n\n\n\nUpdating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.\n\n\nNo-op final handler\n\n\nWhen using the \nNotFoundHandler\n and \nErrorHandler\n middleware (or custom\nmiddleware you drop in place of them), the \nFinalHandler\n implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.\n\n\nHowever, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form of\n\"final\" handler that can do so. (In fact, starting in version 2, the \n$out\n\nargument is renamed to \n$delegate\n, and is a \nrequired\n argument of the\n\nMiddlewarePipe\n.)\n\n\nStarting in version 1.3, we now offer a \nZend\\Stratigility\\NoopFinalHandler\n\nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:\n\n\n\n\nBy passing it explicitly when invoking the middleware pipeline.\n\n\nBy passing it to \nZend\\Diactoros\\Server::listen()\n.\n\n\n\n\nIf you are not using \nZend\\Diactoros\\Server\n to execute your application, but\ninstead invoking your pipeline manually, use the following:\n\n\n$response = $app($request, $response, new NoopFinalHandler());\n\n\n\nIf you are using \nZend\\Diactoros\\Server\n, you will need to pass the final\nhandler you wish to use as an argument to the \nlisten()\n method; that method\nwill then pass that value as the third argument to \nMiddlewarePipe\n as shown\nabove:\n\n\n$server->listen(new NoopFinalHandler());\n\n\n\nBoth approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.\n\n\n(You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)\n\n\nTo summarize:\n\n\n\n\nCall the \nraiseThrowables()\n method of your \nMiddlewarePipe\n instance to\n  opt-in to the new error handling strategy.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\NotFoundHandler\n as the innermost\n  layer of your application pipeline in order to provide 404 responses.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\ErrorHandler\n middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.\n\n\nUse the \nZend\\Stratigility\\NoopFinalHandler\n as the \n$out\n argument when\n  dispatching your application pipeline.\n\n\n\n\nhttp-interop compatibility\n\n\nhttp-middleware 0.2.0 and Stratigility 1.3\n\n\nStarting in version 1.3.0, we offer compatibility with\n\nhttp-interop/http-middleware 0.2.0\n.\nThat version of the specification defines the following interfaces:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\n\n\nThe support in version 1.3.0 consists of the following:\n\n\n\n\nMiddlewarePipe\n now also implements \nServerMiddlewareInterface\n, and allows\n  piping either type of http-interop middleware.\n\n\nNext\n now also implements \nDelegateInterface\n.\n\n\nDispatch\n is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.\n\n\n\n\nAdditionally, \nMiddlewarePipe\n will now allow composing a \nresponse prototype\n;\nthis is a PSR-7 \nResponseInterface\n instance. If not set, the first time the\npipeline is invoked via its \n__invoke()\n method, it will set the prototype from\nthe provided \n$response\n argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.\n\n\nhttp-middleware 0.4.1 and Stratigility 2.0\n\n\nhttp-interop/http-middleware 0.4.1 introduces breaking changes in the\ninterfaces, including the following:\n\n\n\n\n\n\nThe namespace changes from \nInterop\\Http\\Middleware\n to\n  \nInterop\\Http\\ServerMiddleware\n, signaling a change indicating that the project\n  now only targets server-side middleware.\n\n\n\n\n\n\nThe interface \nServerMiddlewareInterface\n is now more simply\n  \nMiddlewareInterface\n, as the namespace indicates its usage in server-side\n  applications. \nInterop\\Http\\Middleware\\MiddlewareInterface\n, which targeted\n  client-side middleware, was removed entirely.\n\n\n\n\n\n\nThe method \nDelegateInterface::process\n now accepts specifically a\n  \nPsr\\Http\\Message\\ServerRequestInterface\n, and not the more general\n  \nRequestInterface\n.\n\n\n\n\n\n\nThe first two changes required only a change in import statements to\naccommodate, and could have been imported in parallel to the 0.2.0 interfaces.\nHowever, the second represents a signature change, which has necessitated a\nmajor version bump in Stratigility in order to remain compatible.\n\n\nStratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that\nversion (and compatible versions) only.\n\n\nAdditionally, starting in version 2.0.0, \nMiddlewarePipe\n \nwill no longer implement\n\nZend\\Stratigility\\MiddlewareInterface\n, and only implement the\nhttp-interop/http-middleware \nMiddlewareInterface\n. This has several\nrepercussions.\n\n\nCallable middleware in version 1.3.0\n\n\nCallable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.\n\n\nFirst, \nwe recommend \nnever\n using the \n$response\n argument provided to\nmiddleware.\n\n\nThe reason for this recommendation is two-fold. First, the http-interop/http-middleware\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.\n\n\nAs an example, consider the following:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return $next($request, $response->withHeader('X-Foo', 'Bar'));\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});\n\n\n\nThe first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware, \ncreates and returns an entirely new response\n,\nmaking the new header disappear.\n\n\nAs such, we recommend rewriting such middleware to modify the \nreturned\n\nresponse instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response->withHeader('X-Foo', 'Bar');\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});\n\n\n\nThe above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.\n\n\nSecond, either wrap your middleware in \nCallableMiddlewareWrapper\n, or ensure\nyour pipeline composes a \nresponse prototype\n (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop/http-middleware delegators.\n\n\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-middleware:\n$pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline->setResponsePrototype($response);\n$pipeline->pipe($middleware);\n\n\n\n\n\nCallableMiddlewareWrapper and Stratigility 2.0\n\n\nAs noted above, version 2 of Stratigility is incompatible with version 1.3 due\nto signature changes in the http-middleware project. However, if you wrap your\ncallable middleware using \nCallableMiddlewareWrapper\n, you will need to make\nno changes in your application to make it forwards compatible.\n\n\nWe recommend using this strategy if you need to do a stepped transition to\nStratigility 2.0.\n\n\n\n\nThird, and optionally, you can make one or both of the following changes to\nyour callable middleware:\n\n\n\n\nTypehint the final \n$next\n argument against \nInterop\\Http\\Middleware\\DelegateInterface\n;\n  optionally, rename it to \n$delegate\n. This will require a slight change to\n  how you invoke the next layer as well; see below.    \n\n\nRemove the \n$response\n argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.\n\n\n\n\nAs an example of the first:\n\n\nfunction ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}\n\n\n\nAs an example of adopting both practices:\n\n\nfunction ($request, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}\n\n\n\nAt this point, you have essentially implemented \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n\n(with the notable exception of not type-hinting the \n$request\n argument).\nWhen you pipe such callable middleware to \nMiddlewarePipeline\n, it will be\nwrapped in a \nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n,\nwhich simply proxies to the middleware when processed.\n\n\n\n\nDelegateInterface and Stratigility 2.0\n\n\nSince the namespace within http-interop/http-middleware changes between\nversion 0.2.0 and 0.4.1, the above strategy will require making changes\nmultiple times: once when upgrading to Stratigility 1.3, and another when\nupgrading to 2.0. As such, we recommend instead decorating your callable\nmiddleware using the \nCallableMiddlewareWrapper\n, until such time as you can\nrewrite your middleware to implement the http-middleware 0.4.1 interfaces.\n\n\n\n\nFinally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop/http-middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.\n\n\nAs an example, consider the following middleware class:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nThis could be rewritten as follows:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nIf we were dealing with callable middleware instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});\n\n\n\nwe could wrap this in an anonymous class instead:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n});\n\n\n\n\n\nUsing anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.\n\n\n\n\nIf you want your middleware to work with either http-interop/http-middleware or\nwith the pre-1.3.0 middleware signature, you can do that as well. To accomplish\nthis, we provide \nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n, which\nwill wrap a \ncallable $next\n such that it may be used as a \nDelegateInterface\n\nimplementation:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\n\n\nImplementing http-interop between Stratigility 1.3 and 2.0\n\n\nWhile you \ncan\n write your middleware to implement the\nhttp-interop/http-middleware middleware interface, please be aware that if you\ndo so, you will need to take additional steps when upgrading from 1.3 to 2.0.\n\n\nIn most cases, you should be able to simply change the import statements\nwithin your class file. As an example, if you have the following in your\nStratigility 1.3-based project:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n\n\nThe imports would become:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n\n\n\n\nTo summarize:\n\n\n\n\n\n\nNever work with the provided \n$response\n argument, but instead manipulate the\n  response returned from calling \n$next\n.\n\n\n\n\n\n\nEnsure your pipeline can decorate callable middleware as http-interop/http-middleware.\n  Do this by injecting a response prototype in the pipeline prior to piping any\n  middleware. (\nNote: this is not necessary if all callable middleware defines\n  exactly two parameters, with the second type-hinting on the http-interop\n  \nDelegateInterface\n.)\n\n\n\n\n\n\nConsider adapting your callable middleware to follow the http-interop middleware\n  signature (\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n);\n  this will make it forward-compatible. (Be aware that this may require changes\n  in import statements between Stratigility 1.3 and 2.0.)\n\n\n\n\n\n\nConsider updating your class-based middleware to implement the\n  http-interop/http-middleware server middleware interface, potentially keeping\n  the \n__invoke()\n method for interoperability with existing callable-based\n  middleware runners. (Be aware that this may require changes in import\n  statements between Stratigility\n  1.3 and 2.0.)\n\n\n\n\n\n\nThe first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-middleware, and to ensure your middleware works\nproperly across middleware stacks.\n\n\nCallable middleware in version 2.0.0\n\n\nCallable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:\n\n\n\n\n\n\nInject a \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory\n\n  instance via the pipeline's \nsetCallableMiddlewareDecorator()\n method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a \nResponseInterface\n in its constructor, and will use that\n  response when creating \nCallableMiddlewareWrapper\n instances.\n\n\n$factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline->setCallableMiddlewareDecorator($factory);\n\n\n\n\n\n\n\nPass a response prototype before piping the callable middleware. If no\n  \nCallableMiddlewareWrapperFactory\n is present, this prototype will be\n  used to seed one for use with decorating callable middleware.\n\n\n$pipeline->setResponsePrototype(new Response());\n\n\n\n\n\n\n\nManually decorate your middleware prior to passing it to the pipeline:\n\n\n$pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-middleware signature already.\n\n\n\n\n\n\n\nInvoking MiddlewarePipe instances in version 2.0.0\n\n\nInvocation of the outermost middleware can now be done in two ways:\n\n\n\n\nUsing \n__invoke()\n. This now requires a third argument, \n$delegate\n, which\n  may be one of a \ncallable\n accepting \nServerRequestInterface\n and \nResponseInterface\n\n  arguments, or a \nDelegateInterface\n instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the \nMiddlewarePipe\n's internal queue is exhausted without returning\n  a response, and \nmust\n return a response itself. A good candidate for this\n  is the \nNoopFinalHandler\n.\n\n\nUsing \nprocess()\n. This argument requires a request and \nDelegateInterface\n\n  instance; again, the \nDelegateInterface\n instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.\n\n\n\n\nAs examples:\n\n\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline->process($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));\n\n\n\nOnce you have done so, you can process the returned request via an\n\nemitter\n.\n\n\nDeprecated functionality\n\n\nThe following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\Dispatch\n (class); this class is marked internal already,\n  but anybody extending \nNext\n and/or this class should be aware of its removal.\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (interface); error middleware\n  should now be implemented per the \nerror handling section above\n.\n\n\nThe \n$response\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n  \nCallableMiddlewareWrapper\n also ensures that a response argument is populated\n  and present when invoking callable middleware.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an \nE_USER_DEPRECATED\n notice, referencing this documentation.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\n\n\nInterface/signature changes\n\n\nThe following signature changes were made with the 2.0.0 release:\n\n\n\n\nZend\\Stratigility\\Next\n:\n\n\nThe \n$done\n constructor argument was renamed to \n$nextDelegate\n, and now\n    allows either \ncallable\n or \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n\n    arguments.\n\n\nThe \n$response\n argument to \n__invoke()\n was removed.\n\n\nThe (optional) \n$err\n argument to \n__invoke()\n was removed.\n\n\n\n\nRemoved functionality\n\n\nThe following classes, methods, and arguments are removed starting in version\n2.0.0.\n\n\n\n\nZend\\Stratigility\\Dispatch\n (class)\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (class)\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\MiddlewareInterface\n. Define your middleware as callables,\n  or using http-interop/http-middleware interfaces instead.\n\n\nZend\\Stratigility\\Utils::getArity()\n (static method); no longer used\n  internally.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method. If\n  passed, it will now be ignored.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\nThe \n$response\n argument to middleware is deprecated; please see the\n  \nsection on callable middleware\n\n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop/http-middleware interface.",
            "title": "To Version 2"
        },
        {
            "location": "/migration/to-v2/#migrating-to-version-2",
            "text": "Version 2 of Stratigility makes several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.  To help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.",
            "title": "Migrating to version 2"
        },
        {
            "location": "/migration/to-v2/#original-request-response-and-uri",
            "text": "In the original 1.X releases, Stratigility would decorate the request and\nresponse instances with  Zend\\Stratigility\\Http\\Request  and Zend\\Stratigility\\Http\\Response , respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated ( Next  truncates matched paths when executing a layer\nif a path was provided when piping the middleware).  Internally, prior to 1.3, only  Zend\\Stratigility\\FinalHandler  was still using\nthis functionality:   It would query the original request to get the original URI when creating a\n  404 response message.  It passes the decorated request and response instances to  onerror  handlers.   Starting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.  If you still need access to the original request, response, or URI instance, we\nrecommend the following:   Pipe  Zend\\Stratigility\\Middleware\\OriginalMessages  as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:  originalRequest , mapping to the request provided to it at invocation.  originalResponse , mapping to the response provided to it at invocation.  originalUri , mapping to the URI composed by the request provided to it at\n  invocation.     You can then access these values within other middleware:  $originalRequest = $request->getAttribute('originalRequest');\n$originalResponse = $request->getAttribute('originalResponse');\n$originalUri = $request->getAttribute('originalUri');  Internally, starting with 1.3.0, we have updated the request decorator to add\nthe  originalRequest  attribute, and the  FinalHandler  to check for this,\ninstead of the decorated instance.  Finally, if you are creating an  onerror  handler for the  FinalHandler , update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.  The  Zend\\Stratigility\\Http  classes, interfaces, and namespace are removed\nin version 2.0.0.",
            "title": "Original request, response, and URI"
        },
        {
            "location": "/migration/to-v2/#error-handling",
            "text": "Prior to version 1.3, the recommended way to handle errors was via error middleware , special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the  Next  implementation when the middleware stack is exhausted,\nbut no response has been returned.  These approaches, however, have several shortcomings:   No other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls  $next()  with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.  The  FinalHandler  implementation hits edge cases when empty responses are\n  intended.  Neither combination works well with error or exception handlers.   Starting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.  The first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the  MiddlewarePipe::raiseThrowables()  method:  $pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();  Once you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:   NotFoundHandler middleware  ErrorHandler middleware  Zend\\Stratigility\\NoopFinalHandler  (see next section)   Updating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.",
            "title": "Error handling"
        },
        {
            "location": "/migration/to-v2/#no-op-final-handler",
            "text": "When using the  NotFoundHandler  and  ErrorHandler  middleware (or custom\nmiddleware you drop in place of them), the  FinalHandler  implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.  However, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form of\n\"final\" handler that can do so. (In fact, starting in version 2, the  $out \nargument is renamed to  $delegate , and is a  required  argument of the MiddlewarePipe .)  Starting in version 1.3, we now offer a  Zend\\Stratigility\\NoopFinalHandler \nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:   By passing it explicitly when invoking the middleware pipeline.  By passing it to  Zend\\Diactoros\\Server::listen() .   If you are not using  Zend\\Diactoros\\Server  to execute your application, but\ninstead invoking your pipeline manually, use the following:  $response = $app($request, $response, new NoopFinalHandler());  If you are using  Zend\\Diactoros\\Server , you will need to pass the final\nhandler you wish to use as an argument to the  listen()  method; that method\nwill then pass that value as the third argument to  MiddlewarePipe  as shown\nabove:  $server->listen(new NoopFinalHandler());  Both approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.  (You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)  To summarize:   Call the  raiseThrowables()  method of your  MiddlewarePipe  instance to\n  opt-in to the new error handling strategy.  Use the new  Zend\\Stratigility\\Middleware\\NotFoundHandler  as the innermost\n  layer of your application pipeline in order to provide 404 responses.  Use the new  Zend\\Stratigility\\Middleware\\ErrorHandler  middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.  Use the  Zend\\Stratigility\\NoopFinalHandler  as the  $out  argument when\n  dispatching your application pipeline.",
            "title": "No-op final handler"
        },
        {
            "location": "/migration/to-v2/#http-interop-compatibility",
            "text": "",
            "title": "http-interop compatibility"
        },
        {
            "location": "/migration/to-v2/#http-middleware-020-and-stratigility-13",
            "text": "Starting in version 1.3.0, we offer compatibility with http-interop/http-middleware 0.2.0 .\nThat version of the specification defines the following interfaces:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}  The support in version 1.3.0 consists of the following:   MiddlewarePipe  now also implements  ServerMiddlewareInterface , and allows\n  piping either type of http-interop middleware.  Next  now also implements  DelegateInterface .  Dispatch  is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.   Additionally,  MiddlewarePipe  will now allow composing a  response prototype ;\nthis is a PSR-7  ResponseInterface  instance. If not set, the first time the\npipeline is invoked via its  __invoke()  method, it will set the prototype from\nthe provided  $response  argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.",
            "title": "http-middleware 0.2.0 and Stratigility 1.3"
        },
        {
            "location": "/migration/to-v2/#http-middleware-041-and-stratigility-20",
            "text": "http-interop/http-middleware 0.4.1 introduces breaking changes in the\ninterfaces, including the following:    The namespace changes from  Interop\\Http\\Middleware  to\n   Interop\\Http\\ServerMiddleware , signaling a change indicating that the project\n  now only targets server-side middleware.    The interface  ServerMiddlewareInterface  is now more simply\n   MiddlewareInterface , as the namespace indicates its usage in server-side\n  applications.  Interop\\Http\\Middleware\\MiddlewareInterface , which targeted\n  client-side middleware, was removed entirely.    The method  DelegateInterface::process  now accepts specifically a\n   Psr\\Http\\Message\\ServerRequestInterface , and not the more general\n   RequestInterface .    The first two changes required only a change in import statements to\naccommodate, and could have been imported in parallel to the 0.2.0 interfaces.\nHowever, the second represents a signature change, which has necessitated a\nmajor version bump in Stratigility in order to remain compatible.  Stratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that\nversion (and compatible versions) only.  Additionally, starting in version 2.0.0,  MiddlewarePipe   will no longer implement Zend\\Stratigility\\MiddlewareInterface , and only implement the\nhttp-interop/http-middleware  MiddlewareInterface . This has several\nrepercussions.",
            "title": "http-middleware 0.4.1 and Stratigility 2.0"
        },
        {
            "location": "/migration/to-v2/#callable-middleware-in-version-130",
            "text": "Callable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.  First,  we recommend  never  using the  $response  argument provided to\nmiddleware.  The reason for this recommendation is two-fold. First, the http-interop/http-middleware\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.  As an example, consider the following:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return $next($request, $response->withHeader('X-Foo', 'Bar'));\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});  The first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware,  creates and returns an entirely new response ,\nmaking the new header disappear.  As such, we recommend rewriting such middleware to modify the  returned \nresponse instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response->withHeader('X-Foo', 'Bar');\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});  The above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.  Second, either wrap your middleware in  CallableMiddlewareWrapper , or ensure\nyour pipeline composes a  response prototype  (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop/http-middleware delegators.  use Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-middleware:\n$pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline->setResponsePrototype($response);\n$pipeline->pipe($middleware);",
            "title": "Callable middleware in version 1.3.0"
        },
        {
            "location": "/migration/to-v2/#callablemiddlewarewrapper-and-stratigility-20",
            "text": "As noted above, version 2 of Stratigility is incompatible with version 1.3 due\nto signature changes in the http-middleware project. However, if you wrap your\ncallable middleware using  CallableMiddlewareWrapper , you will need to make\nno changes in your application to make it forwards compatible.  We recommend using this strategy if you need to do a stepped transition to\nStratigility 2.0.   Third, and optionally, you can make one or both of the following changes to\nyour callable middleware:   Typehint the final  $next  argument against  Interop\\Http\\Middleware\\DelegateInterface ;\n  optionally, rename it to  $delegate . This will require a slight change to\n  how you invoke the next layer as well; see below.      Remove the  $response  argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.   As an example of the first:  function ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}  As an example of adopting both practices:  function ($request, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}  At this point, you have essentially implemented  Interop\\Http\\Middleware\\ServerMiddlewareInterface \n(with the notable exception of not type-hinting the  $request  argument).\nWhen you pipe such callable middleware to  MiddlewarePipeline , it will be\nwrapped in a  Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper ,\nwhich simply proxies to the middleware when processed.",
            "title": "CallableMiddlewareWrapper and Stratigility 2.0"
        },
        {
            "location": "/migration/to-v2/#delegateinterface-and-stratigility-20",
            "text": "Since the namespace within http-interop/http-middleware changes between\nversion 0.2.0 and 0.4.1, the above strategy will require making changes\nmultiple times: once when upgrading to Stratigility 1.3, and another when\nupgrading to 2.0. As such, we recommend instead decorating your callable\nmiddleware using the  CallableMiddlewareWrapper , until such time as you can\nrewrite your middleware to implement the http-middleware 0.4.1 interfaces.   Finally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop/http-middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.  As an example, consider the following middleware class:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  This could be rewritten as follows:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  If we were dealing with callable middleware instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});  we could wrap this in an anonymous class instead:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n});   Using anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.   If you want your middleware to work with either http-interop/http-middleware or\nwith the pre-1.3.0 middleware signature, you can do that as well. To accomplish\nthis, we provide  Zend\\Stratigility\\Delegate\\CallableDelegateDecorator , which\nwill wrap a  callable $next  such that it may be used as a  DelegateInterface \nimplementation:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}",
            "title": "DelegateInterface and Stratigility 2.0"
        },
        {
            "location": "/migration/to-v2/#implementing-http-interop-between-stratigility-13-and-20",
            "text": "While you  can  write your middleware to implement the\nhttp-interop/http-middleware middleware interface, please be aware that if you\ndo so, you will need to take additional steps when upgrading from 1.3 to 2.0.  In most cases, you should be able to simply change the import statements\nwithin your class file. As an example, if you have the following in your\nStratigility 1.3-based project:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;  The imports would become:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;   To summarize:    Never work with the provided  $response  argument, but instead manipulate the\n  response returned from calling  $next .    Ensure your pipeline can decorate callable middleware as http-interop/http-middleware.\n  Do this by injecting a response prototype in the pipeline prior to piping any\n  middleware. ( Note: this is not necessary if all callable middleware defines\n  exactly two parameters, with the second type-hinting on the http-interop\n   DelegateInterface .)    Consider adapting your callable middleware to follow the http-interop middleware\n  signature ( function (ServerRequestInterface $request, DelegateInterface $delegate) );\n  this will make it forward-compatible. (Be aware that this may require changes\n  in import statements between Stratigility 1.3 and 2.0.)    Consider updating your class-based middleware to implement the\n  http-interop/http-middleware server middleware interface, potentially keeping\n  the  __invoke()  method for interoperability with existing callable-based\n  middleware runners. (Be aware that this may require changes in import\n  statements between Stratigility\n  1.3 and 2.0.)    The first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-middleware, and to ensure your middleware works\nproperly across middleware stacks.",
            "title": "Implementing http-interop between Stratigility 1.3 and 2.0"
        },
        {
            "location": "/migration/to-v2/#callable-middleware-in-version-200",
            "text": "Callable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:    Inject a  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory \n  instance via the pipeline's  setCallableMiddlewareDecorator()  method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a  ResponseInterface  in its constructor, and will use that\n  response when creating  CallableMiddlewareWrapper  instances.  $factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline->setCallableMiddlewareDecorator($factory);    Pass a response prototype before piping the callable middleware. If no\n   CallableMiddlewareWrapperFactory  is present, this prototype will be\n  used to seed one for use with decorating callable middleware.  $pipeline->setResponsePrototype(new Response());    Manually decorate your middleware prior to passing it to the pipeline:  $pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-middleware signature already.",
            "title": "Callable middleware in version 2.0.0"
        },
        {
            "location": "/migration/to-v2/#invoking-middlewarepipe-instances-in-version-200",
            "text": "Invocation of the outermost middleware can now be done in two ways:   Using  __invoke() . This now requires a third argument,  $delegate , which\n  may be one of a  callable  accepting  ServerRequestInterface  and  ResponseInterface \n  arguments, or a  DelegateInterface  instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the  MiddlewarePipe 's internal queue is exhausted without returning\n  a response, and  must  return a response itself. A good candidate for this\n  is the  NoopFinalHandler .  Using  process() . This argument requires a request and  DelegateInterface \n  instance; again, the  DelegateInterface  instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.   As examples:  use Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline->process($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));  Once you have done so, you can process the returned request via an emitter .",
            "title": "Invoking MiddlewarePipe instances in version 2.0.0"
        },
        {
            "location": "/migration/to-v2/#deprecated-functionality",
            "text": "The following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.   Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\Dispatch  (class); this class is marked internal already,\n  but anybody extending  Next  and/or this class should be aware of its removal.  Zend\\Stratigility\\ErrorMiddlewareInterface  (interface); error middleware\n  should now be implemented per the  error handling section above .  The  $response  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n   CallableMiddlewareWrapper  also ensures that a response argument is populated\n  and present when invoking callable middleware.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an  E_USER_DEPRECATED  notice, referencing this documentation.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)",
            "title": "Deprecated functionality"
        },
        {
            "location": "/migration/to-v2/#interfacesignature-changes",
            "text": "The following signature changes were made with the 2.0.0 release:   Zend\\Stratigility\\Next :  The  $done  constructor argument was renamed to  $nextDelegate , and now\n    allows either  callable  or  Interop\\Http\\ServerMiddleware\\DelegateInterface \n    arguments.  The  $response  argument to  __invoke()  was removed.  The (optional)  $err  argument to  __invoke()  was removed.",
            "title": "Interface/signature changes"
        },
        {
            "location": "/migration/to-v2/#removed-functionality",
            "text": "The following classes, methods, and arguments are removed starting in version\n2.0.0.   Zend\\Stratigility\\Dispatch  (class)  Zend\\Stratigility\\ErrorMiddlewareInterface  (class)  Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\MiddlewareInterface . Define your middleware as callables,\n  or using http-interop/http-middleware interfaces instead.  Zend\\Stratigility\\Utils::getArity()  (static method); no longer used\n  internally.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method. If\n  passed, it will now be ignored.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)  The  $response  argument to middleware is deprecated; please see the\n   section on callable middleware \n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop/http-middleware interface.",
            "title": "Removed functionality"
        },
        {
            "location": "/migration/preparing-for-v3/",
            "text": "Preparing for version 3\n\n\n\n\nSince 2.2.0\n\n\n\n\nVersion 3 simplifies \nMiddlewarePipe\n and \nNext\n dramatically by restricting\nthem to \nPSR-15\n\ninterface implementations and typehints. However, this also means a number of\nbackwards compatibility breaks are coming.\n\n\nTo help prepare you for the new version, we have provided a number of features\nyou can adopt today in order to make your code forwards-compatible.\nAdditionally, we have marked classes and methods as deprecated where necessary,\nand trigger \nE_USER_DEPRECATED\n errors when using functionality which will no\nlonger be available.\n\n\nBelow, we list the various changes, and propose ways in which you can update\nyour code to be forwards-compatible.\n\n\nMiddlewarePipe and path segregation\n\n\nStarting in version 3, \nMiddlewarePipe\n and \nNext\n have significantly\ndifferent behavior.\n\n\nFirst, the signature of \nMiddlewarePipe::pipe()\n will change to:\n\n\npublic function pipe(\n    MiddlewareInterface $middleware\n) : void\n\n\n\nThis means the following:\n\n\n\n\nYou can no longer use \npipe()\n to perform path segregation.\n\n\nYou can no longer pipe callable middleware of any type.\n\n\n\n\nTo support path segregation, we have introduced\n\nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n. This class accepts two\narguments to its constructor: a string \n$pathPrefix\n (previously, the \n$path\n\nargument to \nMiddlewarePipe::pipe()\n), and a middleware implementation. This\nclass has been backported to version 2.2.0, with usage as follows:\n\n\n// Previously:\n$pipeline->pipe('/api', $apiMiddleware);\n\n// Version 2.2.0+:\nuse Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator;\n$pipeline->pipe(new PathMiddlewareDecorator('/api', $apiMiddleware));\n\n// OR:\nuse Zend\\Stratigility\\path;\n$pipeline->pipe(path('/api', $apiMiddleware));\n\n\n\nPath segregation using this middleware works exactly as it has in previous\nversions. (Internally, if you provide both a \n$path\n and \n$middleware\n argument,\n\nMiddlewarePipe::pipe()\n creates a \nPathMiddlewareDecorator\n instance from the\ntwo arguments).\n\n\nDecorate middleware you need to segregate by path using\n\nPathMiddlewareDecorator\n or the \npath()\n utility function.\n\n\nTo support callable middleware, we have introduced two classes:\n\n\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n can be used to\n  decorate callable middleware following the PSR-15 signature. It replaces the\n  class \nCallableInteropMiddlewareWrapper\n.\n\n\n\n\n\n\nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n can be used to\n  decorate callable middleware following the double-pass signature. It replaces\n  the class \nCallableMiddlewareWrapper\n.\n\n\n\n\n\n\nUse these classes to decorate your callable middleware when piping them:\n\n\n// Previously (interop middleware):\n$pipeline->pipe(function ($request, $delegate) {\n    /* ... */\n});\n\n// Version 2.2.0+:\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\nuse Zend\\Stratigility\\middleware;\n$pipeline->pipe(new CallableMiddlewareDecorator(function ($request, $delegate) {\n    /* ... */\n}));\n// or:\n$pipeline->pipe(middleware(function ($request, $delegate) {\n    /* ... */\n}));\n\n// Previously (double-pass middleware):\n$pipeline->pipe(function ($request, $response, $next) {\n    /* ... */\n});\n\n// Version 2.2.0+:\nuse Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator;\nuse Zend\\Stratigility\\doublePassMiddleware;\n$pipeline->pipe(new DoublePassMiddlewareDecorator(function ($request, $response, $next) {\n    /* ... */\n}));\n// or:\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n    /* ... */\n}));\n\n\n\nIf you pipe callables directly, you will now trigger an \nE_USER_DEPRECATION\n\nerror. Internally, \nMiddlewarePipe::pipe()\n will decorate them using the classes\nnoted above.\n\n\nDecorate callable middleware before piping using either\n\nCallableMiddlewareDecorator\n or \nDoublePassMiddlewareDecorator\n or the relevant\nutility functions as noted in the examples above.\n\n\nExtending MiddlewarePipe\n\n\nStarting in version 3, \nZend\\Stratigility\\MiddlewarePipe\n is marked as \nfinal\n.\nThis means you will no longer be able to directly extend it.\n\n\nWe recommend the following:\n\n\n\n\n\n\nIf you are extending the class for the sole purpose of piping specific\n  middleware, create a PSR-15 \nMiddlewareInterface\n implementation, and compose\n  a \nMiddlewarePipe\n internally; have your \nprocess()\n method proxy to it.\n  (You could also optionally implement \nRequestHandlerInterface\n, which\n  \nMiddlewarePipe\n does in version 3.)\n\n\n\n\n\n\nIf you are extending the class in order to provide additional features or\n  override methods, create your own PSR-15 \nMiddlewareInterface\n implementation\n  to do so, and copy and paste methods from \nMiddlewarePipe\n as needed,\n  providing the changes you need within your version.\n\n\n\n\n\n\nDeprecated classes\n\n\nThe following classes are now marked as deprecated. Where alternatives are\navailable, we note them. If no alternative is available, we note why.\n\n\nZend\\Stratigility\\MiddlewareInterface\n\n\nThis interface has been marked as deprecated since 2.0.0, and unused internally\nsince that release. It is removed with version 3.0.0.\n\n\nZend\\Stratigility\\Route\n\n\nThis is an internal message shared between a \nMiddlewarePipe\n and a \nNext\n\ninstance for purposes of path segregation. In general, it should never be\nconsumed directly; however, it was never marked as internal or final previously.\n\n\nIf you are extending this class or manipulating instances manually, be aware\nthat this class is removed in version 3 as it is no longer used internally.\n\n\nZend\\Stratigility\\Exception\\InvalidMiddlewareException\n\n\nThis was thrown by \nMiddlewarePipe::pipe()\n. In version 3, since the sole\nargument to that method is type-hinted against the PSR-15 \nMiddlewareInterface\n,\nit is no longer used.\n\n\nZend\\Stratigility\\Exception\\InvalidRequestTypeException\n\n\nThis has not been used internally since before version 2.\n\n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n\n\nThis was an internal class used by several classes when they were being used\nwithin double-pass systems in order to cast a \ncallable $next\n argument into a\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance. Since version 3 will\nno longer support operation directly within a double-pass architecture, this\nclass will be removed.\n\n\nMethods that produce an instance include:\n- \nMiddlewarePipe::__invoke()\n\n- \nNotFoundHandler::__invoke()\n\n- \nErrorHandler::__invoke()\n\n\nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n\n\nThis class has been deprecated in favor of a new class,\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n.\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n\n\nThis class has been deprecated in favor of a new class,\n\nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n.\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory\n\n\nThe primary purpose of this class was for composition within a \nMiddlewarePipe\n\nfor purposes of decorating callable double-pass middleware. Since\n\nMiddlewarePipe::pipe()\n will no longer accept callables, it will also no longer\nneed to compose this factory.\n\n\nZend\\Stratigility\\Middleware\\NoopFinalFactory\n\n\nThis class has no internal usage, and is removed in version 3.",
            "title": "Preparing for Version 3"
        },
        {
            "location": "/migration/preparing-for-v3/#preparing-for-version-3",
            "text": "Since 2.2.0   Version 3 simplifies  MiddlewarePipe  and  Next  dramatically by restricting\nthem to  PSR-15 \ninterface implementations and typehints. However, this also means a number of\nbackwards compatibility breaks are coming.  To help prepare you for the new version, we have provided a number of features\nyou can adopt today in order to make your code forwards-compatible.\nAdditionally, we have marked classes and methods as deprecated where necessary,\nand trigger  E_USER_DEPRECATED  errors when using functionality which will no\nlonger be available.  Below, we list the various changes, and propose ways in which you can update\nyour code to be forwards-compatible.",
            "title": "Preparing for version 3"
        },
        {
            "location": "/migration/preparing-for-v3/#middlewarepipe-and-path-segregation",
            "text": "Starting in version 3,  MiddlewarePipe  and  Next  have significantly\ndifferent behavior.  First, the signature of  MiddlewarePipe::pipe()  will change to:  public function pipe(\n    MiddlewareInterface $middleware\n) : void  This means the following:   You can no longer use  pipe()  to perform path segregation.  You can no longer pipe callable middleware of any type.   To support path segregation, we have introduced Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . This class accepts two\narguments to its constructor: a string  $pathPrefix  (previously, the  $path \nargument to  MiddlewarePipe::pipe() ), and a middleware implementation. This\nclass has been backported to version 2.2.0, with usage as follows:  // Previously:\n$pipeline->pipe('/api', $apiMiddleware);\n\n// Version 2.2.0+:\nuse Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator;\n$pipeline->pipe(new PathMiddlewareDecorator('/api', $apiMiddleware));\n\n// OR:\nuse Zend\\Stratigility\\path;\n$pipeline->pipe(path('/api', $apiMiddleware));  Path segregation using this middleware works exactly as it has in previous\nversions. (Internally, if you provide both a  $path  and  $middleware  argument, MiddlewarePipe::pipe()  creates a  PathMiddlewareDecorator  instance from the\ntwo arguments).  Decorate middleware you need to segregate by path using PathMiddlewareDecorator  or the  path()  utility function.  To support callable middleware, we have introduced two classes:    Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  can be used to\n  decorate callable middleware following the PSR-15 signature. It replaces the\n  class  CallableInteropMiddlewareWrapper .    Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  can be used to\n  decorate callable middleware following the double-pass signature. It replaces\n  the class  CallableMiddlewareWrapper .    Use these classes to decorate your callable middleware when piping them:  // Previously (interop middleware):\n$pipeline->pipe(function ($request, $delegate) {\n    /* ... */\n});\n\n// Version 2.2.0+:\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator;\nuse Zend\\Stratigility\\middleware;\n$pipeline->pipe(new CallableMiddlewareDecorator(function ($request, $delegate) {\n    /* ... */\n}));\n// or:\n$pipeline->pipe(middleware(function ($request, $delegate) {\n    /* ... */\n}));\n\n// Previously (double-pass middleware):\n$pipeline->pipe(function ($request, $response, $next) {\n    /* ... */\n});\n\n// Version 2.2.0+:\nuse Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator;\nuse Zend\\Stratigility\\doublePassMiddleware;\n$pipeline->pipe(new DoublePassMiddlewareDecorator(function ($request, $response, $next) {\n    /* ... */\n}));\n// or:\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n    /* ... */\n}));  If you pipe callables directly, you will now trigger an  E_USER_DEPRECATION \nerror. Internally,  MiddlewarePipe::pipe()  will decorate them using the classes\nnoted above.  Decorate callable middleware before piping using either CallableMiddlewareDecorator  or  DoublePassMiddlewareDecorator  or the relevant\nutility functions as noted in the examples above.",
            "title": "MiddlewarePipe and path segregation"
        },
        {
            "location": "/migration/preparing-for-v3/#extending-middlewarepipe",
            "text": "Starting in version 3,  Zend\\Stratigility\\MiddlewarePipe  is marked as  final .\nThis means you will no longer be able to directly extend it.  We recommend the following:    If you are extending the class for the sole purpose of piping specific\n  middleware, create a PSR-15  MiddlewareInterface  implementation, and compose\n  a  MiddlewarePipe  internally; have your  process()  method proxy to it.\n  (You could also optionally implement  RequestHandlerInterface , which\n   MiddlewarePipe  does in version 3.)    If you are extending the class in order to provide additional features or\n  override methods, create your own PSR-15  MiddlewareInterface  implementation\n  to do so, and copy and paste methods from  MiddlewarePipe  as needed,\n  providing the changes you need within your version.",
            "title": "Extending MiddlewarePipe"
        },
        {
            "location": "/migration/preparing-for-v3/#deprecated-classes",
            "text": "The following classes are now marked as deprecated. Where alternatives are\navailable, we note them. If no alternative is available, we note why.",
            "title": "Deprecated classes"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilitymiddlewareinterface",
            "text": "This interface has been marked as deprecated since 2.0.0, and unused internally\nsince that release. It is removed with version 3.0.0.",
            "title": "Zend\\Stratigility\\MiddlewareInterface"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilityroute",
            "text": "This is an internal message shared between a  MiddlewarePipe  and a  Next \ninstance for purposes of path segregation. In general, it should never be\nconsumed directly; however, it was never marked as internal or final previously.  If you are extending this class or manipulating instances manually, be aware\nthat this class is removed in version 3 as it is no longer used internally.",
            "title": "Zend\\Stratigility\\Route"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilityexceptioninvalidmiddlewareexception",
            "text": "This was thrown by  MiddlewarePipe::pipe() . In version 3, since the sole\nargument to that method is type-hinted against the PSR-15  MiddlewareInterface ,\nit is no longer used.",
            "title": "Zend\\Stratigility\\Exception\\InvalidMiddlewareException"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilityexceptioninvalidrequesttypeexception",
            "text": "This has not been used internally since before version 2.",
            "title": "Zend\\Stratigility\\Exception\\InvalidRequestTypeException"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilitydelegatecallabledelegatedecorator",
            "text": "This was an internal class used by several classes when they were being used\nwithin double-pass systems in order to cast a  callable $next  argument into a Interop\\Http\\ServerMiddleware\\DelegateInterface  instance. Since version 3 will\nno longer support operation directly within a double-pass architecture, this\nclass will be removed.  Methods that produce an instance include:\n-  MiddlewarePipe::__invoke() \n-  NotFoundHandler::__invoke() \n-  ErrorHandler::__invoke()",
            "title": "Zend\\Stratigility\\Delegate\\CallableDelegateDecorator"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilitymiddlewarecallableinteropmiddlewarewrapper",
            "text": "This class has been deprecated in favor of a new class, Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator .",
            "title": "Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilitymiddlewarecallablemiddlewarewrapper",
            "text": "This class has been deprecated in favor of a new class, Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator .",
            "title": "Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilitymiddlewarecallablemiddlewarewrapperfactory",
            "text": "The primary purpose of this class was for composition within a  MiddlewarePipe \nfor purposes of decorating callable double-pass middleware. Since MiddlewarePipe::pipe()  will no longer accept callables, it will also no longer\nneed to compose this factory.",
            "title": "Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory"
        },
        {
            "location": "/migration/preparing-for-v3/#zendstratigilitymiddlewarenoopfinalfactory",
            "text": "This class has no internal usage, and is removed in version 3.",
            "title": "Zend\\Stratigility\\Middleware\\NoopFinalFactory"
        }
    ]
}