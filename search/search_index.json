{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/v3/intro/",
            "text": "Stratigility\n\n\n\n\nFrom \"Strata\", Latin for \"layer\", and \"agility\".\n\n\n\n\nStratigility started as a port of \nSencha Connect\n\nto PHP. It allows you to build applications out of \nmiddleware\n.\n\n\nPrevious versions\n\n\n\n\nVersion 1 documentation\n\n\nVersion 2 documentation",
            "title": "Intro"
        },
        {
            "location": "/v3/intro/#stratigility",
            "text": "From \"Strata\", Latin for \"layer\", and \"agility\".   Stratigility started as a port of  Sencha Connect \nto PHP. It allows you to build applications out of  middleware .",
            "title": "Stratigility"
        },
        {
            "location": "/v3/intro/#previous-versions",
            "text": "Version 1 documentation  Version 2 documentation",
            "title": "Previous versions"
        },
        {
            "location": "/v3/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides\n  the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\npsr/http-server-middleware\n,\n  which provides the \nPSR-15\n\n  interfaces.\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nErrorHandler\n middleware and the\n  (legacy) \nFinalHandler\n implementation for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.\n\n\nPrevious versions\n\n\n\n\nVersion 1 documentation\n\n\nVersion 2 documentation",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v3/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides\n  the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n   Diactoros .    psr/http-server-middleware ,\n  which provides the  PSR-15 \n  interfaces.    zendframework/zend-escaper , used by the  ErrorHandler  middleware and the\n  (legacy)  FinalHandler  implementation for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v3/install/#previous-versions",
            "text": "Version 1 documentation  Version 2 documentation",
            "title": "Previous versions"
        },
        {
            "location": "/v3/usage/",
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n\n$server->listen(function ($req, $res) {\n  return $res;\n});\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/v3/usage/#usage",
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n\n$server->listen(function ($req, $res) {\n  return $res;\n});  The above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/v3/middleware/",
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.\n\n\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nuse function Zend\\Stratigility\\middleware;\nuse function Zend\\Stratigility\\path;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe(middleware(function ($req, $handler) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $handler->handle($req);\n    }\n\n    $response = new Response();\n    $response->getBody()->write('Hello world!');\n    return $response;\n}));\n\n// Another page\n$app->pipe(path('/foo', middleware(function ($req, $handler) {\n    $response = new Response();\n    $response->getBody()->write('FOO!');\n    return $response;\n})));\n\n// 404 handler\n$app->pipe(new NotFoundHandler(new Response());\n\n$server->listen(function ($req, $res) {\n  return $res;\n});\n\n\n\nIn the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or\n\n/\n, it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path \n/foo\n\n\u2014 meaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.\n\n\nSo, concisely put, \nmiddleware are PHP callables that accept a request object,\nand do something with it, optionally delegating creation of a response to\nanother handler\n.\n\n\n\n\nPSR-15 middleware\n\n\nStratigility supports only \nPSR-15\n\nmiddleware.\n\n\n\n\nMiddleware can decide more processing can be performed by calling the \n$handler\n\ninstance passed during invocation. With this paradigm, you can build a workflow\nengine for handling requests \u2014 for instance, you could have middleware\nperform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware.\n\n\nUsing the provided \nPathMiddlewareDecorator\n (created by the \npath()\n function\ndemonstrated in the initial example), you can also attach middleware to specific\npaths, allowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:\n\n\n$app->pipe(path('/api', $apiMiddleware));\n$app->pipe(path('/docs', $apiDocMiddleware));\n$app->pipe(path('/files', $filesMiddleware));\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.\n\n\nWithin Stratigility, middleware must be\n\nPSR-15\n middleware.\n\nZend\\Stratigility\\MiddlewarePipe\n implements\n\nPsr\\Http\\Server\\MiddlewareInterface\n.",
            "title": "Middleware"
        },
        {
            "location": "/v3/middleware/#middleware",
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.  use Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nuse function Zend\\Stratigility\\middleware;\nuse function Zend\\Stratigility\\path;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe(middleware(function ($req, $handler) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $handler->handle($req);\n    }\n\n    $response = new Response();\n    $response->getBody()->write('Hello world!');\n    return $response;\n}));\n\n// Another page\n$app->pipe(path('/foo', middleware(function ($req, $handler) {\n    $response = new Response();\n    $response->getBody()->write('FOO!');\n    return $response;\n})));\n\n// 404 handler\n$app->pipe(new NotFoundHandler(new Response());\n\n$server->listen(function ($req, $res) {\n  return $res;\n});  In the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path  /foo \n\u2014 meaning it will match  /foo ,  /foo/ , and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.  So, concisely put,  middleware are PHP callables that accept a request object,\nand do something with it, optionally delegating creation of a response to\nanother handler .",
            "title": "Middleware"
        },
        {
            "location": "/v3/middleware/#psr-15-middleware",
            "text": "Stratigility supports only  PSR-15 \nmiddleware.   Middleware can decide more processing can be performed by calling the  $handler \ninstance passed during invocation. With this paradigm, you can build a workflow\nengine for handling requests \u2014 for instance, you could have middleware\nperform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware.  Using the provided  PathMiddlewareDecorator  (created by the  path()  function\ndemonstrated in the initial example), you can also attach middleware to specific\npaths, allowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:  $app->pipe(path('/api', $apiMiddleware));\n$app->pipe(path('/docs', $apiDocMiddleware));\n$app->pipe(path('/files', $filesMiddleware));  The handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.  Within Stratigility, middleware must be PSR-15  middleware. Zend\\Stratigility\\MiddlewarePipe  implements Psr\\Http\\Server\\MiddlewareInterface .",
            "title": "PSR-15 middleware"
        },
        {
            "location": "/v3/error-handlers/",
            "text": "Error Handlers\n\n\nIn your application, you may need to handle error conditions:\n\n\n\n\nErrors raised by PHP itself (e.g., inability to open a file or database\n  connection).\n\n\nExceptions/throwables raised by PHP and/or code you write or consume.\n\n\nInability of any middleware to handle a request.\n\n\n\n\nYou can typically handle these conditions via middleware itself.\n\n\nHandling 404 conditions\n\n\nIf no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition, \nZend\\Stratigility\\Middleware\\NotFoundHandler\n. The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:\n\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nNote that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.\n\n\nIf you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass NotFoundMiddleware implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\nHandling PHP errors and exceptions\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n is a middleware implementation to\nregister as the \noutermost layer\n of your application (or close to the outermost\nlayer). It does the following:\n\n\n\n\nCreates a PHP error handler that catches any errors in the \nerror_handling()\n\n  mask and throws them as \nErrorException\n instances.\n\n\nWraps the invocation of the delegate in a try/catch block:\n\n\nif no exception is caught, and the result is a response, it returns it.\n\n\nif no exception is caught, it raises an exception, which will be caught.\n\n\nany caught exception is transformed into an error response.\n\n\n\n\nTo generate the error response, we provide the ability to inject a callable with\nthe following signature into the \nErrorHandler\n during instantiation:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe provide a default implementation, \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n,\nwhich generates an error response with a \n5XX\n series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.\n\n\nIn order to work, the \nErrorHandler\n needs a prototype response instance, and,\noptionally, an error response generator (if none is provided,\n\nErrorResponseGenerator\n is used, in production mode):\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n\n\nAs a full example, you can combine the two middleware into the same application\nas separate layers:\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nThe \nErrorResponseGenerator\n provides no templating facilities, and only\nresponds as \ntext/html\n. If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.\n\n\nAs an example:\n\n\nuse ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou would then pass this to the \nErrorHandler\n:\n\n\n$app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));\n\n\n\nErrorHandler Listeners\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n provides the ability to attach\n\nlisteners\n; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.\n\n\nListeners must implement the following signature:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nAttach listeners using \nErrorHandler::attachListener()\n:\n\n\n$errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});",
            "title": "Error Handlers"
        },
        {
            "location": "/v3/error-handlers/#error-handlers",
            "text": "In your application, you may need to handle error conditions:   Errors raised by PHP itself (e.g., inability to open a file or database\n  connection).  Exceptions/throwables raised by PHP and/or code you write or consume.  Inability of any middleware to handle a request.   You can typically handle these conditions via middleware itself.",
            "title": "Error Handlers"
        },
        {
            "location": "/v3/error-handlers/#handling-404-conditions",
            "text": "If no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition,  Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:  // setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  Note that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.  If you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass NotFoundMiddleware implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}",
            "title": "Handling 404 conditions"
        },
        {
            "location": "/v3/error-handlers/#handling-php-errors-and-exceptions",
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  is a middleware implementation to\nregister as the  outermost layer  of your application (or close to the outermost\nlayer). It does the following:   Creates a PHP error handler that catches any errors in the  error_handling() \n  mask and throws them as  ErrorException  instances.  Wraps the invocation of the delegate in a try/catch block:  if no exception is caught, and the result is a response, it returns it.  if no exception is caught, it raises an exception, which will be caught.  any caught exception is transformed into an error response.   To generate the error response, we provide the ability to inject a callable with\nthe following signature into the  ErrorHandler  during instantiation:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We provide a default implementation,  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator ,\nwhich generates an error response with a  5XX  series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.  In order to work, the  ErrorHandler  needs a prototype response instance, and,\noptionally, an error response generator (if none is provided, ErrorResponseGenerator  is used, in production mode):  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);  As a full example, you can combine the two middleware into the same application\nas separate layers:  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  The  ErrorResponseGenerator  provides no templating facilities, and only\nresponds as  text/html . If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.  As an example:  use ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}  You would then pass this to the  ErrorHandler :  $app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));",
            "title": "Handling PHP errors and exceptions"
        },
        {
            "location": "/v3/error-handlers/#errorhandler-listeners",
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  provides the ability to attach listeners ; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.  Listeners must implement the following signature:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  Attach listeners using  ErrorHandler::attachListener() :  $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});",
            "title": "ErrorHandler Listeners"
        },
        {
            "location": "/v3/creating-middleware/",
            "text": "Creating Middleware\n\n\nMiddleware piped to a \nMiddlewarePipe\n \nMUST\n implement the\nPSR-15 middleware interface.\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass MyMiddleware implements MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        RequestHandlerInterface $handler\n    ) : ResponseInterface {\n        // ... do something and return response\n        // or call request handler:\n        // return $handler->handle($request);\n    }\n}\n\n\n\nAnonymous middleware\n\n\nFor one-off middleware, particularly when debugging, you can use an anonymous\nclass to implement \nMiddleareInterface\n:\n\n\n$pipeline->pipe(new class implements MiddlewareInterface {\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $response = $handler->handle($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n});\n\n\n\nCallable middleware\n\n\nSometimes it's easier to eschew the \nMiddlewareInterface\n, particularly when\ncreating a one-off middleware for debugging purposes. In those cases, you can\ncreate a PHP callable that follows the same signature of\n\nMiddlewareInterface::process()\n, and wrap it in a\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n instance:\n\n\n$pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) {\n    // do some work\n    $response = $handler->($req);\n    // do some work\n    return $response;\n});\n\n\n\nThe typehints for the arguments are optional, but such callable middleware will\nreceive \nServerRequestInterface\n and \nRequestHandlerInterface\n instances,\nin that order.\n\n\nYou may also use the \nmiddleware()\n utility function in place of \nnew\nCallableMiddlewareDecorator()\n.\n\n\nDouble-Pass middleware\n\n\nPrior to PSR-15, many PSR-7 frameworks and projects adopted a \"double-pass\"\nmiddleware definition:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) : ResponseInterface\n\n\n\nwhere \n$next\n had the signature:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nThe latter is the origin of the term \"double-pass\", as the implementation passes\nnot a single argument, but two. (The \n$response\n argument was often used as a\nresponse prototype for middleware that needed to return a response.)\n\n\nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n allows decorating\nsuch middleware within a PSR-15 \nMiddlewareInterface\n implementation, allowing\nit to be used in your Stratigility application.\n\n\nWhen using \nDoublePassMiddlewareDecorator\n, internally it will decorate the\n\n$handler\n instance as a callable.\n\n\nTo use the decorator, pass it the double-pass middleware to decorate via the\nconstructor:\n\n\n$pipeline->pipe(new DoublePassMiddlewareDecorator($middleware));\n\n\n\nIf you are not using zend-diactoros for your PSR-7 implementation, the decorator\nalso accepts a second argument, a PSR-7 \nResponseInterface\n prototype instance\nto pass to the double-pass middleware:\n\n\n$pipeline->pipe(new DoublePassMiddlewareDecorator(\n    $middleware,\n    $responsePrototype\n));\n\n\n\nYou may also use the \ndoublePassMiddleware()\n utility function in place of \nnew\nDoublePassMiddlewareDecorator()\n.\n\n\n\n\nBeware of operating on the response\n\n\nIn many cases, poorly written double-pass middleware will manipulate the\nresponse provided to them and pass the manipulated version to \n$next\n.\n\n\nThis is problematic if you mix standard PSR-15 and double-pass middleware, as\nthe response instance is dropped when \n$next\n is called, as the decorator we\nprovide will ignore the argument.\n\n\nIf you notice such issues appearing, please report them to the project\nproviding the double-pass middleware, and ask them to only operate on the\nreturned response.",
            "title": "Creating Middleware"
        },
        {
            "location": "/v3/creating-middleware/#creating-middleware",
            "text": "Middleware piped to a  MiddlewarePipe   MUST  implement the\nPSR-15 middleware interface.  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass MyMiddleware implements MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        RequestHandlerInterface $handler\n    ) : ResponseInterface {\n        // ... do something and return response\n        // or call request handler:\n        // return $handler->handle($request);\n    }\n}",
            "title": "Creating Middleware"
        },
        {
            "location": "/v3/creating-middleware/#anonymous-middleware",
            "text": "For one-off middleware, particularly when debugging, you can use an anonymous\nclass to implement  MiddleareInterface :  $pipeline->pipe(new class implements MiddlewareInterface {\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $response = $handler->handle($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n});",
            "title": "Anonymous middleware"
        },
        {
            "location": "/v3/creating-middleware/#callable-middleware",
            "text": "Sometimes it's easier to eschew the  MiddlewareInterface , particularly when\ncreating a one-off middleware for debugging purposes. In those cases, you can\ncreate a PHP callable that follows the same signature of MiddlewareInterface::process() , and wrap it in a Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  instance:  $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) {\n    // do some work\n    $response = $handler->($req);\n    // do some work\n    return $response;\n});  The typehints for the arguments are optional, but such callable middleware will\nreceive  ServerRequestInterface  and  RequestHandlerInterface  instances,\nin that order.  You may also use the  middleware()  utility function in place of  new\nCallableMiddlewareDecorator() .",
            "title": "Callable middleware"
        },
        {
            "location": "/v3/creating-middleware/#double-pass-middleware",
            "text": "Prior to PSR-15, many PSR-7 frameworks and projects adopted a \"double-pass\"\nmiddleware definition:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) : ResponseInterface  where  $next  had the signature:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  The latter is the origin of the term \"double-pass\", as the implementation passes\nnot a single argument, but two. (The  $response  argument was often used as a\nresponse prototype for middleware that needed to return a response.)  Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  allows decorating\nsuch middleware within a PSR-15  MiddlewareInterface  implementation, allowing\nit to be used in your Stratigility application.  When using  DoublePassMiddlewareDecorator , internally it will decorate the $handler  instance as a callable.  To use the decorator, pass it the double-pass middleware to decorate via the\nconstructor:  $pipeline->pipe(new DoublePassMiddlewareDecorator($middleware));  If you are not using zend-diactoros for your PSR-7 implementation, the decorator\nalso accepts a second argument, a PSR-7  ResponseInterface  prototype instance\nto pass to the double-pass middleware:  $pipeline->pipe(new DoublePassMiddlewareDecorator(\n    $middleware,\n    $responsePrototype\n));  You may also use the  doublePassMiddleware()  utility function in place of  new\nDoublePassMiddlewareDecorator() .",
            "title": "Double-Pass middleware"
        },
        {
            "location": "/v3/creating-middleware/#beware-of-operating-on-the-response",
            "text": "In many cases, poorly written double-pass middleware will manipulate the\nresponse provided to them and pass the manipulated version to  $next .  This is problematic if you mix standard PSR-15 and double-pass middleware, as\nthe response instance is dropped when  $next  is called, as the decorator we\nprovide will ignore the argument.  If you notice such issues appearing, please report them to the project\nproviding the double-pass middleware, and ask them to only operate on the\nreturned response.",
            "title": "Beware of operating on the response"
        },
        {
            "location": "/v3/executing-middleware/",
            "text": "Executing and composing middleware\n\n\nThe easiest way to execute middleware is to write closures and attach them to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest \nMiddlewarePipe\n\ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe(new PathMiddlewareDecorator('/api', $api)); // API middleware attached to the path \"/api\"\n\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you use the \nPathMiddlewareDecorator\n using a path (other than '' or\n'/'), the middleware it decorates is dispatched with a request that strips the\nmatched segment(s) from the start of the path. Using the previous example, if\nthe path \n/api/users/foo\n is matched, the \n$api\n middleware will receive a\nrequest with the path \n/users/foo\n. This allows middleware segregated by path to\nbe re-used without changes to its own internal routing.\n\n\n\n\nHandling errors\n\n\nWhile the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n class:\n\n\nuse Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(new ErrorHandler(new Response());\n// Add more middleware...\n\n\n\nYou can learn how to customize the error handler to your needs in the\n\nchapter on error handlers\n.\n\n\nDecorating the MiddlewarePipe\n\n\nAnother approach is to compose a \nZend\\Stratigility\\MiddlewarePipe\n instance\nwithin your own \nPsr\\Http\\Server\\MiddlewareInterface\n implementation, and\noptionally implementing the \nRequestHandlerInterface\n and/or \npipe()\n method.\n\n\nIn such a case, you might define the \nprocess()\n method to perform any\nadditional logic you have, and then call on the decorated \nMiddlewarePipe\n\ninstance in order to iterate through your stack of middleware:\n\n\nclass CustomMiddleware implements MiddlewareInterface\n{\n    private $pipeline;\n\n    public function __construct(MiddlewarePipe $pipeline)\n    {\n        $this->pipeline = $pipeline;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // perform some work...\n\n        // delegate to parent\n        $this->pipeline->process($request, $handler);\n\n        // maybe do more work?\n    }\n}\n\n\n\nAnother approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided.\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware implements MiddlewareInterface\n{\n    private $pipeline;\n\n    public function __construct(array $configuration, MiddlewarePipe $pipeline)\n    {\n        // do something with configuration ...\n\n        // attach some middleware ...\n        $pipeline->pipe(/* some middleware */);\n\n        $this->pipeline = $pipeline;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        /* ... */\n    }\n}\n\n\n\nThese approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Composing middleware"
        },
        {
            "location": "/v3/executing-middleware/#executing-and-composing-middleware",
            "text": "The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe  instance. You can nest  MiddlewarePipe \ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.  $api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe(new PathMiddlewareDecorator('/api', $api)); // API middleware attached to the path \"/api\"",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/v3/executing-middleware/#request-path-changes-when-path-matched",
            "text": "When you use the  PathMiddlewareDecorator  using a path (other than '' or\n'/'), the middleware it decorates is dispatched with a request that strips the\nmatched segment(s) from the start of the path. Using the previous example, if\nthe path  /api/users/foo  is matched, the  $api  middleware will receive a\nrequest with the path  /users/foo . This allows middleware segregated by path to\nbe re-used without changes to its own internal routing.",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/v3/executing-middleware/#handling-errors",
            "text": "While the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler  class:  use Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(new ErrorHandler(new Response());\n// Add more middleware...  You can learn how to customize the error handler to your needs in the chapter on error handlers .",
            "title": "Handling errors"
        },
        {
            "location": "/v3/executing-middleware/#decorating-the-middlewarepipe",
            "text": "Another approach is to compose a  Zend\\Stratigility\\MiddlewarePipe  instance\nwithin your own  Psr\\Http\\Server\\MiddlewareInterface  implementation, and\noptionally implementing the  RequestHandlerInterface  and/or  pipe()  method.  In such a case, you might define the  process()  method to perform any\nadditional logic you have, and then call on the decorated  MiddlewarePipe \ninstance in order to iterate through your stack of middleware:  class CustomMiddleware implements MiddlewareInterface\n{\n    private $pipeline;\n\n    public function __construct(MiddlewarePipe $pipeline)\n    {\n        $this->pipeline = $pipeline;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // perform some work...\n\n        // delegate to parent\n        $this->pipeline->process($request, $handler);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided.  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware implements MiddlewareInterface\n{\n    private $pipeline;\n\n    public function __construct(array $configuration, MiddlewarePipe $pipeline)\n    {\n        // do something with configuration ...\n\n        // attach some middleware ...\n        $pipeline->pipe(/* some middleware */);\n\n        $this->pipeline = $pipeline;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        /* ... */\n    }\n}  These approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Decorating the MiddlewarePipe"
        },
        {
            "location": "/v3/api/",
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\n\n\nhttp-server-middleware\n\n\n\n\nAffects: version 3.0.0alpha1\n\n\n\n\nStarting with version 3.0.0, support for http-interop/http-middleware has been\nreplaced with support for psr/http-server-middleware.\n\n\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and\nhas been discussed previously. Its API is:\n\n\nnamespace Zend\\Stratigility;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass MiddlewarePipe implements MiddlewareInterface, RequestHandlerInterface\n{\n    public function pipe(MiddlewareInterface $middleware);\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\nMiddleware is executed in the order in which it is piped to the\n\nMiddlewarePipe\n instance.\n\n\nThe \nMiddlewarePipe\n is itself middleware, and can be executed in stacks that\nexpect PSR-15 middleware signatures. It is also a request handler,\nallowing you to use it in paradigms where a request handler is required; when\nexecuted in this way, it will process itself in order to generate a response.\n\n\nMiddleware should either return a response, or the result of\n\nRequestHandlerInterface::handle()\n (which should eventually evaluate to a\nresponse instance).\n\n\nInternally, \nMiddlewarePipe\n creates an instance of \nZend\\Stratigility\\Next\n to\nuse as a \nRequestHandlerInterface\n implementation to pass to each middleware;\n\nNext\n receives the queue of middleware from the \nMiddlewarePipe\n instance and\nprocesses each one, calling them with the current request and itself, advancing\nits internal pointer until all middleware are executed, or a response is\nreturned.\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail, and exists to\nallow delegating to middleware aggregated in the \nMiddlewarePipe\n. It is\nimplemented as an PSR-15 \nRequestHandlerInterface\n.\n\n\nSince your middleware needs to return a response, the instance receives the\n\n$handler\n argument passed to \nMiddlewarePipe::process()\n as a fallback request\nhandler; if the last middleware in the queue calls on its handler, \nNext\n will\nexecute the fallback request handler to generate a response to return.\n\n\nProviding an altered request:\n\n\nfunction ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n\n\nProviding an altered request and operating on the returned response:\n\n\nfunction ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the handler:\n    $response = return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n\n    // Return a response with an additional header:\n    return $response->withHeader('X-Completed', 'true');\n}\n\n\n\nReturning a response to complete the request\n\n\nIf your middleware does not need to delegate to another layer, it's time to\nreturn a response.\n\n\nWe recommend creating a new response, or providing your middleware with a\nresponse prototype; this will ensure that the response is specific for your\ncontext.\n\n\n$prototype = new Response();\n\nfunction ($request, RequestHandlerInterface $handler) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}\n\n\n\nDelegation\n\n\nIf your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\nhandler.\n\n\nreturn $handler->handle($request);\n\n\n\nMiddleware should always return a response, and, if it cannot, return the\nresult of delegating to the request handler.\n\n\nRaising an error condition\n\n\nIf your middleware cannot complete \u2014 perhaps a database error occurred, a\nservice was unreachable, etc. \u2014 how can you report the error?\n\n\nRaise an exception!\n\n\nfunction ($request, RequestHandlerInterface $handler) use ($service)\n{\n    $result = $service->fetchSomething();\n    if (! $result->isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}\n\n\n\nUse the \nErrorHandler middleware\n\nto handle exceptions thrown by your middleware and report the error condition to\nyour users.\n\n\nMiddleware\n\n\nStratigility provides several concrete middleware implementations.\n\n\nPathMiddlewareDecorator\n\n\nIf you wish to segregate middleware by path prefix and/or conditionally\nexecute middleware based on a path prefix, decorate your middleware using\n\nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n.\n\n\nMiddleware decorated by \nPathMiddlewareDecorator\n will only execute if the\nrequest URI matches the path prefix provided during instantiation.\n\n\n// Only process $middleware if the URI path prefix matches '/foo':\n$pipeline->pipe(new PathMiddlewareDecorator('/foo', $middleware));\n\n\n\nWhen the path prefix matches, the \nPathMiddlewareDecorator\n will strip the path\nprefix from the request passed to the decorated middleware. For example, if you\nexecuted \n$pipeline->pipe('/api', $api)\n, and this was matched via a URI with\nthe path \n/api/users/foo\n, the \n$api\n middleware will receive a request with the\npath \n/users/foo\n. This allows middleware segregated by path to be re-used\nwithout changes to its own internal routing.\n\n\nCallableMiddlewareDecorator\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n provides the ability\nto decorate PHP callables that have the same signature as or a compatible\nsignature to PSR-15's \nMiddlewareInterface\n. This allows for one-off middleware\ncreation when creating your pipeline:\n\n\n$pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) {\n    // do some work\n    $response = $handler->handle($req);\n    // do some work\n    return $response;\n});\n\n\n\nDoublePassMiddlewareDecorator\n\n\nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n provides the\nability to decorate \"double-pass\", callable middleware (so-called because you\npass the request \nand\n response to the delegate) within a class implementing the\nPSR-15 \nMiddlewareInterface\n. This allows you to adapt existing middleware with\nthe double-pass interface to work with Stratigility.\n\n\n$pipeline->pipe(new DoublePassMiddlewareDecorator(function ($req, $res, $next) {\n    // do some work\n    $response = $next($req, $res);\n    // do some work\n    return $response;\n});\n\n\n\n$next\n is a callable that decorates Stratigility's \nNext\n instance; it\nignores the response argument.\n\n\nThe constructor takes an optional second argument, a response prototype. This\nwill be used to pass to the middleware when it is executed. If no instance is\nprovided, a zend-diactoros response instance is auto-wired. If you want to use\nan alternate PSR-7 \nResponseInterface\n implementation, pass it when creating the\ndecorator instance:\n\n\n$pipeline->pipe(new DoublePassMiddlewareDecorator(\n    $doublePassMiddleware,\n    $response\n));\n\n\n\nRequestHandlerMiddleware\n\n\nZend\\Stratigility\\Middleware\\RequestHandlerMiddleware\n allows you to decorate a\nPSR-15 \nRequestHandlerInterface\n for use as either a request handler or\nmiddleware. When either its \nhandle()\n or \nprocess()\n method are called, it will\nproxy to the composed request handler's \nhandle()\n method and return the\nresponse it produces.\n\n\nThis can be useful for piping a final handler to a pipeline.\n\n\n// Where $handler is a RequestHandlerInterface:\n$pipeline->pipe(new RequestHandlerMiddleware($handler));\n\n\n\nErrorHandler and NotFoundHandler\n\n\nThese two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the\n\nerror handling chapter\n.\n\n\nOriginalMessages\n\n\nThis callable middleware can be used as the outermost layer of middleware in\norder to set the original request and URI instances as request attributes for\ninner layers.\n\n\nUtility Functions\n\n\nStratigility provides the following utility functions.\n\n\nhost\n\n\nfunction Zend\\Stratigility\\host(\n  string $host,\n  Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator\n\n\n\nhost()\n provides a convenient way to perform host name segregation when piping your\nmiddleware.\n\n\n$pipeline->pipe(host('example.com', $middleware));\n\n\n\npath\n\n\nfunction Zend\\Stratigility\\path(\n    string $pathPrefix,\n    Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n\n\n\npath()\n provides a convenient way to perform path segregation when piping your\nmiddleware.\n\n\n$pipeline->pipe(path('/foo', $middleware));\n\n\n\nmiddleware\n\n\nfunction Zend\\Stratigility\\middleware(\n    callable $middleware\n) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n\n\n\nmiddleware()\n provides a convenient way to decorate callable middleware that\nimplements the PSR-15 middleware signature when piping it to your application.\n\n\n$pipeline->pipe(middleware(function ($request, $handler) {\n  // ...\n});\n\n\n\ndoublePassMiddleware\n\n\nfunction Zend\\Stratigility\\doublePassMiddleware(\n    callable $middleware,\n    Psr\\Http\\Message\\ResponseInterface $responsePrototype = null\n) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n\n\n\ndoublePassMiddleware()\n provides a convenient way to decorate middleware that\nimplements the double pass middleware signature when piping it to your application.\n\n\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n});\n\n\n\nIf you are not using zend-diactoros as a PSR-7 implementation, you will need to\npass a response prototype as well:\n\n\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n}, $response);",
            "title": "API Reference"
        },
        {
            "location": "/v3/api/#api-reference",
            "text": "The following make up the primary API of Stratigility.",
            "title": "API Reference"
        },
        {
            "location": "/v3/api/#http-server-middleware",
            "text": "Affects: version 3.0.0alpha1   Starting with version 3.0.0, support for http-interop/http-middleware has been\nreplaced with support for psr/http-server-middleware.",
            "title": "http-server-middleware"
        },
        {
            "location": "/v3/api/#middleware",
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and\nhas been discussed previously. Its API is:  namespace Zend\\Stratigility;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass MiddlewarePipe implements MiddlewareInterface, RequestHandlerInterface\n{\n    public function pipe(MiddlewareInterface $middleware);\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  Middleware is executed in the order in which it is piped to the MiddlewarePipe  instance.  The  MiddlewarePipe  is itself middleware, and can be executed in stacks that\nexpect PSR-15 middleware signatures. It is also a request handler,\nallowing you to use it in paradigms where a request handler is required; when\nexecuted in this way, it will process itself in order to generate a response.  Middleware should either return a response, or the result of RequestHandlerInterface::handle()  (which should eventually evaluate to a\nresponse instance).  Internally,  MiddlewarePipe  creates an instance of  Zend\\Stratigility\\Next  to\nuse as a  RequestHandlerInterface  implementation to pass to each middleware; Next  receives the queue of middleware from the  MiddlewarePipe  instance and\nprocesses each one, calling them with the current request and itself, advancing\nits internal pointer until all middleware are executed, or a response is\nreturned.",
            "title": "Middleware"
        },
        {
            "location": "/v3/api/#next",
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail, and exists to\nallow delegating to middleware aggregated in the  MiddlewarePipe . It is\nimplemented as an PSR-15  RequestHandlerInterface .  Since your middleware needs to return a response, the instance receives the $handler  argument passed to  MiddlewarePipe::process()  as a fallback request\nhandler; if the last middleware in the queue calls on its handler,  Next  will\nexecute the fallback request handler to generate a response to return.",
            "title": "Next"
        },
        {
            "location": "/v3/api/#providing-an-altered-request",
            "text": "function ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n}",
            "title": "Providing an altered request:"
        },
        {
            "location": "/v3/api/#providing-an-altered-request-and-operating-on-the-returned-response",
            "text": "function ($request, RequestHandlerInterface $handler) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the handler:\n    $response = return $handler->handle(\n        $request->withBodyParams($bodyParams)\n    );\n\n    // Return a response with an additional header:\n    return $response->withHeader('X-Completed', 'true');\n}",
            "title": "Providing an altered request and operating on the returned response:"
        },
        {
            "location": "/v3/api/#returning-a-response-to-complete-the-request",
            "text": "If your middleware does not need to delegate to another layer, it's time to\nreturn a response.  We recommend creating a new response, or providing your middleware with a\nresponse prototype; this will ensure that the response is specific for your\ncontext.  $prototype = new Response();\n\nfunction ($request, RequestHandlerInterface $handler) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}",
            "title": "Returning a response to complete the request"
        },
        {
            "location": "/v3/api/#delegation",
            "text": "If your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\nhandler.  return $handler->handle($request);  Middleware should always return a response, and, if it cannot, return the\nresult of delegating to the request handler.",
            "title": "Delegation"
        },
        {
            "location": "/v3/api/#raising-an-error-condition",
            "text": "If your middleware cannot complete \u2014 perhaps a database error occurred, a\nservice was unreachable, etc. \u2014 how can you report the error?  Raise an exception!  function ($request, RequestHandlerInterface $handler) use ($service)\n{\n    $result = $service->fetchSomething();\n    if (! $result->isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}  Use the  ErrorHandler middleware \nto handle exceptions thrown by your middleware and report the error condition to\nyour users.",
            "title": "Raising an error condition"
        },
        {
            "location": "/v3/api/#middleware_1",
            "text": "Stratigility provides several concrete middleware implementations.",
            "title": "Middleware"
        },
        {
            "location": "/v3/api/#pathmiddlewaredecorator",
            "text": "If you wish to segregate middleware by path prefix and/or conditionally\nexecute middleware based on a path prefix, decorate your middleware using Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator .  Middleware decorated by  PathMiddlewareDecorator  will only execute if the\nrequest URI matches the path prefix provided during instantiation.  // Only process $middleware if the URI path prefix matches '/foo':\n$pipeline->pipe(new PathMiddlewareDecorator('/foo', $middleware));  When the path prefix matches, the  PathMiddlewareDecorator  will strip the path\nprefix from the request passed to the decorated middleware. For example, if you\nexecuted  $pipeline->pipe('/api', $api) , and this was matched via a URI with\nthe path  /api/users/foo , the  $api  middleware will receive a request with the\npath  /users/foo . This allows middleware segregated by path to be re-used\nwithout changes to its own internal routing.",
            "title": "PathMiddlewareDecorator"
        },
        {
            "location": "/v3/api/#callablemiddlewaredecorator",
            "text": "Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  provides the ability\nto decorate PHP callables that have the same signature as or a compatible\nsignature to PSR-15's  MiddlewareInterface . This allows for one-off middleware\ncreation when creating your pipeline:  $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) {\n    // do some work\n    $response = $handler->handle($req);\n    // do some work\n    return $response;\n});",
            "title": "CallableMiddlewareDecorator"
        },
        {
            "location": "/v3/api/#doublepassmiddlewaredecorator",
            "text": "Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  provides the\nability to decorate \"double-pass\", callable middleware (so-called because you\npass the request  and  response to the delegate) within a class implementing the\nPSR-15  MiddlewareInterface . This allows you to adapt existing middleware with\nthe double-pass interface to work with Stratigility.  $pipeline->pipe(new DoublePassMiddlewareDecorator(function ($req, $res, $next) {\n    // do some work\n    $response = $next($req, $res);\n    // do some work\n    return $response;\n});  $next  is a callable that decorates Stratigility's  Next  instance; it\nignores the response argument.  The constructor takes an optional second argument, a response prototype. This\nwill be used to pass to the middleware when it is executed. If no instance is\nprovided, a zend-diactoros response instance is auto-wired. If you want to use\nan alternate PSR-7  ResponseInterface  implementation, pass it when creating the\ndecorator instance:  $pipeline->pipe(new DoublePassMiddlewareDecorator(\n    $doublePassMiddleware,\n    $response\n));",
            "title": "DoublePassMiddlewareDecorator"
        },
        {
            "location": "/v3/api/#requesthandlermiddleware",
            "text": "Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware  allows you to decorate a\nPSR-15  RequestHandlerInterface  for use as either a request handler or\nmiddleware. When either its  handle()  or  process()  method are called, it will\nproxy to the composed request handler's  handle()  method and return the\nresponse it produces.  This can be useful for piping a final handler to a pipeline.  // Where $handler is a RequestHandlerInterface:\n$pipeline->pipe(new RequestHandlerMiddleware($handler));",
            "title": "RequestHandlerMiddleware"
        },
        {
            "location": "/v3/api/#errorhandler-and-notfoundhandler",
            "text": "These two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the error handling chapter .",
            "title": "ErrorHandler and NotFoundHandler"
        },
        {
            "location": "/v3/api/#originalmessages",
            "text": "This callable middleware can be used as the outermost layer of middleware in\norder to set the original request and URI instances as request attributes for\ninner layers.",
            "title": "OriginalMessages"
        },
        {
            "location": "/v3/api/#utility-functions",
            "text": "Stratigility provides the following utility functions.",
            "title": "Utility Functions"
        },
        {
            "location": "/v3/api/#host",
            "text": "function Zend\\Stratigility\\host(\n  string $host,\n  Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator  host()  provides a convenient way to perform host name segregation when piping your\nmiddleware.  $pipeline->pipe(host('example.com', $middleware));",
            "title": "host"
        },
        {
            "location": "/v3/api/#path",
            "text": "function Zend\\Stratigility\\path(\n    string $pathPrefix,\n    Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  path()  provides a convenient way to perform path segregation when piping your\nmiddleware.  $pipeline->pipe(path('/foo', $middleware));",
            "title": "path"
        },
        {
            "location": "/v3/api/#middleware_2",
            "text": "function Zend\\Stratigility\\middleware(\n    callable $middleware\n) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  middleware()  provides a convenient way to decorate callable middleware that\nimplements the PSR-15 middleware signature when piping it to your application.  $pipeline->pipe(middleware(function ($request, $handler) {\n  // ...\n});",
            "title": "middleware"
        },
        {
            "location": "/v3/api/#doublepassmiddleware",
            "text": "function Zend\\Stratigility\\doublePassMiddleware(\n    callable $middleware,\n    Psr\\Http\\Message\\ResponseInterface $responsePrototype = null\n) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  doublePassMiddleware()  provides a convenient way to decorate middleware that\nimplements the double pass middleware signature when piping it to your application.  $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n});  If you are not using zend-diactoros as a PSR-7 implementation, you will need to\npass a response prototype as well:  $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n}, $response);",
            "title": "doublePassMiddleware"
        },
        {
            "location": "/v3/migration/",
            "text": "Migrating from version 2 to version 3\n\n\nIn this document, we outline the backwards breaking changes with version 3.0,\nand provide guidance on how to upgrade your application to be compatible.\n\n\n\n\nPHP support\n\n\nPSR-15\n\n\nPipeline (\nMiddlewarePipe\n)\n\n\nChanges in public interfaces\n\n\nSignature changes\n\n\nClass additions\n\n\nRemoved classes and exceptions\n\n\nRemoved methods\n\n\nFunction additions\n\n\n\n\nPHP support\n\n\nWe now support only PHP versions 7.1 and above.  PHP 5.6 and 7.0 support has\nbeen dropped.\n\n\nPSR-15\n\n\nStratigility now supports only \nPSR-15\n\ninterfaces. Support of \nhttp-interop/http-middleware\n has been dropped.\n\n\nAll middleware and request handlers must now implement \nPSR-15\n\ninterfaces, including those Stratigility implements.\n\n\nAs a result, a number of signatures have been changed.  Primarily, these were a\nmatter of updating typehints on\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n (defined in\n\nhttp-interop/http-middleware\n\n0.4 and up, an early draft of PSR-15) and\n\nInterop\\Http\\Server\\RequestHandlerInterface\n (defined in\n\nhttp-interop/http-server-handler\n,\nthe immediate predecessor to the final spec) to\n\nPsr\\Http\\Server\\RequestHandlerInterface\n, and adding the return type hint\n\nPsr\\Http\\Message\\ResponseInterface\n.\n\n\nSignatures affected include:\n\n\n\n\nZend\\Stratigility\\MiddlewarePipe::process()\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler::process()\n\n\nZend\\Stratigility\\Middleware\\NotFoundHandler::process()\n\n\nZend\\Stratigility\\Middleware\\OriginalMessages::process()\n\n\nZend\\Stratigility\\MiddlewarePipe::process()\n\n\n\n\nAll of these classes now implement the PSR-15 \nMiddlewareInterface\n.\n\n\nPipeline - \nMiddlewarePipe\n\n\nWe now only allow piping \nPsr\\Http\\Server\\MiddlewareInterface\n instances\ninto the \nMiddlewarePipe\n class.\n\n\nIn version 2, we had a number of internal utilities for identifying other types\nof middleware (callable, double-pass, etc.), and would decorate those within the\n\npipe()\n method. This is no longer allowed.\n\n\nIf you wish to use those types, you will need to decorate them using the\nappropriate decorators as outlined in the \nClass additions\n\nsection.\n\n\nAdditionally, \nMiddlewarePipe\n is now marked \nfinal\n, and may not be directly\nextended. Decorate an instance if you wish to provide alternate behavior, or\ncreate your own \nMiddlewareInterface\n implementation to provide alternate\ninternal logic.\n\n\nChanges in public interfaces\n\n\nSignature changes\n\n\n\n\n\n\nNext::__construct()\n: the second parameter now typehints against the\n  PSR-15 \nRequestHandlerInterface\n.\n\n\n\n\n\n\nNext::handle()\n: the method now provides a return typehint of\n  \nPsr\\Http\\Message\\ResponseInterface\n.\n\n\n\n\n\n\nMiddlewarePipe\n class is marked now as \nfinal\n and implements the new\n  interface \nMiddlewarePipeInterface.\n\n\n\n\n\n\nMiddlewarePipe::pipe()\n: reduces the number of arguments to one, which now\n  typehints against \nPsr\\Http\\Server\\MiddlewareInterface\n. This means the method\n  can no longer be used to segregate middleware by path. If you want to do that,\n  please use \nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n to decorate\n  your middleware and to provide the path prefix it will run under. See the next\n  section for details.\n\n\n\n\n\n\nMiddlewarePipe::process()\n: the second parameter now typehints against\n  \nPsr\\Http\\Server\\RequestHandlerInterface\n, and provides a return typehint of\n  \nPsr\\Http\\Message\\ResponseInterface\n.\n\n\n\n\n\n\nErrorHandler::__construct()\n and \nNotFoundHandler::__construct()\n: the first\n  parameter of each constructor now expects a PHP \ncallable\n capable of\n  returning a PSR-7 \nResponseInterface\n instance (instead of typehinting\n  directly against \nResponseInterface\n). This paves the way for usage with the\n  upcoming PSR-17 (HTTP Message Factories) specification, and simplifies re-use\n  of a dependency injection container service (as otherwise you would need to\n  specify a discrete service per class that expects a response prototype, due to\n  mutability of the response body).\n\n\n\n\n\n\nClass additions\n\n\n\n\n\n\nZend\\Stratigility\\MiddlewarePipeInterface\n extends\n  \nPsr\\Http\\Server\\MiddlewareInterface\n and \nPsr\\Http\\Server\\RequestHandlerInterface\n,\n  and defines the method \npipe(Psr\\Http\\Server\\MiddlewareInterface $middleware) : void\n.\n  It is implemented by \nMiddlewarePipe\n.\n\n\n\n\n\n\nZend\\Stratigility\\Middleware\\HostMiddlewareDecorator\n allows you to segregate\n  middleware by a static host name. This allows executing middleware only\n  if a particular host matches.\n\n\n\n\n\n\n// Segregate to hosts matching 'example.com':\n$pipeline->pipe(new HostMiddlewareDecorator('example.com', $middleware));\n\n\n\nAlternately, use the \nhost()\n utility function to generate the instance; \nsee\n  below\n.\n\n\n\n\nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n allows you to segregate\n  middleware by a static URI path prefix. This allows executing middleware only\n  if a particular path matches, or segregating a sub-application by path.\n\n\n\n\n// Segregate to paths matching '/foo' as the prefix:\n$pipeline->pipe(new PathMiddlewareDecorator('/foo', $middleware));\n\n\n\nAlternately, use the \npath()\n utility function to generate the instance; \nsee\n  below\n.\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n provides the\n  functionality that was formerly provided by\n  \nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n: it provides\n  the ability to decorate PHP callables that have the same or compatible\n  signatures to the PSR-15 \nMiddlewareInterface\n. This allows for one-off piping\n  of middleware:\n\n\n\n\n$pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) {\n    // do some work\n    $response = $next($req, $handler);\n    // do some work\n    return $response;\n});\n\n\n\nThe arguments and return value can be type-hinted, but do not need to be. The\n  decorator provides some checking on the return value in order to raise an\n  exception if a response is not returned.\n\n\nAlternately, use the \nmiddleware()\n utility function to generate the instance;\n  \nsee below\n.\n\n\n\n\nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n provides the\n  functionality that was formerly provided by \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n.\n  The class now makes the response prototype argument to the constructor\n  optional, and falls back to a zend-diactoros response instance if that library\n  is installed. Internally, it decorates the \n$handler\n as a callable.\n\n\n\n\n$pipeline->pipe(new DoublePassMiddlewareDecorator(function ($req, $res, $next) {\n    // do some work\n    $response = $next($req, $res);\n    // do some work\n    return $response;\n});\n\n\n\nPer recommendations in previous versions, if you are using double-pass\n  middleware, do not operate on the response passed to the middleware; instead,\n  only operate on the response returned by \n$next\n, or produce a concrete\n  response yourself.\n\n\nAlternately, use the \ndoublePassMiddleware()\n utility function to create the\n  instance; \nsee below\n.\n\n\n\n\nZend\\Stratigility\\Exception\\ExceptionInterface\n - marker for\n  package-specific exceptions.\n\n\n\n\nRemoved classes and exceptions\n\n\nThe following classes have been removed:\n\n\n\n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n\n\nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory\n\n\nZend\\Stratigility\\MiddlewareInterface\n (Please use the PSR-15\n  \nMiddlewareInterface\n instead.)\n\n\nZend\\Stratigility\\NoopFinalHandler\n\n\nZend\\Stratigility\\Route\n. This was an internal class used by \nMiddlewarePipe\n\n  and \nNext\n, and its removal should not affect consumers.\n\n\n\n\nThe following exceptions have been removed:\n\n\n\n\nZend\\Stratigility\\Exception\\InvalidMiddlewareException\n (this is no longer\n  thrown by \nMiddlewarePipe\n, and thus no longer necessary).\n\n\nZend\\Stratigility\\Exception\\InvalidRequestTypeException\n\n\n\n\nRemoved methods\n\n\n\n\n\n\nMiddlewarePipe::__invoke()\n: the class is no longer invokable.\n  Use the method \nprocess\n instead.\n\n\n\n\n\n\nMiddlewarePipe::setCallableMiddlewareDecorator()\n: since we now accept only\n  PSR-15 middleware implementations within \nMiddlewarePipe\n, this method is no\n  longer needed. Other middleware types should be decorated in a\n  \nMiddlewareInterface\n implementation prior to piping.\n\n\n\n\n\n\nMiddlewarePipe::setResponsePrototype()\n: this method is no longer needed,\n  due to removing support for non-\nMiddlewareInterface\n types.\n\n\n\n\n\n\nMiddlewarePipe::hasResponsePrototype()\n: this method is no longer needed,\n  due to removing support for non-\nMiddlewareInterface\n types.\n\n\n\n\n\n\nMiddlewarePipe::raiseThrowables()\n: this method has been deprecated since\n  2.0.0, and slated for removal with this version.\n\n\n\n\n\n\nMiddleware\\ErrorHandler::__invoke()\n: this class is no longer invokable.\n  Use the \nprocess\n method instead.\n\n\n\n\n\n\nMiddleware\\NotFoundHandler::__invoke()\n: this class is no longer invokable.\n  Use the \nprocess\n method instead.\n\n\n\n\n\n\nNext::__invoke()\n: this class is no longer invokable. Use the method \nhandle\n\n  instead.\n\n\n\n\n\n\nNext::next()\n: this method was a proxy to the \nhandle()\n method, and no\n  longer of use, particularly as the class is an internal detail.\n\n\n\n\n\n\nNext::process()\n: this method was a proxy to the \nhandle()\n method, and no\n  longer of use, particularly as the class is an internal detail.\n\n\n\n\n\n\nNext::raiseThrowables()\n: this method has been deprecated since 2.0.0, and\n  slated for removal with this version.\n\n\n\n\n\n\nFunction additions\n\n\nRelease 3.0 adds the following utility functions:\n\n\nhost\n\n\nfunction Zend\\Stratigility\\host(\n  string $host,\n  Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator\n\n\n\nThis is a convenience wrapper around instantiation of a\n\nZend\\Stratigility\\Middleware\\HostMiddlewareDecorator\n instance:\n\n\n$pipeline->pipe(host('example.com', $middleware));\n\n\n\npath\n\n\nfunction Zend\\Stratigility\\path(\n  string $pathPrefix,\n  Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n\n\n\nThis is a convenience wrapper around instantiation of a\n\nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n instance:\n\n\n$pipeline->pipe(path('/foo', $middleware));\n\n\n\nmiddleware\n\n\nfunction Zend\\Stratigility\\middleware(\n    callable $middleware\n) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n\n\n\nmiddleware()\n provides a convenient way to decorate callable middleware that\nimplements the PSR-15 middleware signature when piping it to your application.\n\n\n$pipeline->pipe(middleware(function ($request, $handler) {\n  // ...\n});\n\n\n\ndoublePassMiddleware\n\n\nfunction Zend\\Stratigility\\doublePassMiddleware(\n    callable $middleware,\n    Psr\\Http\\Message\\ResponseInterface $responsePrototype = null\n) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n\n\n\ndoublePassMiddleware()\n provides a convenient way to decorate middleware that\nimplements the double pass middleware signature when piping it to your application.\n\n\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n});\n\n\n\nIf you are not using zend-diactoros as a PSR-7 implementation, you will need to\npass a response prototype as well:\n\n\n$pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n}, $response);",
            "title": "Migration"
        },
        {
            "location": "/v3/migration/#migrating-from-version-2-to-version-3",
            "text": "In this document, we outline the backwards breaking changes with version 3.0,\nand provide guidance on how to upgrade your application to be compatible.   PHP support  PSR-15  Pipeline ( MiddlewarePipe )  Changes in public interfaces  Signature changes  Class additions  Removed classes and exceptions  Removed methods  Function additions",
            "title": "Migrating from version 2 to version 3"
        },
        {
            "location": "/v3/migration/#php-support",
            "text": "We now support only PHP versions 7.1 and above.  PHP 5.6 and 7.0 support has\nbeen dropped.",
            "title": "PHP support"
        },
        {
            "location": "/v3/migration/#psr-15",
            "text": "Stratigility now supports only  PSR-15 \ninterfaces. Support of  http-interop/http-middleware  has been dropped.  All middleware and request handlers must now implement  PSR-15 \ninterfaces, including those Stratigility implements.  As a result, a number of signatures have been changed.  Primarily, these were a\nmatter of updating typehints on Interop\\Http\\ServerMiddleware\\DelegateInterface  (defined in http-interop/http-middleware \n0.4 and up, an early draft of PSR-15) and Interop\\Http\\Server\\RequestHandlerInterface  (defined in http-interop/http-server-handler ,\nthe immediate predecessor to the final spec) to Psr\\Http\\Server\\RequestHandlerInterface , and adding the return type hint Psr\\Http\\Message\\ResponseInterface .  Signatures affected include:   Zend\\Stratigility\\MiddlewarePipe::process()  Zend\\Stratigility\\Middleware\\ErrorHandler::process()  Zend\\Stratigility\\Middleware\\NotFoundHandler::process()  Zend\\Stratigility\\Middleware\\OriginalMessages::process()  Zend\\Stratigility\\MiddlewarePipe::process()   All of these classes now implement the PSR-15  MiddlewareInterface .",
            "title": "PSR-15"
        },
        {
            "location": "/v3/migration/#pipeline-middlewarepipe",
            "text": "We now only allow piping  Psr\\Http\\Server\\MiddlewareInterface  instances\ninto the  MiddlewarePipe  class.  In version 2, we had a number of internal utilities for identifying other types\nof middleware (callable, double-pass, etc.), and would decorate those within the pipe()  method. This is no longer allowed.  If you wish to use those types, you will need to decorate them using the\nappropriate decorators as outlined in the  Class additions \nsection.  Additionally,  MiddlewarePipe  is now marked  final , and may not be directly\nextended. Decorate an instance if you wish to provide alternate behavior, or\ncreate your own  MiddlewareInterface  implementation to provide alternate\ninternal logic.",
            "title": "Pipeline - MiddlewarePipe"
        },
        {
            "location": "/v3/migration/#changes-in-public-interfaces",
            "text": "",
            "title": "Changes in public interfaces"
        },
        {
            "location": "/v3/migration/#signature-changes",
            "text": "Next::__construct() : the second parameter now typehints against the\n  PSR-15  RequestHandlerInterface .    Next::handle() : the method now provides a return typehint of\n   Psr\\Http\\Message\\ResponseInterface .    MiddlewarePipe  class is marked now as  final  and implements the new\n  interface  MiddlewarePipeInterface.    MiddlewarePipe::pipe() : reduces the number of arguments to one, which now\n  typehints against  Psr\\Http\\Server\\MiddlewareInterface . This means the method\n  can no longer be used to segregate middleware by path. If you want to do that,\n  please use  Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  to decorate\n  your middleware and to provide the path prefix it will run under. See the next\n  section for details.    MiddlewarePipe::process() : the second parameter now typehints against\n   Psr\\Http\\Server\\RequestHandlerInterface , and provides a return typehint of\n   Psr\\Http\\Message\\ResponseInterface .    ErrorHandler::__construct()  and  NotFoundHandler::__construct() : the first\n  parameter of each constructor now expects a PHP  callable  capable of\n  returning a PSR-7  ResponseInterface  instance (instead of typehinting\n  directly against  ResponseInterface ). This paves the way for usage with the\n  upcoming PSR-17 (HTTP Message Factories) specification, and simplifies re-use\n  of a dependency injection container service (as otherwise you would need to\n  specify a discrete service per class that expects a response prototype, due to\n  mutability of the response body).",
            "title": "Signature changes"
        },
        {
            "location": "/v3/migration/#class-additions",
            "text": "Zend\\Stratigility\\MiddlewarePipeInterface  extends\n   Psr\\Http\\Server\\MiddlewareInterface  and  Psr\\Http\\Server\\RequestHandlerInterface ,\n  and defines the method  pipe(Psr\\Http\\Server\\MiddlewareInterface $middleware) : void .\n  It is implemented by  MiddlewarePipe .    Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator  allows you to segregate\n  middleware by a static host name. This allows executing middleware only\n  if a particular host matches.    // Segregate to hosts matching 'example.com':\n$pipeline->pipe(new HostMiddlewareDecorator('example.com', $middleware));  Alternately, use the  host()  utility function to generate the instance;  see\n  below .   Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  allows you to segregate\n  middleware by a static URI path prefix. This allows executing middleware only\n  if a particular path matches, or segregating a sub-application by path.   // Segregate to paths matching '/foo' as the prefix:\n$pipeline->pipe(new PathMiddlewareDecorator('/foo', $middleware));  Alternately, use the  path()  utility function to generate the instance;  see\n  below .   Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  provides the\n  functionality that was formerly provided by\n   Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper : it provides\n  the ability to decorate PHP callables that have the same or compatible\n  signatures to the PSR-15  MiddlewareInterface . This allows for one-off piping\n  of middleware:   $pipeline->pipe(new CallableMiddlewareDecorator(function ($req, $handler) {\n    // do some work\n    $response = $next($req, $handler);\n    // do some work\n    return $response;\n});  The arguments and return value can be type-hinted, but do not need to be. The\n  decorator provides some checking on the return value in order to raise an\n  exception if a response is not returned.  Alternately, use the  middleware()  utility function to generate the instance;\n   see below .   Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  provides the\n  functionality that was formerly provided by  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper .\n  The class now makes the response prototype argument to the constructor\n  optional, and falls back to a zend-diactoros response instance if that library\n  is installed. Internally, it decorates the  $handler  as a callable.   $pipeline->pipe(new DoublePassMiddlewareDecorator(function ($req, $res, $next) {\n    // do some work\n    $response = $next($req, $res);\n    // do some work\n    return $response;\n});  Per recommendations in previous versions, if you are using double-pass\n  middleware, do not operate on the response passed to the middleware; instead,\n  only operate on the response returned by  $next , or produce a concrete\n  response yourself.  Alternately, use the  doublePassMiddleware()  utility function to create the\n  instance;  see below .   Zend\\Stratigility\\Exception\\ExceptionInterface  - marker for\n  package-specific exceptions.",
            "title": "Class additions"
        },
        {
            "location": "/v3/migration/#removed-classes-and-exceptions",
            "text": "The following classes have been removed:   Zend\\Stratigility\\Delegate\\CallableDelegateDecorator  Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory  Zend\\Stratigility\\MiddlewareInterface  (Please use the PSR-15\n   MiddlewareInterface  instead.)  Zend\\Stratigility\\NoopFinalHandler  Zend\\Stratigility\\Route . This was an internal class used by  MiddlewarePipe \n  and  Next , and its removal should not affect consumers.   The following exceptions have been removed:   Zend\\Stratigility\\Exception\\InvalidMiddlewareException  (this is no longer\n  thrown by  MiddlewarePipe , and thus no longer necessary).  Zend\\Stratigility\\Exception\\InvalidRequestTypeException",
            "title": "Removed classes and exceptions"
        },
        {
            "location": "/v3/migration/#removed-methods",
            "text": "MiddlewarePipe::__invoke() : the class is no longer invokable.\n  Use the method  process  instead.    MiddlewarePipe::setCallableMiddlewareDecorator() : since we now accept only\n  PSR-15 middleware implementations within  MiddlewarePipe , this method is no\n  longer needed. Other middleware types should be decorated in a\n   MiddlewareInterface  implementation prior to piping.    MiddlewarePipe::setResponsePrototype() : this method is no longer needed,\n  due to removing support for non- MiddlewareInterface  types.    MiddlewarePipe::hasResponsePrototype() : this method is no longer needed,\n  due to removing support for non- MiddlewareInterface  types.    MiddlewarePipe::raiseThrowables() : this method has been deprecated since\n  2.0.0, and slated for removal with this version.    Middleware\\ErrorHandler::__invoke() : this class is no longer invokable.\n  Use the  process  method instead.    Middleware\\NotFoundHandler::__invoke() : this class is no longer invokable.\n  Use the  process  method instead.    Next::__invoke() : this class is no longer invokable. Use the method  handle \n  instead.    Next::next() : this method was a proxy to the  handle()  method, and no\n  longer of use, particularly as the class is an internal detail.    Next::process() : this method was a proxy to the  handle()  method, and no\n  longer of use, particularly as the class is an internal detail.    Next::raiseThrowables() : this method has been deprecated since 2.0.0, and\n  slated for removal with this version.",
            "title": "Removed methods"
        },
        {
            "location": "/v3/migration/#function-additions",
            "text": "Release 3.0 adds the following utility functions:",
            "title": "Function additions"
        },
        {
            "location": "/v3/migration/#host",
            "text": "function Zend\\Stratigility\\host(\n  string $host,\n  Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator  This is a convenience wrapper around instantiation of a Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator  instance:  $pipeline->pipe(host('example.com', $middleware));",
            "title": "host"
        },
        {
            "location": "/v3/migration/#path",
            "text": "function Zend\\Stratigility\\path(\n  string $pathPrefix,\n  Psr\\Http\\Server\\MiddlewareInterface $middleware\n) : Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  This is a convenience wrapper around instantiation of a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  instance:  $pipeline->pipe(path('/foo', $middleware));",
            "title": "path"
        },
        {
            "location": "/v3/migration/#middleware",
            "text": "function Zend\\Stratigility\\middleware(\n    callable $middleware\n) : Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  middleware()  provides a convenient way to decorate callable middleware that\nimplements the PSR-15 middleware signature when piping it to your application.  $pipeline->pipe(middleware(function ($request, $handler) {\n  // ...\n});",
            "title": "middleware"
        },
        {
            "location": "/v3/migration/#doublepassmiddleware",
            "text": "function Zend\\Stratigility\\doublePassMiddleware(\n    callable $middleware,\n    Psr\\Http\\Message\\ResponseInterface $responsePrototype = null\n) : Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator  doublePassMiddleware()  provides a convenient way to decorate middleware that\nimplements the double pass middleware signature when piping it to your application.  $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n});  If you are not using zend-diactoros as a PSR-7 implementation, you will need to\npass a response prototype as well:  $pipeline->pipe(doublePassMiddleware(function ($request, $response, $next) {\n  // ...\n}, $response);",
            "title": "doublePassMiddleware"
        },
        {
            "location": "/v1/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^1.0\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\nhttp-interop/http-middleware\n,\n  which provides the interfaces that will become PSR-15. This is pinned to the\n  0.2 series.\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nErrorHandler\n middleware and the\n  (legacy) \nFinalHandler\n implementation for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.\n\n\nLater versions\n\n\n\n\nVersion 2 documentation\n\n\nVersion 3 (current) documentation",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v1/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^1.0  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n   Diactoros .    http-interop/http-middleware ,\n  which provides the interfaces that will become PSR-15. This is pinned to the\n  0.2 series.    zendframework/zend-escaper , used by the  ErrorHandler  middleware and the\n  (legacy)  FinalHandler  implementation for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v1/install/#later-versions",
            "text": "Version 2 documentation  Version 3 (current) documentation",
            "title": "Later versions"
        },
        {
            "location": "/v1/usage/",
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen(new NoopFinalHandler());\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/v1/usage/#usage",
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen(new NoopFinalHandler());  The above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/v1/middleware/",
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe('/', function ($req, $res, $next) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    $res->getBody()->write('Hello world!');\n    return $res;\n});\n\n// Another page\n$app->pipe('/foo', function ($req, $res, $next) {\n    $res->getBody()->write('FOO!');\n    return $res;\n});\n\n$server->listen();\n\n\n\nIn the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or\n\n/\n, it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path \n/foo\n\n\u2014 meaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.\n\n\nSo, concisely put, \nmiddleware are PHP callables that accept a request and\nresponse object, and do something with it\n.\n\n\n\n\nhttp-interop middleware\n\n\nThe above example demonstrates the legacy (pre-1.3.0) signature for\nmiddleware, which is also widely used across other middleware frameworks\nsuch as Slim, Relay, Adroit, etc.\n\n\nhttp-interop is a project attempting to standardize middleware signatures.\nThe signature it uses for server-side middleware is:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface ServerMiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\nwhere \nDelegateInterface\n is defined as:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface DelegateInterface\n{\n    public function process(\n        RequestInterface $request\n    ) : ResponseInterface;\n}\n\n\n\nStratigility allows you to implement \nServerMiddlewareInterface\n to provide\nmiddleware.  Additionally, you can define \ncallable\n middleware with the\nfollowing signature, and it will be dispatched as http-interop middleware:\n\n\nfunction(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;\n\n\n\n(The \n$request\n argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)\n\n\nAs such, the above example can also be written as follows:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\n$app->pipe('/', function ($req, DelegateInterface $delegate) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $delegate->process($req);\n    }\n    return new TextResponse('Hello world!');\n});\n\n\n\n\n\nMiddleware can decide more processing can be performed by calling the \n$next\n\ncallable (or, when defining http-interop middleware, \n$delegate\n) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests \u2014 for instance, you could have middleware perform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:\n\n\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.\n\n\nWithin Stratigility, middleware can be:\n\n\n\n\nAny PHP callable that accepts, minimally, a\n  \nPSR-7\n\n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).\n\n\nAny \nhttp-interop 0.2.0 - middleware\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements\n  \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n.\n\n\nAn object implementing \nZend\\Stratigility\\MiddlewareInterface\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements this interface.\n  (Legacy; this interface is deprecated starting in 1.3.0.)",
            "title": "Middleware"
        },
        {
            "location": "/v1/middleware/#middleware",
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.  use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe('/', function ($req, $res, $next) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $next($req, $res);\n    }\n    $res->getBody()->write('Hello world!');\n    return $res;\n});\n\n// Another page\n$app->pipe('/foo', function ($req, $res, $next) {\n    $res->getBody()->write('FOO!');\n    return $res;\n});\n\n$server->listen();  In the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path  /foo \n\u2014 meaning it will match  /foo ,  /foo/ , and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.  So, concisely put,  middleware are PHP callables that accept a request and\nresponse object, and do something with it .",
            "title": "Middleware"
        },
        {
            "location": "/v1/middleware/#http-interop-middleware",
            "text": "The above example demonstrates the legacy (pre-1.3.0) signature for\nmiddleware, which is also widely used across other middleware frameworks\nsuch as Slim, Relay, Adroit, etc.  http-interop is a project attempting to standardize middleware signatures.\nThe signature it uses for server-side middleware is:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface ServerMiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  where  DelegateInterface  is defined as:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\ninterface DelegateInterface\n{\n    public function process(\n        RequestInterface $request\n    ) : ResponseInterface;\n}  Stratigility allows you to implement  ServerMiddlewareInterface  to provide\nmiddleware.  Additionally, you can define  callable  middleware with the\nfollowing signature, and it will be dispatched as http-interop middleware:  function(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;  (The  $request  argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)  As such, the above example can also be written as follows:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\n$app->pipe('/', function ($req, DelegateInterface $delegate) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $delegate->process($req);\n    }\n    return new TextResponse('Hello world!');\n});   Middleware can decide more processing can be performed by calling the  $next \ncallable (or, when defining http-interop middleware,  $delegate ) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests \u2014 for instance, you could have middleware perform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:  $app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);  The handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.  Within Stratigility, middleware can be:   Any PHP callable that accepts, minimally, a\n   PSR-7 \n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).  Any  http-interop 0.2.0 - middleware .\n   Zend\\Stratigility\\MiddlewarePipe  implements\n   Interop\\Http\\Middleware\\ServerMiddlewareInterface .  An object implementing  Zend\\Stratigility\\MiddlewareInterface .\n   Zend\\Stratigility\\MiddlewarePipe  implements this interface.\n  (Legacy; this interface is deprecated starting in 1.3.0.)",
            "title": "http-interop middleware"
        },
        {
            "location": "/v1/error-handlers/",
            "text": "Error Handlers\n\n\nIn your application, you may need to handle error conditions:\n\n\n\n\nErrors raised by PHP itself (e.g., inability to open a file or database\n  connection).\n\n\nExceptions/throwables raised by PHP and/or code you write or consume.\n\n\nInability of any middleware to handle a request.\n\n\n\n\nYou can typically handle these conditions via middleware itself.\n\n\nHandling 404 conditions\n\n\n\n\nSince 1.3.0\n\n\n\n\nIf no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition, \nZend\\Stratigility\\Middleware\\NotFoundHandler\n. The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:\n\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nNote that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.\n\n\nIf you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\nHandling PHP errors and exceptions\n\n\n\n\nSince 1.3.0\n\n\n\n\n\n\nOpting in to error middleware\n\n\nIf you have upgraded from Expressive 1.0.0, you will have been using the\n\nFinalHandler\n implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in \ntry/catch\n blocks.\n\n\nStarting in 1.3.0, we provide a new way to handle errors via middleware.\n\n\nTo opt-in to the new system, you must call \nraiseThrowables()\n on your\nmiddleware pipeline:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();\n\n\n\n(Starting in 2.0.0, this will no longer be necessary, but until then, this is\nhow you opt-in to the system described below.)\n\n\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n is a middleware implementation to\nregister as the \noutermost layer\n of your application (or close to the outermost\nlayer). It does the following:\n\n\n\n\nCreates a PHP error handler that catches any errors in the \nerror_handling()\n\n  mask and throws them as \nErrorException\n instances.\n\n\nWraps the invocation of the delegate in a try/catch block:\n\n\nif no exception is caught, and the result is a response, it returns it.\n\n\nif no exception is caught, it raises an exception, which will be caught.\n\n\nany caught exception is transformed into an error response.\n\n\n\n\nTo generate the error response, we provide the ability to inject a callable with\nthe following signature into the \nErrorHandler\n during instantiation:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe provide a default implementation, \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n,\nwhich generates an error response with a \n5XX\n series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.\n\n\nIn order to work, the \nErrorHandler\n needs a prototype response instance, and,\noptionally, an error response generator (if none is provided,\n\nErrorResponseGenerator\n is used, in production mode):\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n\n\nAs a full example, you can combine the two middleware into the same application\nas separate layers:\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nThe \nErrorResponseGenerator\n provides no templating facilities, and only\nresponds as \ntext/html\n. If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.\n\n\nAs an example:\n\n\nuse ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou would then pass this to the \nErrorHandler\n:\n\n\n$app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));\n\n\n\nErrorHandler Listeners\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n provides the ability to attach\n\nlisteners\n; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.\n\n\nListeners must implement the following signature:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nAttach listeners using \nErrorHandler::attachListener()\n:\n\n\n$errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});\n\n\n\nLegacy error middleware\n\n\n\n\nDeprecated starting in 1.3.0, to be removed in 2.0.0. Please see the\n  \nv2 migration guide\n for more details, as well\n  as the preceding section.\n\n\n\n\nTo handle errors, you can write middleware that accepts \nexactly\n four arguments:\n\n\nfunction ($error, $request, $response, $next) { }\n\n\n\nAlternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nWhen using \nMiddlewarePipe\n, as the queue is executed, if \n$next()\n is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call \n$next()\n.\n\nError handlers that call \n$next()\n SHOULD call it with the error it received itself, or with\nanother error.\n\n\nError handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.",
            "title": "Error Handlers"
        },
        {
            "location": "/v1/error-handlers/#error-handlers",
            "text": "In your application, you may need to handle error conditions:   Errors raised by PHP itself (e.g., inability to open a file or database\n  connection).  Exceptions/throwables raised by PHP and/or code you write or consume.  Inability of any middleware to handle a request.   You can typically handle these conditions via middleware itself.",
            "title": "Error Handlers"
        },
        {
            "location": "/v1/error-handlers/#handling-404-conditions",
            "text": "Since 1.3.0   If no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition,  Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:  // setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  Note that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.  If you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}",
            "title": "Handling 404 conditions"
        },
        {
            "location": "/v1/error-handlers/#handling-php-errors-and-exceptions",
            "text": "Since 1.3.0",
            "title": "Handling PHP errors and exceptions"
        },
        {
            "location": "/v1/error-handlers/#opting-in-to-error-middleware",
            "text": "If you have upgraded from Expressive 1.0.0, you will have been using the FinalHandler  implementation, and relying on the fact that, internally,\ndispatching wraps all middleware in  try/catch  blocks.  Starting in 1.3.0, we provide a new way to handle errors via middleware.  To opt-in to the new system, you must call  raiseThrowables()  on your\nmiddleware pipeline:  $pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();  (Starting in 2.0.0, this will no longer be necessary, but until then, this is\nhow you opt-in to the system described below.)   Zend\\Stratigility\\Middleware\\ErrorHandler  is a middleware implementation to\nregister as the  outermost layer  of your application (or close to the outermost\nlayer). It does the following:   Creates a PHP error handler that catches any errors in the  error_handling() \n  mask and throws them as  ErrorException  instances.  Wraps the invocation of the delegate in a try/catch block:  if no exception is caught, and the result is a response, it returns it.  if no exception is caught, it raises an exception, which will be caught.  any caught exception is transformed into an error response.   To generate the error response, we provide the ability to inject a callable with\nthe following signature into the  ErrorHandler  during instantiation:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We provide a default implementation,  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator ,\nwhich generates an error response with a  5XX  series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.  In order to work, the  ErrorHandler  needs a prototype response instance, and,\noptionally, an error response generator (if none is provided, ErrorResponseGenerator  is used, in production mode):  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);  As a full example, you can combine the two middleware into the same application\nas separate layers:  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  The  ErrorResponseGenerator  provides no templating facilities, and only\nresponds as  text/html . If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.  As an example:  use ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}  You would then pass this to the  ErrorHandler :  $app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));",
            "title": "Opting in to error middleware"
        },
        {
            "location": "/v1/error-handlers/#errorhandler-listeners",
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  provides the ability to attach listeners ; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.  Listeners must implement the following signature:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  Attach listeners using  ErrorHandler::attachListener() :  $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});",
            "title": "ErrorHandler Listeners"
        },
        {
            "location": "/v1/error-handlers/#legacy-error-middleware",
            "text": "Deprecated starting in 1.3.0, to be removed in 2.0.0. Please see the\n   v2 migration guide  for more details, as well\n  as the preceding section.   To handle errors, you can write middleware that accepts  exactly  four arguments:  function ($error, $request, $response, $next) { }  Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .  When using  MiddlewarePipe , as the queue is executed, if  $next()  is called with an argument, or\nif an exception is thrown, middleware will iterate through the queue until the first such error\nhandler is found. That error handler can either complete the request, or itself call  $next() . Error handlers that call  $next()  SHOULD call it with the error it received itself, or with\nanother error.  Error handlers are usually attached at the end of middleware, to prevent attempts at executing\nnon-error-handling middleware, and to ensure they can intercept errors from any other handlers.",
            "title": "Legacy error middleware"
        },
        {
            "location": "/v1/creating-middleware/",
            "text": "Creating Middleware\n\n\nTo create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware. By accepting the\nthird argument, \n$next\n, it can allow further processing via invoking that\nargument, or return handling to the parent middleware by returning a response.\n\n\nAs an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.\n\n\nfunction ($req, $res, $next) use ($router) {\n    $path = $req->getUri()->getPath();\n\n    // Route the path\n    $route = $router->route($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route->getHandler();\n    return $handler($req, $res, $next);\n}\n\n\n\nMiddleware written in this way can be any of the following:\n\n\n\n\nClosures (as shown above)\n\n\nFunctions\n\n\nStatic class methods\n\n\nPHP array callbacks (e.g., \n[ $dispatcher, 'dispatch' ]\n, where \n$dispatcher\n is a class instance)\n\n\nInvokable PHP objects (i.e., instances of classes implementing \n__invoke()\n)\n\n\nObjects implementing \nZend\\Stratigility\\MiddlewareInterface\n (including\n  \nZend\\Stratigility\\MiddlewarePipe\n)\n\n\n\n\nIn all cases, if you wish to implement typehinting, the signature is:\n\n\nfunction (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface\n\n\n\nLegacy error middleware\n\n\n\n\nDeprecated since 1.3.0; to be removed in version 2.0.0. Please use the the\n  \nNotFoundHandler\n and \nErrorHandler\n detailed in the\n  \nerror handling chapter\n, or equivalents.\n\n\n\n\nThe implementation Stratigility offers also allows you to write specialized\nerror handler middleware. The signature is the same as for normal middleware,\nexcept that it expects an additional argument prepended to the signature,\n\n$error\n.  (Alternately, you can implement \nZend\\Stratigility\\ErrorMiddlewareInterface\n.)\nThe signature is:\n\n\nfunction (\n    $error, // Can be any type\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Creating Middleware"
        },
        {
            "location": "/v1/creating-middleware/#creating-middleware",
            "text": "To create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware. By accepting the\nthird argument,  $next , it can allow further processing via invoking that\nargument, or return handling to the parent middleware by returning a response.  As an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.  function ($req, $res, $next) use ($router) {\n    $path = $req->getUri()->getPath();\n\n    // Route the path\n    $route = $router->route($path);\n    if (! $route) {\n        return $next($req, $res);\n    }\n\n    $handler = $route->getHandler();\n    return $handler($req, $res, $next);\n}  Middleware written in this way can be any of the following:   Closures (as shown above)  Functions  Static class methods  PHP array callbacks (e.g.,  [ $dispatcher, 'dispatch' ] , where  $dispatcher  is a class instance)  Invokable PHP objects (i.e., instances of classes implementing  __invoke() )  Objects implementing  Zend\\Stratigility\\MiddlewareInterface  (including\n   Zend\\Stratigility\\MiddlewarePipe )   In all cases, if you wish to implement typehinting, the signature is:  function (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Creating Middleware"
        },
        {
            "location": "/v1/creating-middleware/#legacy-error-middleware",
            "text": "Deprecated since 1.3.0; to be removed in version 2.0.0. Please use the the\n   NotFoundHandler  and  ErrorHandler  detailed in the\n   error handling chapter , or equivalents.   The implementation Stratigility offers also allows you to write specialized\nerror handler middleware. The signature is the same as for normal middleware,\nexcept that it expects an additional argument prepended to the signature, $error .  (Alternately, you can implement  Zend\\Stratigility\\ErrorMiddlewareInterface .)\nThe signature is:  function (\n    $error, // Can be any type\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    callable $next\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Legacy error middleware"
        },
        {
            "location": "/v1/executing-middleware/",
            "text": "Executing and composing middleware\n\n\nThe easiest way to execute middleware is to write closures and attach them to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest \nMiddlewarePipe\n\ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"\n\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path. Using the previous example, if the path \n/api/users/foo\n is\nmatched, the \n$api\n middleware will receive a request with the path\n\n/users/foo\n. This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.\n\n\n\n\nAnother approach is to extend the \nZend\\Stratigility\\MiddlewarePipe\n class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the \nprocess()\n\nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(Request $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}\n\n\n\nAnother approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call \nparent::__construct()\n to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}\n\n\n\nThese approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/v1/executing-middleware/#executing-and-composing-middleware",
            "text": "The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe  instance. You can nest  MiddlewarePipe \ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.  $api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/v1/executing-middleware/#request-path-changes-when-path-matched",
            "text": "When you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path. Using the previous example, if the path  /api/users/foo  is\nmatched, the  $api  middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.   Another approach is to extend the  Zend\\Stratigility\\MiddlewarePipe  class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the  process() \nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(Request $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call  parent::__construct()  to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.  use Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}  These approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/v1/api/",
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and\nhas been discussed previously. Its API is:\n\n\nnamespace Zend\\Stratigility;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\MiddlewareInterface as InteropMiddlewareInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements MiddlewareInterface, ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|InteropMiddlewareInterface|ServerRequestInterface $path,\n        callable|InteropMiddlewareInterface|ServerRequestInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface,\n        ResponseInterface $response,\n        callable $out = null\n    ) :  ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\npipe()\n takes up to two arguments. If only one argument is provided,\n\n$middleware\n will be assigned that value, and \n$path\n will be re-assigned to\nthe value \n/\n; this is an indication that the \n$middleware\n should be invoked\nfor any path. If \n$path\n is provided, the \n$middleware\n will only be executed\nfor that path and any subpaths.\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.\n\n\nIf, for example, you executed \n$pipeline->pipe('/api', $api)\n, and this was\nmatched via a URI with the path \n/api/users/foo\n, the \n$api\n middleware will\nreceive a request with the path \n/users/foo\n. This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.\n\n\n\n\nMiddleware is executed in the order in which it is piped to the\n\nMiddlewarePipe\n instance.\n\n\nThe \nMiddlewarePipe\n is itself middleware, and can be executed in stacks that\nexpect the \n__invoke()\n signature (via the \n__invoke()\n signature), or stacks\nexpecting http-interop middleware signatures (via the \nprocess()\n method).\n\n\nWhen executing the \nMiddlewarePipe\n via its \n__invoke()\n method, if \n$out\n is\nnot provided, an instance of \nZend\\Stratigility\\FinalHandler\n will be created\nand used in the event that the pipe stack is exhausted (\nMiddlewarePipe\n passes\nthe \n$response\n instance it receives to \nFinalHandler\n as well, so that the\nlatter can determine if the response it receives is new).\n\n\n\n\n$out is no longer optional\n\n\nStarting in version 1.3.0, we now raise a deprecation notice if no argument is\npassed for the \n$out\n argument to \n__invoke()\n; starting in version 2.0.0,\nthe argument will be required.  Always pass a \nNext\n instance, a\n\nZend\\Stratigility\\NoopFinalHandler\n instance, or a custom callback; we no\nlonger recommend the \nFinalHandler\n implementation.\n\n\n\n\nWhen using \n__invoke()\n, the callable \n$out\n argument should use the signature:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWithin Stratigility, \nZend\\Stratigility\\Next\n provides such an implementation.\n\n\nStarting in version 1.3.0, \nMiddlewarePipe\n also implements the http-interop\n\nServerMiddlewareInterface\n, and thus provides a \nprocess()\n method. This\nmethod requires a \nServerRequestInterface\n instance and an\n\nInterop\\Http\\Middleware\\DelegateInterface\n instance on invocation; the latter\ncan be a \nNext\n instance, as it also implements that interface.\n\n\nInternally, for both \n__invoke()\n and \nprocess()\n, \nMiddlewarePipe\n creates an\ninstance of \nZend\\Stratigility\\Next\n, feeding it its queue, executes it, and\nreturns its response.\n\n\nResponse prototype\n\n\nStarting in version 1.3.0, you can compose a \"response prototype\" in the\n\nMiddlewarePipe\n. When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the \nsection on middleware\ndecorators\n, below) such that it will now conform to\nhttp-interop middleware interfaces.\n\n\nTo use this functionality, inject the prototype before piping middleware:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->setResponsePrototype(new Response());\n\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an \nInterop\\Http\\Middleware\\DelegateInterface\n.\n\n\nFunctor invocation\n\n\nBecause \nPsr\\Http\\Message\n's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain. \nNext\n expects\nthese arguments for every invocation. Additionally, if an error condition has\noccurred, you may pass an optional third argument, \n$err\n, representing the\nerror condition.\n\n\nclass Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\nYou should \nalways\n either capture or return the return value of \n$next()\n when calling it in your\napplication. The expected return value is a response instance, but if it is not, you may want to\nreturn the response provided to you.\n\n\n\n\n$err argument\n\n\nTechnically, \nNext::__invoke()\n accepts a third, optional argument, \n$err\n.\nHowever, as of version 1.3.0, this argument is deprecated, and usage will\nraise a deprecation notice during runtime. We will be removing the argument\nentirely starting with version 2.0.0.\n\n\n$response argument\n\n\nUsing the \n$response\n argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.\n\n\nAs such, we recommend ignoring the \n$response\n argument and doing one of the\nfollowing:\n\n\n\n\nFor innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance. \nDiactoros provides a number of convenient custom responses\n.\n\n\nFor middleware delegating to another layer, operate on the \nreturned\n\n  response instead:\n\n\n\n\n$response = $next($request, $response);\nreturn $response->withHeader('X-Foo', 'Bar');\n\n\n\n\n\nDelegate invocation\n\n\n\n\nSince 1.3.0.\n\n\n\n\nWhen invoked as a \nDelegateInterface\n, the \nprocess()\n method will be invoked, and\npassed a \nServerRequestInterface\n instance \nonly\n. If you need to return a response,\nyou will need to:\n\n\n\n\nCompose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR\n\n\nCreate and return a concrete response type, OR\n\n\nOperate on a response returned by invoking the delegate.\n\n\n\n\nProviding an altered request:\n\n\n// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n\n\nReturning a response to complete the request\n\n\nIf your middleware does not need to delegate to another layer, it's time to\nreturn a response.\n\n\nWhile we pass a response when using \nNext\n as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response;\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n\n\nDelegation\n\n\nIf your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.\n\n\nIf using the legacy middleware signature, invoke the \n$next\n argument:\n\n\nreturn $next($request, $response);\n\n\n\nIf using a \nDelegateInterface\n, invoke its \nprocess()\n method:\n\n\nreturn $delegate->process($request);\n\n\n\nMiddleware should always return a response, and, if it cannot, return the\nresult of delegation.\n\n\nRaising an error condition\n\n\n\n\nDeprecated as of 1.3.0; please use exceptions and a error handling middleware\n  such as the \nErrorHandler\n\n  to handle error conditions in your application instead.\n\n\n\n\nTo raise an error condition, pass a non-null value as the third argument to \n$next()\n:\n\n\nfunction ($request, $response, $next)\n{\n    try {\n        // try some operation...\n    } catch (Exception $e) {\n        return $next($request, $response, $e); // Next registered error middleware will be invoked\n    }\n}\n\n\n\nFinalHandler\n\n\n\n\nDeprecated starting with 1.3.0. Use \nZend\\Stratigility\\NoopFinalHandler\n or a\n  custom handler guaranteed to return a response instead.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n is a default implementation of middleware to execute when the stack\nexhausts itself. It expects three arguments when invoked: a request instance, a response instance,\nand an error condition (or \nnull\n for no error). It returns a response.\n\n\nFinalHandler\n allows two optional arguments during instantiation\n\n\n\n\n$options\n, an array of options with which to configure itself. These options currently include:\n\n\nenv\n, the application environment. If set to \"production\", no stack traces will be provided.\n\n\nonerror\n, a callable to execute if an error is passed when \nFinalHandler\n is invoked. The\n    callable is invoked with the error (which will be \nnull\n in the absence of an error), the request,\n    and the response, in that order.\n\n\nPsr\\Http\\Message\\ResponseInterface $response\n; if passed, it will compare the response passed\n  during invocation against this instance; if they are different, it will return the response from\n  the invocation, as this indicates that one or more middleware provided a new response instance.\n\n\n\n\nInternally, \nFinalHandler\n does the following on invocation:\n\n\n\n\nIf \n$error\n is non-\nnull\n, it creates an error response from the response provided at invocation,\n  ensuring a 400 or 500 series response is returned.\n\n\nIf the response at invocation matches the response provided at instantiation, it returns it\n  without further changes. This is an indication that some middleware at some point in the execution\n  chain called \n$next()\n with a new response instance.\n\n\nIf the response at invocation does not match the response provided at instantiation, or if no\n  response was provided at instantiation, it creates a 404 response, as the assumption is that no\n  middleware was capable of handling the request.\n\n\n\n\nHTTP Messages\n\n\nZend\\Stratigility\\Http\\Request\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Request\n acts as a decorator for a \nPsr\\Http\\Message\\ServerRequestInterface\n\ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.\n\n\nAs an example, consider the following:\n\n\n$app1 = new Middleware();\n$app1->pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2->pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);\n\n\n\nIn the above, if the URI of the original incoming request is \n/root/foo\n, what \n$fooCallback\n will\nreceive is a URI with a past consisting of only \n/foo\n. This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.\n\n\nIf you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014 \nZend\\Stratigility\\Http\\Request\n contains a method, \ngetOriginalRequest()\n,\nwhich will always return the original request provided to the application:\n\n\nfunction ($request, $response, $next)\n{\n    $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]';\n    $response = $response->setHeader('Location', $location);\n    $response = $response->setStatus(302);\n    return $response;\n}\n\n\n\nZend\\Stratigility\\Http\\Response\n\n\n\n\nDeprecated in 1.3.0; to be removed in 2.0.0.\n\n\n\n\nZend\\Stratigility\\Http\\Response\n acts as a decorator for a \nPsr\\Http\\Message\\ResponseInterface\n\ninstance, and also implements \nZend\\Stratigility\\Http\\ResponseInterface\n, which provides the\nfollowing convenience methods:\n\n\n\n\nwrite()\n, which proxies to the \nwrite()\n method of the composed response stream.\n\n\nend()\n, which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the \nwrite()\n method. Once \nend()\n has been called, the response is\n  immutable and will throw an exception if a state mutating method like \nwithHeader\n is called.\n\n\nisComplete()\n indicates whether or not \nend()\n has been called.\n\n\n\n\nAdditionally, it provides access to the original response created by the server via the method\n\ngetOriginalResponse()\n.\n\n\nMiddleware\n\n\nStratigility provides several concrete middleware implementations.\n\n\nErrorHandler and NotFoundHandler\n\n\nThese two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the\n\nerror handling chapter\n.\n\n\nOriginalMessages\n\n\nThis callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the \nv2 migration chapter\n\nfor more details.\n\n\nMiddleware Decorators\n\n\nStarting in version 1.3.0, we offer the ability to work with http-interop\nmiddleware. Internally, if a response prototype is composed in the\n\nMiddlewarePipe\n, callable middleware piped to the \nMiddlewarePipe\n will be\nwrapped in one of these decorators.\n\n\nTwo versions exist:\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper($middleware, $response);\n\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on\n  \nInterop\\Http\\Middleware\\DelegateInterface\n:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ...\n  }\n);\n\n\n\nYou can manually decorate callable middleware using these decorators, or simply\nlet \nMiddlewarePipe\n do the work for you. To let \nMiddlewarePipe\n handle this,\nhowever, you \nmust\n compose a response prototype prior to piping middleware\nusing the legacy middleware signature.\n\n\nDelegates\n\n\nIn addition to \nZend\\Stratigility\\Next\n, Stratigility provides another\n\nInterop\\Http\\Middleware\\DelegateInterface\n implementation,\n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n.\n\n\nThis class can be used to wrap a callable \n$next\n instance for use in passing\nto a \nServerMiddlewareInterface::process()\n method as a delegate; the primary\nuse case is adapting functor middleware to work as http-interop middleware.\n\n\nAs an example:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Processed-Timestamp', time());\n    }\n}",
            "title": "API Reference"
        },
        {
            "location": "/v1/api/#api-reference",
            "text": "The following make up the primary API of Stratigility.",
            "title": "API Reference"
        },
        {
            "location": "/v1/api/#middleware",
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and\nhas been discussed previously. Its API is:  namespace Zend\\Stratigility;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\MiddlewareInterface as InteropMiddlewareInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements MiddlewareInterface, ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|InteropMiddlewareInterface|ServerRequestInterface $path,\n        callable|InteropMiddlewareInterface|ServerRequestInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface,\n        ResponseInterface $response,\n        callable $out = null\n    ) :  ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  pipe()  takes up to two arguments. If only one argument is provided, $middleware  will be assigned that value, and  $path  will be re-assigned to\nthe value  / ; this is an indication that the  $middleware  should be invoked\nfor any path. If  $path  is provided, the  $middleware  will only be executed\nfor that path and any subpaths.",
            "title": "Middleware"
        },
        {
            "location": "/v1/api/#request-path-changes-when-path-matched",
            "text": "When you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.  If, for example, you executed  $pipeline->pipe('/api', $api) , and this was\nmatched via a URI with the path  /api/users/foo , the  $api  middleware will\nreceive a request with the path  /users/foo . This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.   Middleware is executed in the order in which it is piped to the MiddlewarePipe  instance.  The  MiddlewarePipe  is itself middleware, and can be executed in stacks that\nexpect the  __invoke()  signature (via the  __invoke()  signature), or stacks\nexpecting http-interop middleware signatures (via the  process()  method).  When executing the  MiddlewarePipe  via its  __invoke()  method, if  $out  is\nnot provided, an instance of  Zend\\Stratigility\\FinalHandler  will be created\nand used in the event that the pipe stack is exhausted ( MiddlewarePipe  passes\nthe  $response  instance it receives to  FinalHandler  as well, so that the\nlatter can determine if the response it receives is new).",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/v1/api/#out-is-no-longer-optional",
            "text": "Starting in version 1.3.0, we now raise a deprecation notice if no argument is\npassed for the  $out  argument to  __invoke() ; starting in version 2.0.0,\nthe argument will be required.  Always pass a  Next  instance, a Zend\\Stratigility\\NoopFinalHandler  instance, or a custom callback; we no\nlonger recommend the  FinalHandler  implementation.   When using  __invoke() , the callable  $out  argument should use the signature:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Within Stratigility,  Zend\\Stratigility\\Next  provides such an implementation.  Starting in version 1.3.0,  MiddlewarePipe  also implements the http-interop ServerMiddlewareInterface , and thus provides a  process()  method. This\nmethod requires a  ServerRequestInterface  instance and an Interop\\Http\\Middleware\\DelegateInterface  instance on invocation; the latter\ncan be a  Next  instance, as it also implements that interface.  Internally, for both  __invoke()  and  process() ,  MiddlewarePipe  creates an\ninstance of  Zend\\Stratigility\\Next , feeding it its queue, executes it, and\nreturns its response.",
            "title": "$out is no longer optional"
        },
        {
            "location": "/v1/api/#response-prototype",
            "text": "Starting in version 1.3.0, you can compose a \"response prototype\" in the MiddlewarePipe . When present, any callable middleware piped to the instance\nwill be wrapped in a decorator (see the  section on middleware\ndecorators , below) such that it will now conform to\nhttp-interop middleware interfaces.  To use this functionality, inject the prototype before piping middleware:  $pipeline = new MiddlewarePipe();\n$pipeline->setResponsePrototype(new Response());",
            "title": "Response prototype"
        },
        {
            "location": "/v1/api/#next",
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an  Interop\\Http\\Middleware\\DelegateInterface .",
            "title": "Next"
        },
        {
            "location": "/v1/api/#functor-invocation",
            "text": "Because  Psr\\Http\\Message 's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain.  Next  expects\nthese arguments for every invocation. Additionally, if an error condition has\noccurred, you may pass an optional third argument,  $err , representing the\nerror condition.  class Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}  You should  always  either capture or return the return value of  $next()  when calling it in your\napplication. The expected return value is a response instance, but if it is not, you may want to\nreturn the response provided to you.",
            "title": "Functor invocation"
        },
        {
            "location": "/v1/api/#err-argument",
            "text": "Technically,  Next::__invoke()  accepts a third, optional argument,  $err .\nHowever, as of version 1.3.0, this argument is deprecated, and usage will\nraise a deprecation notice during runtime. We will be removing the argument\nentirely starting with version 2.0.0.",
            "title": "$err argument"
        },
        {
            "location": "/v1/api/#response-argument",
            "text": "Using the  $response  argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.  As such, we recommend ignoring the  $response  argument and doing one of the\nfollowing:   For innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance.  Diactoros provides a number of convenient custom responses .  For middleware delegating to another layer, operate on the  returned \n  response instead:   $response = $next($request, $response);\nreturn $response->withHeader('X-Foo', 'Bar');",
            "title": "$response argument"
        },
        {
            "location": "/v1/api/#delegate-invocation",
            "text": "Since 1.3.0.   When invoked as a  DelegateInterface , the  process()  method will be invoked, and\npassed a  ServerRequestInterface  instance  only . If you need to return a response,\nyou will need to:   Compose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR  Create and return a concrete response type, OR  Operate on a response returned by invoking the delegate.",
            "title": "Delegate invocation"
        },
        {
            "location": "/v1/api/#providing-an-altered-request",
            "text": "// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}",
            "title": "Providing an altered request:"
        },
        {
            "location": "/v1/api/#returning-a-response-to-complete-the-request",
            "text": "If your middleware does not need to delegate to another layer, it's time to\nreturn a response.  While we pass a response when using  Next  as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response;\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n    return $response;\n}",
            "title": "Returning a response to complete the request"
        },
        {
            "location": "/v1/api/#delegation",
            "text": "If your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.  If using the legacy middleware signature, invoke the  $next  argument:  return $next($request, $response);  If using a  DelegateInterface , invoke its  process()  method:  return $delegate->process($request);  Middleware should always return a response, and, if it cannot, return the\nresult of delegation.",
            "title": "Delegation"
        },
        {
            "location": "/v1/api/#raising-an-error-condition",
            "text": "Deprecated as of 1.3.0; please use exceptions and a error handling middleware\n  such as the  ErrorHandler \n  to handle error conditions in your application instead.   To raise an error condition, pass a non-null value as the third argument to  $next() :  function ($request, $response, $next)\n{\n    try {\n        // try some operation...\n    } catch (Exception $e) {\n        return $next($request, $response, $e); // Next registered error middleware will be invoked\n    }\n}",
            "title": "Raising an error condition"
        },
        {
            "location": "/v1/api/#finalhandler",
            "text": "Deprecated starting with 1.3.0. Use  Zend\\Stratigility\\NoopFinalHandler  or a\n  custom handler guaranteed to return a response instead.   Zend\\Stratigility\\FinalHandler  is a default implementation of middleware to execute when the stack\nexhausts itself. It expects three arguments when invoked: a request instance, a response instance,\nand an error condition (or  null  for no error). It returns a response.  FinalHandler  allows two optional arguments during instantiation   $options , an array of options with which to configure itself. These options currently include:  env , the application environment. If set to \"production\", no stack traces will be provided.  onerror , a callable to execute if an error is passed when  FinalHandler  is invoked. The\n    callable is invoked with the error (which will be  null  in the absence of an error), the request,\n    and the response, in that order.  Psr\\Http\\Message\\ResponseInterface $response ; if passed, it will compare the response passed\n  during invocation against this instance; if they are different, it will return the response from\n  the invocation, as this indicates that one or more middleware provided a new response instance.   Internally,  FinalHandler  does the following on invocation:   If  $error  is non- null , it creates an error response from the response provided at invocation,\n  ensuring a 400 or 500 series response is returned.  If the response at invocation matches the response provided at instantiation, it returns it\n  without further changes. This is an indication that some middleware at some point in the execution\n  chain called  $next()  with a new response instance.  If the response at invocation does not match the response provided at instantiation, or if no\n  response was provided at instantiation, it creates a 404 response, as the assumption is that no\n  middleware was capable of handling the request.",
            "title": "FinalHandler"
        },
        {
            "location": "/v1/api/#http-messages",
            "text": "",
            "title": "HTTP Messages"
        },
        {
            "location": "/v1/api/#zendstratigilityhttprequest",
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Request  acts as a decorator for a  Psr\\Http\\Message\\ServerRequestInterface \ninstance. The primary reason is to allow composing middleware such that you always have access to\nthe original request instance.  As an example, consider the following:  $app1 = new Middleware();\n$app1->pipe('/foo', $fooCallback);\n\n$app2 = new Middleware();\n$app2->pipe('/root', $app1);\n\n$server = Server::createServer($app2 /* ... */);  In the above, if the URI of the original incoming request is  /root/foo , what  $fooCallback  will\nreceive is a URI with a past consisting of only  /foo . This practice ensures that middleware can be\nnested safely and resolve regardless of the nesting level.  If you want access to the full URI \u2014 for instance, to construct a fully qualified URI to your\ncurrent middleware \u2014  Zend\\Stratigility\\Http\\Request  contains a method,  getOriginalRequest() ,\nwhich will always return the original request provided to the application:  function ($request, $response, $next)\n{\n    $location = $request->getOriginalRequest()->getUri()->getPath() . '/[:id]';\n    $response = $response->setHeader('Location', $location);\n    $response = $response->setStatus(302);\n    return $response;\n}",
            "title": "Zend\\Stratigility\\Http\\Request"
        },
        {
            "location": "/v1/api/#zendstratigilityhttpresponse",
            "text": "Deprecated in 1.3.0; to be removed in 2.0.0.   Zend\\Stratigility\\Http\\Response  acts as a decorator for a  Psr\\Http\\Message\\ResponseInterface \ninstance, and also implements  Zend\\Stratigility\\Http\\ResponseInterface , which provides the\nfollowing convenience methods:   write() , which proxies to the  write()  method of the composed response stream.  end() , which marks the response as complete; it can take an optional argument, which, when\n  provided, will be passed to the  write()  method. Once  end()  has been called, the response is\n  immutable and will throw an exception if a state mutating method like  withHeader  is called.  isComplete()  indicates whether or not  end()  has been called.   Additionally, it provides access to the original response created by the server via the method getOriginalResponse() .",
            "title": "Zend\\Stratigility\\Http\\Response"
        },
        {
            "location": "/v1/api/#middleware_1",
            "text": "Stratigility provides several concrete middleware implementations.",
            "title": "Middleware"
        },
        {
            "location": "/v1/api/#errorhandler-and-notfoundhandler",
            "text": "These two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the error handling chapter .",
            "title": "ErrorHandler and NotFoundHandler"
        },
        {
            "location": "/v1/api/#originalmessages",
            "text": "This callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the  v2 migration chapter \nfor more details.",
            "title": "OriginalMessages"
        },
        {
            "location": "/v1/api/#middleware-decorators",
            "text": "Starting in version 1.3.0, we offer the ability to work with http-interop\nmiddleware. Internally, if a response prototype is composed in the MiddlewarePipe , callable middleware piped to the  MiddlewarePipe  will be\nwrapped in one of these decorators.  Two versions exist:   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:   $middleware = new CallableMiddlewareWrapper($middleware, $response);   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on\n   Interop\\Http\\Middleware\\DelegateInterface :   $middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ...\n  }\n);  You can manually decorate callable middleware using these decorators, or simply\nlet  MiddlewarePipe  do the work for you. To let  MiddlewarePipe  handle this,\nhowever, you  must  compose a response prototype prior to piping middleware\nusing the legacy middleware signature.",
            "title": "Middleware Decorators"
        },
        {
            "location": "/v1/api/#delegates",
            "text": "In addition to  Zend\\Stratigility\\Next , Stratigility provides another Interop\\Http\\Middleware\\DelegateInterface  implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator .  This class can be used to wrap a callable  $next  instance for use in passing\nto a  ServerMiddlewareInterface::process()  method as a delegate; the primary\nuse case is adapting functor middleware to work as http-interop middleware.  As an example:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Processed-Timestamp', time());\n    }\n}",
            "title": "Delegates"
        },
        {
            "location": "/v2/install/",
            "text": "Installation and Requirements\n\n\nInstall this library using composer:\n\n\n$ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^2.0\n\n\n\nStratigility has the following dependencies (which are managed by Composer):\n\n\n\n\n\n\npsr/http-message\n, which provides the interfaces specified in \nPSR-7\n,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n  \nDiactoros\n.\n\n\n\n\n\n\nhttp-interop/http-middleware\n,\n  which provides the interfaces that will become PSR-15. This is pinned to 0.4.1+.\n\n\n\n\n\n\nzendframework/zend-escaper\n, used by the \nErrorHandler\n middleware and the\n  (legacy) \nFinalHandler\n implementation for escaping error messages prior to\n  passing them to the response.\n\n\n\n\n\n\nYou can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.\n\n\nPrevious versions\n\n\n\n\nVersion 1 documentation\n\n\n\n\nLater versions\n\n\n\n\nVersion 3 (current) documentation",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v2/install/#installation-and-requirements",
            "text": "Install this library using composer:  $ composer require zendframework/zend-diactoros zendframework/zend-stratigility:^2.0  Stratigility has the following dependencies (which are managed by Composer):    psr/http-message , which provides the interfaces specified in  PSR-7 ,\n  and type-hinted against in this package. In order to use Stratigility, you\n  will need an implementation of PSR-7; one such package is\n   Diactoros .    http-interop/http-middleware ,\n  which provides the interfaces that will become PSR-15. This is pinned to 0.4.1+.    zendframework/zend-escaper , used by the  ErrorHandler  middleware and the\n  (legacy)  FinalHandler  implementation for escaping error messages prior to\n  passing them to the response.    You can provide your own request and response implementations if desired as\nlong as they implement the PSR-7 HTTP message interfaces.",
            "title": "Installation and Requirements"
        },
        {
            "location": "/v2/install/#previous-versions",
            "text": "Version 1 documentation",
            "title": "Previous versions"
        },
        {
            "location": "/v2/install/#later-versions",
            "text": "Version 3 (current) documentation",
            "title": "Later versions"
        },
        {
            "location": "/v2/usage/",
            "text": "Usage\n\n\nCreating an application consists of 3 steps:\n\n\n\n\nCreate middleware or a middleware pipeline\n\n\nCreate a server, using the middleware\n\n\nInstruct the server to listen for a request\n\n\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen(new NoopFinalHandler());\n\n\n\nThe above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/v2/usage/#usage",
            "text": "Creating an application consists of 3 steps:   Create middleware or a middleware pipeline  Create a server, using the middleware  Instruct the server to listen for a request   use Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Diactoros\\Server;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app    = new MiddlewarePipe();\n$server = Server::createServer($app,\n  $_SERVER,\n  $_GET,\n  $_POST,\n  $_COOKIE,\n  $_FILES\n);\n$server->listen(new NoopFinalHandler());  The above example is useless by itself until you pipe middleware into the application.",
            "title": "Usage"
        },
        {
            "location": "/v2/middleware/",
            "text": "Middleware\n\n\nWhat is middleware?\n\n\nMiddleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\NoopFinalHandler;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->setResponsePrototype(new Response());\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe('/', function ($req, DelegateInterface $delegate) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $delegate->process($req);\n    }\n\n    $response = new Response();\n    $response->getBody()->write('Hello world!');\n    return $response;\n});\n\n// Another page\n$app->pipe('/foo', function ($req, DelegateInterface $delegate) {\n    $response = new Response();\n    $response->getBody()->write('FOO!');\n    return $response;\n});\n\n// 404 handler\n$app->pipe(new NotFoundHandler(new Response());\n\n$server->listen(new NoopFinalHandler());\n\n\n\nIn the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or\n\n/\n, it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path \n/foo\n\n\u2014 meaning it will match \n/foo\n, \n/foo/\n, and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.\n\n\nSo, concisely put, \nmiddleware are PHP callables that accept a request object,\nand do something with it\n.\n\n\n\n\nhttp-interop middleware\n\n\nThe above example demonstrates the using the interfaces from the http-interop\nproject. http-interop is a project attempting to standardize middleware signatures.\nThe signature of the 0.4 series server-side middleware, on which Stratigility\n2.X is based, is:\n\n\nnamespace Interop\\Http\\ServerMiddleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\ninterface DelegateInterface\n{\n    public function process(\n        ServerRequestInterface $request\n    ) : ResponseInterface;\n}\n\n\n\nStratigility allows you to implement the http-interop/http-middleware\nmiddleware interface to provide middleware.  Additionally, you can define\n\ncallable\n middleware with the following signature, and it will be dispatched\nas http-interop middleware:\n\n\nfunction(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;\n\n\n\n(The \n$request\n argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)\n\n\nFinally, to keep backwards compatibility with Stratigility v1, as well as\nother projects that have not yet adopted http-interop, we allow using the\n\"double-pass\" signature (so-called because you pass both a request and response\nobject to the delegate):\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) : ResponseInterface\n\n\n\nwhere \n$next\n is expected to have the following signature:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nAs such, the above example can also be written as follows:\n\n\n$app->pipe('/', function ($request, $response, $next) {\n    if (! in_array($request->getUri()->getPath(), ['/', ''], true)) {\n        return $next($request, $response);\n    }\n    return new TextResponse('Hello world!');\n});\n\n\n\n\n\nMiddleware can decide more processing can be performed by calling the \n$next\n\ncallable (or, when defining http-interop middleware, \n$delegate\n) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests \u2014 for instance, you could have middleware perform the following:\n\n\n\n\nHandle authentication details\n\n\nPerform content negotiation\n\n\nPerform HTTP negotiation\n\n\nRoute the path to a more appropriate, specific handler\n\n\n\n\nEach middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:\n\n\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n\n\nThe handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.\n\n\nWithin Stratigility, middleware can be:\n\n\n\n\nAny PHP callable that accepts, minimally, a\n  \nPSR-7\n\n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).\n\n\nAny \nhttp-interop 0.4.1 - middleware\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements\n  \nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n. (Stratigility 2.0 series.)\n\n\nAny \nhttp-interop 0.5.0 - middleware\n.\n  \nZend\\Stratigility\\MiddlewarePipe\n implements\n  \nInterop\\Http\\Server\\MiddlewareInterface\n. (Since Stratigility 2.1)",
            "title": "Middleware"
        },
        {
            "location": "/v2/middleware/#middleware",
            "text": "What is middleware?  Middleware is code that exists between the request and response, and which can\ntake the incoming request, perform actions based on it, and either complete the\nresponse or pass delegation on to the next middleware in the queue.  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Diactoros\\Server;\nuse Zend\\Stratigility\\MiddlewarePipe;\nuse Zend\\Stratigility\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\NoopFinalHandler;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->setResponsePrototype(new Response());\n\n$server = Server::createServer($app, $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES);\n\n// Landing page\n$app->pipe('/', function ($req, DelegateInterface $delegate) {\n    if (! in_array($req->getUri()->getPath(), ['/', ''], true)) {\n        return $delegate->process($req);\n    }\n\n    $response = new Response();\n    $response->getBody()->write('Hello world!');\n    return $response;\n});\n\n// Another page\n$app->pipe('/foo', function ($req, DelegateInterface $delegate) {\n    $response = new Response();\n    $response->getBody()->write('FOO!');\n    return $response;\n});\n\n// 404 handler\n$app->pipe(new NotFoundHandler(new Response());\n\n$server->listen(new NoopFinalHandler());  In the above example, we have two examples of middleware. The first is a\nlanding page, and listens at the root path. If the request path is empty or / , it completes the response. If it is not, it delegates to the next\nmiddleware in the stack. The second middleware matches on the path  /foo \n\u2014 meaning it will match  /foo ,  /foo/ , and any path beneath. In that\ncase, it will complete the response with its own message. If no paths match at\nthis point, a \"final handler\" is composed by default to report 404 status.  So, concisely put,  middleware are PHP callables that accept a request object,\nand do something with it .",
            "title": "Middleware"
        },
        {
            "location": "/v2/middleware/#http-interop-middleware",
            "text": "The above example demonstrates the using the interfaces from the http-interop\nproject. http-interop is a project attempting to standardize middleware signatures.\nThe signature of the 0.4 series server-side middleware, on which Stratigility\n2.X is based, is:  namespace Interop\\Http\\ServerMiddleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\ninterface DelegateInterface\n{\n    public function process(\n        ServerRequestInterface $request\n    ) : ResponseInterface;\n}  Stratigility allows you to implement the http-interop/http-middleware\nmiddleware interface to provide middleware.  Additionally, you can define callable  middleware with the following signature, and it will be dispatched\nas http-interop middleware:  function(\n    ServerRequestInterface $request,\n    DelegateInterface $delegate\n) : ResponseInterface;  (The  $request  argument does not require a typehint when defining callable\nmiddleware, but we encourage its use.)  Finally, to keep backwards compatibility with Stratigility v1, as well as\nother projects that have not yet adopted http-interop, we allow using the\n\"double-pass\" signature (so-called because you pass both a request and response\nobject to the delegate):  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) : ResponseInterface  where  $next  is expected to have the following signature:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  As such, the above example can also be written as follows:  $app->pipe('/', function ($request, $response, $next) {\n    if (! in_array($request->getUri()->getPath(), ['/', ''], true)) {\n        return $next($request, $response);\n    }\n    return new TextResponse('Hello world!');\n});   Middleware can decide more processing can be performed by calling the  $next \ncallable (or, when defining http-interop middleware,  $delegate ) passed during\ninvocation. With this paradigm, you can build a workflow engine for handling\nrequests \u2014 for instance, you could have middleware perform the following:   Handle authentication details  Perform content negotiation  Perform HTTP negotiation  Route the path to a more appropriate, specific handler   Each middleware can itself be middleware, and can attach to specific paths,\nallowing you to mix and match applications under a common domain. As an\nexample, you could put API middleware next to middleware that serves its\ndocumentation, next to middleware that serves files, and segregate each by URI:  $app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);  The handlers in each middleware attached this way will see a URI with that path\nsegment stripped, allowing them to be developed separately and re-used under\nany path you wish.  Within Stratigility, middleware can be:   Any PHP callable that accepts, minimally, a\n   PSR-7 \n  ServerRequest and Response (in that order), and, optionally, a callable (for\n  invoking the next middleware in the queue, if any).  Any  http-interop 0.4.1 - middleware .\n   Zend\\Stratigility\\MiddlewarePipe  implements\n   Interop\\Http\\ServerMiddleware\\MiddlewareInterface . (Stratigility 2.0 series.)  Any  http-interop 0.5.0 - middleware .\n   Zend\\Stratigility\\MiddlewarePipe  implements\n   Interop\\Http\\Server\\MiddlewareInterface . (Since Stratigility 2.1)",
            "title": "http-interop middleware"
        },
        {
            "location": "/v2/error-handlers/",
            "text": "Error Handlers\n\n\nIn your application, you may need to handle error conditions:\n\n\n\n\nErrors raised by PHP itself (e.g., inability to open a file or database\n  connection).\n\n\nExceptions/throwables raised by PHP and/or code you write or consume.\n\n\nInability of any middleware to handle a request.\n\n\n\n\nYou can typically handle these conditions via middleware itself.\n\n\nHandling 404 conditions\n\n\nIf no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition, \nZend\\Stratigility\\Middleware\\NotFoundHandler\n. The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:\n\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nNote that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.\n\n\nIf you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}\n\n\n\nHandling PHP errors and exceptions\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n is a middleware implementation to\nregister as the \noutermost layer\n of your application (or close to the outermost\nlayer). It does the following:\n\n\n\n\nCreates a PHP error handler that catches any errors in the \nerror_handling()\n\n  mask and throws them as \nErrorException\n instances.\n\n\nWraps the invocation of the delegate in a try/catch block:\n\n\nif no exception is caught, and the result is a response, it returns it.\n\n\nif no exception is caught, it raises an exception, which will be caught.\n\n\nany caught exception is transformed into an error response.\n\n\n\n\nTo generate the error response, we provide the ability to inject a callable with\nthe following signature into the \nErrorHandler\n during instantiation:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe provide a default implementation, \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n,\nwhich generates an error response with a \n5XX\n series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.\n\n\nIn order to work, the \nErrorHandler\n needs a prototype response instance, and,\noptionally, an error response generator (if none is provided,\n\nErrorResponseGenerator\n is used, in production mode):\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n\n\nAs a full example, you can combine the two middleware into the same application\nas separate layers:\n\n\n// setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application\n\n\n\nThe \nErrorResponseGenerator\n provides no templating facilities, and only\nresponds as \ntext/html\n. If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.\n\n\nAs an example:\n\n\nuse ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou would then pass this to the \nErrorHandler\n:\n\n\n$app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));\n\n\n\nErrorHandler Listeners\n\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n provides the ability to attach\n\nlisteners\n; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.\n\n\nListeners must implement the following signature:\n\n\nPsr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nAttach listeners using \nErrorHandler::attachListener()\n:\n\n\n$errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});",
            "title": "Error Handlers"
        },
        {
            "location": "/v2/error-handlers/#error-handlers",
            "text": "In your application, you may need to handle error conditions:   Errors raised by PHP itself (e.g., inability to open a file or database\n  connection).  Exceptions/throwables raised by PHP and/or code you write or consume.  Inability of any middleware to handle a request.   You can typically handle these conditions via middleware itself.",
            "title": "Error Handlers"
        },
        {
            "location": "/v2/error-handlers/#handling-404-conditions",
            "text": "If no middleware is able to handle the incoming request, this is typically\nrepresentative of an HTTP 404 status. Stratigility provides a barebones\nmiddleware that you may register in an innermost layer that will return a 404\ncondition,  Zend\\Stratigility\\Middleware\\NotFoundHandler . The class requires a\nresponse prototype instance that it will use to provide the 404 status and a\nmessage indicating the request method and URI used:  // setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  Note that it is the last middleware piped into the application! Since it returns\na response, no deeper nested layers will execute once it has been invoked.  If you would like a templated response, you will need to write your own\nmiddleware; such middleware might look like the following:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass NotFoundMiddleware implements ServerMiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseInterface $response\n    ) {\n        $this->renderer = $renderer;\n        $this->response = $response;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $this->response->withStatus(404);\n        $response->getBody()->write(\n            $this->renderer->render('error::404')\n        );\n        return $response;\n    }\n}",
            "title": "Handling 404 conditions"
        },
        {
            "location": "/v2/error-handlers/#handling-php-errors-and-exceptions",
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  is a middleware implementation to\nregister as the  outermost layer  of your application (or close to the outermost\nlayer). It does the following:   Creates a PHP error handler that catches any errors in the  error_handling() \n  mask and throws them as  ErrorException  instances.  Wraps the invocation of the delegate in a try/catch block:  if no exception is caught, and the result is a response, it returns it.  if no exception is caught, it raises an exception, which will be caught.  any caught exception is transformed into an error response.   To generate the error response, we provide the ability to inject a callable with\nthe following signature into the  ErrorHandler  during instantiation:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We provide a default implementation,  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator ,\nwhich generates an error response with a  5XX  series status code and a message\nderived from the reason phrase, if any is present. You may pass a boolean flag\nto its constructor indicating the application is in development mode; if so, the\nresponse will have the stack trace included in the body.  In order to work, the  ErrorHandler  needs a prototype response instance, and,\noptionally, an error response generator (if none is provided, ErrorResponseGenerator  is used, in production mode):  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);  As a full example, you can combine the two middleware into the same application\nas separate layers:  // setup error handling\n$app->pipe(new ErrorHandler(new Response(), new ErrorResponseGenerator($isDevelopmentMode));\n\n// setup layers\n$app->pipe(/* ... */);\n$app->pipe(/* ... */);\n\n// setup 404 handling\n$app->pipe(new NotFoundHandler(new Response());\n\n// execute application  The  ErrorResponseGenerator  provides no templating facilities, and only\nresponds as  text/html . If you want to provide a templated response, or a\ndifferent serialization and/or markup format, you will need to write your own\nerror response generator.  As an example:  use ErrorException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Throwable;\nuse Zend\\Stratigility\\Exception\\MissingResponseException;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass TemplatedErrorResponseGenerator\n{\n    private $isDevelopmentMode;\n    private $renderer;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $isDevelopmentMode = false\n    ) {\n        $this->renderer = $renderer;\n        $this->isDevelopmentMode = $isDevelopmentMode;\n    }\n\n    public function __invoke($e, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $response = $response->withStatus(500);\n        $response->getBody()->write($this->renderer->render('error::error', [\n            'exception'        => $e,\n            'development_mode' => $this->isDevelopmentMode,\n        ]));\n        return $response;\n    }\n}  You would then pass this to the  ErrorHandler :  $app->pipe(new ErrorHandler(\n    new Response(),\n    new TemplatedErrorResponseGenerator($renderer, $isDevelopmentMode)\n));",
            "title": "Handling PHP errors and exceptions"
        },
        {
            "location": "/v2/error-handlers/#errorhandler-listeners",
            "text": "Zend\\Stratigility\\Middleware\\ErrorHandler  provides the ability to attach listeners ; these are triggered when an error or exception is caught, and\nprovided with the exception/throwable raised, the original request, and the\nfinal response. These instances are considered immutable, so listeners are for\npurposes of logging/monitoring only.  Listeners must implement the following signature:  Psr\\Http\\Message\\ResponseInterface;\nPsr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  Attach listeners using  ErrorHandler::attachListener() :  $errorHandler->attachListener(function ($throwable, $request, $response) use ($logger) {\n    $message = sprintf(\n        '[%s] %s %s: %s',\n        date('Y-m-d H:i:s'),\n        $request->getMethod(),\n        (string) $request->getUri(),\n        $throwable->getMessage()\n    );\n    $logger->error($message);\n});",
            "title": "ErrorHandler Listeners"
        },
        {
            "location": "/v2/creating-middleware/",
            "text": "Creating Middleware\n\n\nTo create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware in order to\nproduce or return a response.\n\n\nAs an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\n\nfunction ($req, DelegateInterface $delegate) use ($router) {\n    $path = $req->getUri()->getPath();\n\n    // Route the path\n    $route = $router->route($path);\n    if (! $route) {\n        return $delegate->process($req);\n    }\n\n    /** @var MiddlewareInterface $handler */\n    $handler = $route->getHandler();\n    return $handler->process($req, $delegate);\n}\n\n\n\nMiddleware written in this way can be any of the following:\n\n\n\n\nClosures (as shown above)\n\n\nFunctions\n\n\nStatic class methods\n\n\nPHP array callbacks (e.g., \n[ $dispatcher, 'dispatch' ]\n, where \n$dispatcher\n is a class instance)\n\n\nInvokable PHP objects (i.e., instances of classes implementing \n__invoke()\n)\n\n\nObjects implementing \nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n\n\n\n\nIn all cases, if you wish to implement typehinting, the signature is:\n\n\nfunction (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Creating Middleware"
        },
        {
            "location": "/v2/creating-middleware/#creating-middleware",
            "text": "To create middleware, write a callable capable of receiving minimally PSR-7\nServerRequest and Response objects, and a callback to call the next middleware\nin the chain. In your middleware, you can handle as much or as little of the\nrequest as you want, including delegating to other middleware in order to\nproduce or return a response.  As an example, consider the following middleware which will use an external\nrouter to map the incoming request path to a handler; if unable to map the\nrequest, it returns processing to the next middleware.  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\n\nfunction ($req, DelegateInterface $delegate) use ($router) {\n    $path = $req->getUri()->getPath();\n\n    // Route the path\n    $route = $router->route($path);\n    if (! $route) {\n        return $delegate->process($req);\n    }\n\n    /** @var MiddlewareInterface $handler */\n    $handler = $route->getHandler();\n    return $handler->process($req, $delegate);\n}  Middleware written in this way can be any of the following:   Closures (as shown above)  Functions  Static class methods  PHP array callbacks (e.g.,  [ $dispatcher, 'dispatch' ] , where  $dispatcher  is a class instance)  Invokable PHP objects (i.e., instances of classes implementing  __invoke() )  Objects implementing  Interop\\Http\\ServerMiddleware\\MiddlewareInterface   In all cases, if you wish to implement typehinting, the signature is:  function (\n    Psr\\Http\\Message\\ServerRequestInterface $request,\n    Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate\n) : Psr\\Http\\Message\\ResponseInterface",
            "title": "Creating Middleware"
        },
        {
            "location": "/v2/executing-middleware/",
            "text": "Executing and composing middleware\n\n\nThe easiest way to execute middleware is to write closures and attach them to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance. You can nest \nMiddlewarePipe\n\ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.\n\n\n$api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"\n\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path. Using the previous example, if the path \n/api/users/foo\n is\nmatched, the \n$api\n middleware will receive a request with the path\n\n/users/foo\n. This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.\n\n\n\n\nHandling errors\n\n\nWhile the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n class:\n\n\nuse Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(new ErrorHandler(new Response());\n// Add more middleware...\n\n\n\nYou can learn how to customize the error handler to your needs in the\n\nchapter on error handlers\n.\n\n\nExtending the MiddlewarePipe\n\n\nAnother approach is to extend the \nZend\\Stratigility\\MiddlewarePipe\n class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the \nprocess()\n\nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:\n\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}\n\n\n\nAnother approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call \nparent::__construct()\n to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.\n\n\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}\n\n\n\nThese approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/v2/executing-middleware/#executing-and-composing-middleware",
            "text": "The easiest way to execute middleware is to write closures and attach them to a Zend\\Stratigility\\MiddlewarePipe  instance. You can nest  MiddlewarePipe \ninstances to create groups of related middleware, and attach them using a base\npath so they only execute if that path is matched.  $api = new MiddlewarePipe();  // API middleware collection\n$api->pipe(/* ... */);        // repeat as necessary\n\n$app = new MiddlewarePipe();  // Middleware representing the application\n$app->pipe('/api', $api);     // API middleware attached to the path \"/api\"",
            "title": "Executing and composing middleware"
        },
        {
            "location": "/v2/executing-middleware/#request-path-changes-when-path-matched",
            "text": "When you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path. Using the previous example, if the path  /api/users/foo  is\nmatched, the  $api  middleware will receive a request with the path /users/foo . This allows middleware segregated by path to be re-used without\nchanges to its own internal routing.",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/v2/executing-middleware/#handling-errors",
            "text": "While the above will give you a basic application, it has no error handling\nwhatsoever. We recommend adding an initial middleware layer using the Zend\\Stratigility\\Middleware\\ErrorHandler  class:  use Zend\\Diactoros\\Response;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(new ErrorHandler(new Response());\n// Add more middleware...  You can learn how to customize the error handler to your needs in the chapter on error handlers .",
            "title": "Handling errors"
        },
        {
            "location": "/v2/executing-middleware/#extending-the-middlewarepipe",
            "text": "Another approach is to extend the  Zend\\Stratigility\\MiddlewarePipe  class\nitself, particularly if you want to allow attaching other middleware to your\nown middleware. In such a case, you will generally override the  process() \nmethod to perform any additional logic you have, and then call on the parent in\norder to iterate through your stack of middleware:  class CustomMiddleware extends MiddlewarePipe\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // perform some work...\n\n        // delegate to parent\n        parent::process($request, $delegate);\n\n        // maybe do more work?\n    }\n}  Another approach using this method would be to override the constructor to add\nin specific middleware, perhaps using configuration provided. In this case,\nmake sure to also call  parent::__construct()  to ensure the middleware queue\nis initialized; we recommend doing this as the first action of the method.  use Zend\\Stratigility\\MiddlewarePipe;\n\nclass CustomMiddleware extends MiddlewarePipe\n{\n    public function __construct($configuration)\n    {\n        parent::__construct();\n\n        // do something with configuration ...\n\n        // attach some middleware ...\n\n        $this->pipe(/* some middleware */);\n    }\n}  These approaches are particularly suited for cases where you may want to\nimplement a specific workflow for an application segment using existing\nmiddleware, but do not necessarily want that middleware applied to all requests\nin the application.",
            "title": "Extending the MiddlewarePipe"
        },
        {
            "location": "/v2/api/",
            "text": "API Reference\n\n\nThe following make up the primary API of Stratigility.\n\n\nMiddleware\n\n\nZend\\Stratigility\\MiddlewarePipe\n is the primary application interface, and\nhas been discussed previously. Its API is:\n\n\nnamespace Zend\\Stratigility;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|ServerMiddlewareInterface $path,\n        callable|ServerMiddlewareInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        $delegate\n    ) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}\n\n\n\npipe()\n takes up to two arguments. If only one argument is provided,\n\n$middleware\n will be assigned that value, and \n$path\n will be re-assigned to\nthe value \n/\n; this is an indication that the \n$middleware\n should be invoked\nfor any path. If \n$path\n is provided, the \n$middleware\n will only be executed\nfor that path and any subpaths.\n\n\n\n\nRequest path changes when path matched\n\n\nWhen you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.\n\n\nIf, for example, you executed \n$pipeline->pipe('/api', $api)\n, and this was\nmatched via a URI with the path \n/api/users/foo\n, the \n$api\n middleware will\nreceive a request with the path \n/users/foo\n. This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.\n\n\n\n\nMiddleware is executed in the order in which it is piped to the\n\nMiddlewarePipe\n instance.\n\n\nThe \nMiddlewarePipe\n is itself middleware, and can be executed in stacks that\nexpect the \n__invoke()\n signature (via the \n__invoke()\n signature), or stacks\nexpecting http-interop middleware signatures (via the \nprocess()\n method).\n\n\nWhen using \n__invoke()\n, the callable \n$out\n argument should either implement\ndelegator/request handler interface from \nhttp-interop/http-middleware\n\n(depends on version you are using), or use the signature:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nMost often, you can pass an instance of \nZend\\Stratigility\\NoopFinalHandler\n for\n\n$out\n if invoking a middleware pipeline manually; otherwise, a suitable\ncallback will be provided for you (typically an instance of\n\nZend\\Stratigility\\Next\n, which \nMiddlewarePipe\n creates internally before\ndispatching to the various middleware in its pipeline).\n\n\nMiddleware should either return a response, or the result of\n\n$next()/DelegateInterface::process()/RequestHandlerInterface::handle()\n\n(which should eventually evaluate to a response instance).\n\n\nWithin Stratigility, \nZend\\Stratigility\\Next\n provides an implementation\ncompatible with either usage.\n\n\nMiddlewarePipe\n implements the http-interop/http-middleware server-side\nmiddleware interface, and thus provides a \nprocess()\n method. This method\nrequires a \nServerRequestInterface\n instance and an http-interop/http-middleware\n\nDelegateInterface\n instance on invocation; the latter can be a \nNext\n instance,\nas it also implements that interface.\n\n\nInternally, for both \n__invoke()\n and \nprocess()\n, \nMiddlewarePipe\n creates an\ninstance of \nZend\\Stratigility\\Next\n (feeding it its queue), executes it, and\nreturns its response.\n\n\nResponse prototype\n\n\nYou may compose a \"response prototype\" in the \nMiddlewarePipe\n. When present,\nany callable middleware piped to the instance will be wrapped in a decorator\n(see the \nsection on middleware decorators\n, below) such\nthat it will now conform to http-interop middleware interfaces.\n\n\nTo use this functionality, inject the prototype before piping middleware:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->setResponsePrototype(new Response());\n\n\n\nNext\n\n\nZend\\Stratigility\\Next\n is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an http-interop/http-middleware\n\nDelegateInterface\n.\n\n\nFunctor invocation\n\n\nBecause \nPsr\\Http\\Message\n's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain. \nNext\n expects\nthese arguments for every invocation.\n\n\nclass Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}\n\n\n\nYou should \nalways\n either capture or return the return value of \n$next()\n\nwhen calling it in your application, or return a response yourself.\n\n\n\n\n$response argument\n\n\nUsing the \n$response\n argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.\n\n\nAs such, we recommend ignoring the \n$response\n argument and doing one of the\nfollowing:\n\n\n\n\nFor innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance. \nDiactoros provides a number of convenient custom responses\n.\n\n\nFor middleware delegating to another layer, operate on the \nreturned\n\n  response instead:\n\n\n\n\n$response = $next($request, $response);\nreturn $response->withHeader('X-Foo', 'Bar');\n\n\n\n\n\nDelegate invocation\n\n\nWhen invoked as a \nDelegateInterface\n, the \nprocess()\n method will be invoked, and\npassed a \nServerRequestInterface\n instance \nonly\n. If you need to return a response,\nyou will need to:\n\n\n\n\nCompose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR\n\n\nCreate and return a concrete response type, OR\n\n\nOperate on a response returned by invoking the delegate.\n\n\n\n\nProviding an altered request:\n\n\n// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n\n\nProviding an altered request and operating on the returned response:\n\n\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $response = $next(\n        $request->withBodyParams($bodyParser($request)),\n        $response\n    );\n\n    return $response->withAddedHeader('Cache-Control', [\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}\n\n\n\nReturning a response to complete the request\n\n\nIf your middleware does not need to delegate to another layer, it's time to\nreturn a response.\n\n\nWhile we pass a response when using \nNext\n as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.\n\n\n$prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}\n\n\n\nDelegation\n\n\nIf your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.\n\n\nIf using the legacy middleware signature, invoke the \n$next\n argument:\n\n\nreturn $next($request, $response);\n\n\n\nIf using a \nDelegateInterface\n, invoke its \nprocess()\n method:\n\n\nreturn $delegate->process($request);\n\n\n\nMiddleware should always return a response, and, if it cannot, return the\nresult of delegation.\n\n\nRaising an error condition\n\n\nIf your middleware cannot complete \u2014 perhaps a database error occurred, a\nservice was unreachable, etc. \u2014 how can you report the error?\n\n\nRaise an exception!\n\n\nfunction ($request, $response, $next) use ($service)\n{\n    $result = $service->fetchSomething();\n    if (! $result->isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}\n\n\n\nUse the \nErrorHandler middleware\n\nto handle exceptions thrown by your middleware and report the error condition to\nyour users.\n\n\nMiddleware\n\n\nStratigility provides several concrete middleware implementations.\n\n\nErrorHandler and NotFoundHandler\n\n\nThese two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the\n\nerror handling chapter\n.\n\n\nOriginalMessages\n\n\nThis callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the \nmigration chapter\n\nfor more details.\n\n\nMiddleware Decorators\n\n\nWithin \nMiddlewarePipe\n, if a response prototype is composed, callable\nmiddleware piped to the instance will be wrapped in a decorator.\n\n\nTwo versions exist:\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper($middleware, $response);\n\n\n\n\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on the\n  http-interop/http-middleware \nDelegateInterface\n:\n\n\n\n\n$middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ...\n  }\n);\n\n\n\nYou can manually decorate callable middleware using these decorators, or simply\nlet \nMiddlewarePipe\n do the work for you. To let \nMiddlewarePipe\n handle this,\nhowever, you \nmust\n compose a response prototype prior to piping middleware\nusing the legacy middleware signature.\n\n\nDelegates\n\n\nIn addition to \nZend\\Stratigility\\Next\n, Stratigility provides another\nhttp-interop/http-middleware \nDelegateInterface\n implementation,\n\nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n.\n\n\nThis class can be used to wrap a callable \n$next\n instance for use in passing to\nan http-interop/http-middleware middleware interface \nprocess()\n method as a\ndelegate; the primary use case is adapting functor middleware to work as\nhttp-interop middleware.\n\n\nAs an example:\n\n\n// http-interop/http-middleware 0.2:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.4.1:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Processed-Timestamp', time());\n    }\n}",
            "title": "API Reference"
        },
        {
            "location": "/v2/api/#api-reference",
            "text": "The following make up the primary API of Stratigility.",
            "title": "API Reference"
        },
        {
            "location": "/v2/api/#middleware",
            "text": "Zend\\Stratigility\\MiddlewarePipe  is the primary application interface, and\nhas been discussed previously. Its API is:  namespace Zend\\Stratigility;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass MiddlewarePipe implements ServerMiddlewareInterface\n{\n    public function pipe(\n        string|callable|ServerMiddlewareInterface $path,\n        callable|ServerMiddlewareInterface $middleware = null\n    );\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        $delegate\n    ) : ResponseInterface;\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) : ResponseInterface;\n}  pipe()  takes up to two arguments. If only one argument is provided, $middleware  will be assigned that value, and  $path  will be re-assigned to\nthe value  / ; this is an indication that the  $middleware  should be invoked\nfor any path. If  $path  is provided, the  $middleware  will only be executed\nfor that path and any subpaths.",
            "title": "Middleware"
        },
        {
            "location": "/v2/api/#request-path-changes-when-path-matched",
            "text": "When you pipe middleware using a path (other than '' or '/'), the middleware\nis dispatched with a request that strips the matched segment(s) from the start\nof the path.  If, for example, you executed  $pipeline->pipe('/api', $api) , and this was\nmatched via a URI with the path  /api/users/foo , the  $api  middleware will\nreceive a request with the path  /users/foo . This allows middleware\nsegregated by path to be re-used without changes to its own internal routing.   Middleware is executed in the order in which it is piped to the MiddlewarePipe  instance.  The  MiddlewarePipe  is itself middleware, and can be executed in stacks that\nexpect the  __invoke()  signature (via the  __invoke()  signature), or stacks\nexpecting http-interop middleware signatures (via the  process()  method).  When using  __invoke() , the callable  $out  argument should either implement\ndelegator/request handler interface from  http-interop/http-middleware \n(depends on version you are using), or use the signature:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Most often, you can pass an instance of  Zend\\Stratigility\\NoopFinalHandler  for $out  if invoking a middleware pipeline manually; otherwise, a suitable\ncallback will be provided for you (typically an instance of Zend\\Stratigility\\Next , which  MiddlewarePipe  creates internally before\ndispatching to the various middleware in its pipeline).  Middleware should either return a response, or the result of $next()/DelegateInterface::process()/RequestHandlerInterface::handle() \n(which should eventually evaluate to a response instance).  Within Stratigility,  Zend\\Stratigility\\Next  provides an implementation\ncompatible with either usage.  MiddlewarePipe  implements the http-interop/http-middleware server-side\nmiddleware interface, and thus provides a  process()  method. This method\nrequires a  ServerRequestInterface  instance and an http-interop/http-middleware DelegateInterface  instance on invocation; the latter can be a  Next  instance,\nas it also implements that interface.  Internally, for both  __invoke()  and  process() ,  MiddlewarePipe  creates an\ninstance of  Zend\\Stratigility\\Next  (feeding it its queue), executes it, and\nreturns its response.",
            "title": "Request path changes when path matched"
        },
        {
            "location": "/v2/api/#response-prototype",
            "text": "You may compose a \"response prototype\" in the  MiddlewarePipe . When present,\nany callable middleware piped to the instance will be wrapped in a decorator\n(see the  section on middleware decorators , below) such\nthat it will now conform to http-interop middleware interfaces.  To use this functionality, inject the prototype before piping middleware:  $pipeline = new MiddlewarePipe();\n$pipeline->setResponsePrototype(new Response());",
            "title": "Response prototype"
        },
        {
            "location": "/v2/api/#next",
            "text": "Zend\\Stratigility\\Next  is primarily an implementation detail of middleware,\nand exists to allow delegating to middleware registered later in the stack. It\nis implemented both as a functor and as an http-interop/http-middleware DelegateInterface .",
            "title": "Next"
        },
        {
            "location": "/v2/api/#functor-invocation",
            "text": "Because  Psr\\Http\\Message 's interfaces are immutable, if you make changes to\nyour Request and/or Response instances, you will have new instances, and will\nneed to make these known to the next middleware in the chain.  Next  expects\nthese arguments for every invocation.  class Next\n{\n    public function __invoke(\n        Psr\\Http\\Message\\ServerRequestInterface $request,\n        Psr\\Http\\Message\\ResponseInterface $response\n    ) : Psr\\Http\\Message\\ResponseInterface;\n}  You should  always  either capture or return the return value of  $next() \nwhen calling it in your application, or return a response yourself.",
            "title": "Functor invocation"
        },
        {
            "location": "/v2/api/#response-argument",
            "text": "Using the  $response  argument is unsafe when using delegation, as an inner\nlayer could return an entirely different response, ignoring any changes you\nmay have introduced previously. Additionally, when manipulating the response\nfrom an inner layer, you may be inheriting unwanted context.  As such, we recommend ignoring the  $response  argument and doing one of the\nfollowing:   For innermost middleware that will be returning a response without\n  delegation, we recommend instantiating and returning a concrete\n  response instance.  Diactoros provides a number of convenient custom responses .  For middleware delegating to another layer, operate on the  returned \n  response instead:   $response = $next($request, $response);\nreturn $response->withHeader('X-Foo', 'Bar');",
            "title": "$response argument"
        },
        {
            "location": "/v2/api/#delegate-invocation",
            "text": "When invoked as a  DelegateInterface , the  process()  method will be invoked, and\npassed a  ServerRequestInterface  instance  only . If you need to return a response,\nyou will need to:   Compose a response prototype in the middleware to use to build a response, or a\n  canned response to return, OR  Create and return a concrete response type, OR  Operate on a response returned by invoking the delegate.",
            "title": "Delegate invocation"
        },
        {
            "location": "/v2/api/#providing-an-altered-request",
            "text": "// Standard invokable:\nfunction ($request, $response, $next) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n    return $next(\n        $request->withBodyParams($bodyParams), // Next will pass the new\n        $response                              // request instance\n    );\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Delegate will receive the new request instance:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}",
            "title": "Providing an altered request:"
        },
        {
            "location": "/v2/api/#providing-an-altered-request-and-operating-on-the-returned-response",
            "text": "function ($request, $response, $next) use ($bodyParser)\n{\n    $response = $next(\n        $request->withBodyParams($bodyParser($request)),\n        $response\n    );\n\n    return $response->withAddedHeader('Cache-Control', [\n}\n\n// http-interop invokable:\nfunction ($request, DelegateInterface $delegate) use ($bodyParser)\n{\n    $bodyParams = $bodyParser($request);\n\n    // Provide a new request instance to the delegate:\n    return $delegate->process(\n        $request->withBodyParams($bodyParams)\n    );\n}",
            "title": "Providing an altered request and operating on the returned response:"
        },
        {
            "location": "/v2/api/#returning-a-response-to-complete-the-request",
            "text": "If your middleware does not need to delegate to another layer, it's time to\nreturn a response.  While we pass a response when using  Next  as a functor, we recommend creating\na new response, or providing your middleware with a response prototype; this\nwill ensure that the response is specific for your context.  $prototype = new Response();\n\n// Standard invokable signature:\nfunction ($request, $response, $next) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n\n    return $response;\n}\n\n// http-interop invokable signature:\nfunction ($request, DelegateInterface $delegate) use ($prototype)\n{\n    $response = $prototype->withAddedHeader('Cache-Control', [\n        'public',\n        'max-age=18600',\n        's-maxage=18600',\n    ]);\n}",
            "title": "Returning a response to complete the request"
        },
        {
            "location": "/v2/api/#delegation",
            "text": "If your middleware is not capable of returning a response, or a particular path\nin the middleware cannot return a response, return the result of executing the\ndelegate.  If using the legacy middleware signature, invoke the  $next  argument:  return $next($request, $response);  If using a  DelegateInterface , invoke its  process()  method:  return $delegate->process($request);  Middleware should always return a response, and, if it cannot, return the\nresult of delegation.",
            "title": "Delegation"
        },
        {
            "location": "/v2/api/#raising-an-error-condition",
            "text": "If your middleware cannot complete \u2014 perhaps a database error occurred, a\nservice was unreachable, etc. \u2014 how can you report the error?  Raise an exception!  function ($request, $response, $next) use ($service)\n{\n    $result = $service->fetchSomething();\n    if (! $result->isSuccess()) {\n        throw new RuntimeException('Error fetching something');\n    }\n\n    /* ... otherwise, complete the request ... */\n}  Use the  ErrorHandler middleware \nto handle exceptions thrown by your middleware and report the error condition to\nyour users.",
            "title": "Raising an error condition"
        },
        {
            "location": "/v2/api/#middleware_1",
            "text": "Stratigility provides several concrete middleware implementations.",
            "title": "Middleware"
        },
        {
            "location": "/v2/api/#errorhandler-and-notfoundhandler",
            "text": "These two middleware allow you to provide handle PHP errors and exceptions, and\n404 conditions, respectively. You may read more about them in the error handling chapter .",
            "title": "ErrorHandler and NotFoundHandler"
        },
        {
            "location": "/v2/api/#originalmessages",
            "text": "This callable middleware can be used as the outermost layer of middleware in\norder to set the original request, URI, and response instances as request\nattributes for inner layers. See the  migration chapter \nfor more details.",
            "title": "OriginalMessages"
        },
        {
            "location": "/v2/api/#middleware-decorators",
            "text": "Within  MiddlewarePipe , if a response prototype is composed, callable\nmiddleware piped to the instance will be wrapped in a decorator.  Two versions exist:   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  using the legacy interface; as such, it also requires a response instance:   $middleware = new CallableMiddlewareWrapper($middleware, $response);   Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  will wrap a callable\n  that defines exactly two arguments, with the second type-hinting on the\n  http-interop/http-middleware  DelegateInterface :   $middleware = new CallableMiddlewareWrapper(\n  function ($request, DelegateInterface $delegate) {\n      // ...\n  }\n);  You can manually decorate callable middleware using these decorators, or simply\nlet  MiddlewarePipe  do the work for you. To let  MiddlewarePipe  handle this,\nhowever, you  must  compose a response prototype prior to piping middleware\nusing the legacy middleware signature.",
            "title": "Middleware Decorators"
        },
        {
            "location": "/v2/api/#delegates",
            "text": "In addition to  Zend\\Stratigility\\Next , Stratigility provides another\nhttp-interop/http-middleware  DelegateInterface  implementation, Zend\\Stratigility\\Delegate\\CallableDelegateDecorator .  This class can be used to wrap a callable  $next  instance for use in passing to\nan http-interop/http-middleware middleware interface  process()  method as a\ndelegate; the primary use case is adapting functor middleware to work as\nhttp-interop middleware.  As an example:  // http-interop/http-middleware 0.2:\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n// http-interop/http-middleware 0.4.1:\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass TimestampMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(\n        ServerRequestInterface $request,\n        DelegateInterface $delegate\n    ) {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Processed-Timestamp', time());\n    }\n}",
            "title": "Delegates"
        },
        {
            "location": "/v2/migration/",
            "text": "Migrating to version 2\n\n\nVersion 2 of Stratigility makes several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.\n\n\nTo help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.\n\n\nOriginal request, response, and URI\n\n\nIn the original 1.X releases, Stratigility would decorate the request and\nresponse instances with \nZend\\Stratigility\\Http\\Request\n and\n\nZend\\Stratigility\\Http\\Response\n, respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated (\nNext\n truncates matched paths when executing a layer\nif a path was provided when piping the middleware).\n\n\nInternally, prior to 1.3, only \nZend\\Stratigility\\FinalHandler\n was still using\nthis functionality:\n\n\n\n\nIt would query the original request to get the original URI when creating a\n  404 response message.\n\n\nIt passes the decorated request and response instances to \nonerror\n handlers.\n\n\n\n\nStarting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.\n\n\nIf you still need access to the original request, response, or URI instance, we\nrecommend the following:\n\n\n\n\nPipe \nZend\\Stratigility\\Middleware\\OriginalMessages\n as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:\n\n\noriginalRequest\n, mapping to the request provided to it at invocation.\n\n\noriginalResponse\n, mapping to the response provided to it at invocation.\n\n\noriginalUri\n, mapping to the URI composed by the request provided to it at\n  invocation.\n\n\n\n\n\n\n\n\nYou can then access these values within other middleware:\n\n\n$originalRequest = $request->getAttribute('originalRequest');\n$originalResponse = $request->getAttribute('originalResponse');\n$originalUri = $request->getAttribute('originalUri');\n\n\n\nInternally, starting with 1.3.0, we have updated the request decorator to add\nthe \noriginalRequest\n attribute, and the \nFinalHandler\n to check for this,\ninstead of the decorated instance.\n\n\nFinally, if you are creating an \nonerror\n handler for the \nFinalHandler\n, update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.\n\n\nThe \nZend\\Stratigility\\Http\n classes, interfaces, and namespace are removed\nin version 2.0.0.\n\n\nError handling\n\n\nPrior to version 1.3, the recommended way to handle errors was via\n\nerror middleware\n, special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the \nNext\n implementation when the middleware stack is exhausted,\nbut no response has been returned.\n\n\nThese approaches, however, have several shortcomings:\n\n\n\n\nNo other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls \n$next()\n with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.\n\n\nThe \nFinalHandler\n implementation hits edge cases when empty responses are\n  intended.\n\n\nNeither combination works well with error or exception handlers.\n\n\n\n\nStarting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.\n\n\nThe first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the \nMiddlewarePipe::raiseThrowables()\n method:\n\n\n$pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();\n\n\n\nOnce you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:\n\n\n\n\nNotFoundHandler middleware\n\n\nErrorHandler middleware\n\n\nZend\\Stratigility\\NoopFinalHandler\n (see next section)\n\n\n\n\nUpdating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.\n\n\nNo-op final handler\n\n\nWhen using the \nNotFoundHandler\n and \nErrorHandler\n middleware (or custom\nmiddleware you drop in place of them), the \nFinalHandler\n implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.\n\n\nHowever, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form of\n\"final\" handler that can do so. (In fact, starting in version 2, the \n$out\n\nargument is renamed to \n$delegate\n, and is a \nrequired\n argument of the\n\nMiddlewarePipe\n.)\n\n\nStarting in version 1.3, we now offer a \nZend\\Stratigility\\NoopFinalHandler\n\nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:\n\n\n\n\nBy passing it explicitly when invoking the middleware pipeline.\n\n\nBy passing it to \nZend\\Diactoros\\Server::listen()\n.\n\n\n\n\nIf you are not using \nZend\\Diactoros\\Server\n to execute your application, but\ninstead invoking your pipeline manually, use the following:\n\n\n$response = $app($request, $response, new NoopFinalHandler());\n\n\n\nIf you are using \nZend\\Diactoros\\Server\n, you will need to pass the final\nhandler you wish to use as an argument to the \nlisten()\n method; that method\nwill then pass that value as the third argument to \nMiddlewarePipe\n as shown\nabove:\n\n\n$server->listen(new NoopFinalHandler());\n\n\n\nBoth approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.\n\n\n(You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)\n\n\nTo summarize:\n\n\n\n\nCall the \nraiseThrowables()\n method of your \nMiddlewarePipe\n instance to\n  opt-in to the new error handling strategy.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\NotFoundHandler\n as the innermost\n  layer of your application pipeline in order to provide 404 responses.\n\n\nUse the new \nZend\\Stratigility\\Middleware\\ErrorHandler\n middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.\n\n\nUse the \nZend\\Stratigility\\NoopFinalHandler\n as the \n$out\n argument when\n  dispatching your application pipeline.\n\n\n\n\nhttp-interop compatibility\n\n\nhttp-middleware 0.2.0 and Stratigility 1.3\n\n\nStarting in version 1.3.0, we offer compatibility with\n\nhttp-interop/http-middleware 0.2.0\n.\nThat version of the specification defines the following interfaces:\n\n\nnamespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\n\n\nThe support in version 1.3.0 consists of the following:\n\n\n\n\nMiddlewarePipe\n now also implements \nServerMiddlewareInterface\n, and allows\n  piping either type of http-interop middleware.\n\n\nNext\n now also implements \nDelegateInterface\n.\n\n\nDispatch\n is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.\n\n\n\n\nAdditionally, \nMiddlewarePipe\n will now allow composing a \nresponse prototype\n;\nthis is a PSR-7 \nResponseInterface\n instance. If not set, the first time the\npipeline is invoked via its \n__invoke()\n method, it will set the prototype from\nthe provided \n$response\n argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.\n\n\nhttp-middleware 0.4.1 and Stratigility 2.0\n\n\nhttp-interop/http-middleware 0.4.1 introduces breaking changes in the\ninterfaces, including the following:\n\n\n\n\n\n\nThe namespace changes from \nInterop\\Http\\Middleware\n to\n  \nInterop\\Http\\ServerMiddleware\n, signaling a change indicating that the project\n  now only targets server-side middleware.\n\n\n\n\n\n\nThe interface \nServerMiddlewareInterface\n is now more simply\n  \nMiddlewareInterface\n, as the namespace indicates its usage in server-side\n  applications. \nInterop\\Http\\Middleware\\MiddlewareInterface\n, which targeted\n  client-side middleware, was removed entirely.\n\n\n\n\n\n\nThe method \nDelegateInterface::process\n now accepts specifically a\n  \nPsr\\Http\\Message\\ServerRequestInterface\n, and not the more general\n  \nRequestInterface\n.\n\n\n\n\n\n\nThe first two changes required only a change in import statements to\naccommodate, and could have been imported in parallel to the 0.2.0 interfaces.\nHowever, the second represents a signature change, which has necessitated a\nmajor version bump in Stratigility in order to remain compatible.\n\n\nStratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that\nversion (and compatible versions) only.\n\n\nAdditionally, starting in version 2.0.0, \nMiddlewarePipe\n \nwill no longer implement\n\nZend\\Stratigility\\MiddlewareInterface\n, and only implement the\nhttp-interop/http-middleware \nMiddlewareInterface\n. This has several\nrepercussions.\n\n\nCallable middleware in version 1.3.0\n\n\nCallable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.\n\n\nFirst, \nwe recommend \nnever\n using the \n$response\n argument provided to\nmiddleware.\n\n\nThe reason for this recommendation is two-fold. First, the http-interop/http-middleware\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.\n\n\nAs an example, consider the following:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return $next($request, $response->withHeader('X-Foo', 'Bar'));\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});\n\n\n\nThe first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware, \ncreates and returns an entirely new response\n,\nmaking the new header disappear.\n\n\nAs such, we recommend rewriting such middleware to modify the \nreturned\n\nresponse instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response->withHeader('X-Foo', 'Bar');\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});\n\n\n\nThe above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.\n\n\nSecond, either wrap your middleware in \nCallableMiddlewareWrapper\n, or ensure\nyour pipeline composes a \nresponse prototype\n (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop/http-middleware delegators.\n\n\nuse Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-middleware:\n$pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline->setResponsePrototype($response);\n$pipeline->pipe($middleware);\n\n\n\n\n\nCallableMiddlewareWrapper and Stratigility 2.0\n\n\nAs noted above, version 2 of Stratigility is incompatible with version 1.3 due\nto signature changes in the http-middleware project. However, if you wrap your\ncallable middleware using \nCallableMiddlewareWrapper\n, you will need to make\nno changes in your application to make it forwards compatible.\n\n\nWe recommend using this strategy if you need to do a stepped transition to\nStratigility 2.0.\n\n\n\n\nThird, and optionally, you can make one or both of the following changes to\nyour callable middleware:\n\n\n\n\nTypehint the final \n$next\n argument against \nInterop\\Http\\Middleware\\DelegateInterface\n;\n  optionally, rename it to \n$delegate\n. This will require a slight change to\n  how you invoke the next layer as well; see below.\n\n\nRemove the \n$response\n argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.\n\n\n\n\nAs an example of the first:\n\n\nfunction ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}\n\n\n\nAs an example of adopting both practices:\n\n\nfunction ($request, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}\n\n\n\nAt this point, you have essentially implemented \nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n\n(with the notable exception of not type-hinting the \n$request\n argument).\nWhen you pipe such callable middleware to \nMiddlewarePipeline\n, it will be\nwrapped in a \nZend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper\n,\nwhich simply proxies to the middleware when processed.\n\n\n\n\nDelegateInterface and Stratigility 2.0\n\n\nSince the namespace within http-interop/http-middleware changes between\nversion 0.2.0 and 0.4.1, the above strategy will require making changes\nmultiple times: once when upgrading to Stratigility 1.3, and another when\nupgrading to 2.0. As such, we recommend instead decorating your callable\nmiddleware using the \nCallableMiddlewareWrapper\n, until such time as you can\nrewrite your middleware to implement the http-middleware 0.4.1 interfaces.\n\n\n\n\nFinally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop/http-middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.\n\n\nAs an example, consider the following middleware class:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nThis could be rewritten as follows:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nIf we were dealing with callable middleware instead:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});\n\n\n\nwe could wrap this in an anonymous class instead:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n});\n\n\n\n\n\nUsing anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.\n\n\n\n\nIf you want your middleware to work with either http-interop/http-middleware or\nwith the pre-1.3.0 middleware signature, you can do that as well. To accomplish\nthis, we provide \nZend\\Stratigility\\Delegate\\CallableDelegateDecorator\n, which\nwill wrap a \ncallable $next\n such that it may be used as a \nDelegateInterface\n\nimplementation:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\n\n\nImplementing http-interop between Stratigility 1.3 and 2.0\n\n\nWhile you \ncan\n write your middleware to implement the\nhttp-interop/http-middleware middleware interface, please be aware that if you\ndo so, you will need to take additional steps when upgrading from 1.3 to 2.0.\n\n\nIn most cases, you should be able to simply change the import statements\nwithin your class file. As an example, if you have the following in your\nStratigility 1.3-based project:\n\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\n\n\n\nThe imports would become:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;\n\n\n\n\n\nTo summarize:\n\n\n\n\n\n\nNever work with the provided \n$response\n argument, but instead manipulate the\n  response returned from calling \n$next\n.\n\n\n\n\n\n\nEnsure your pipeline can decorate callable middleware as http-interop/http-middleware.\n  Do this by injecting a response prototype in the pipeline prior to piping any\n  middleware. (\nNote: this is not necessary if all callable middleware defines\n  exactly two parameters, with the second type-hinting on the http-interop\n  \nDelegateInterface\n.)\n\n\n\n\n\n\nConsider adapting your callable middleware to follow the http-interop middleware\n  signature (\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n);\n  this will make it forward-compatible. (Be aware that this may require changes\n  in import statements between Stratigility 1.3 and 2.0.)\n\n\n\n\n\n\nConsider updating your class-based middleware to implement the\n  http-interop/http-middleware server middleware interface, potentially keeping\n  the \n__invoke()\n method for interoperability with existing callable-based\n  middleware runners. (Be aware that this may require changes in import\n  statements between Stratigility\n  1.3 and 2.0.)\n\n\n\n\n\n\nThe first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-middleware, and to ensure your middleware works\nproperly across middleware stacks.\n\n\nCallable middleware in version 2.0.0\n\n\nCallable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:\n\n\n\n\n\n\nInject a \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory\n\n  instance via the pipeline's \nsetCallableMiddlewareDecorator()\n method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a \nResponseInterface\n in its constructor, and will use that\n  response when creating \nCallableMiddlewareWrapper\n instances.\n\n\n$factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline->setCallableMiddlewareDecorator($factory);\n\n\n\n\n\n\n\nPass a response prototype before piping the callable middleware. If no\n  \nCallableMiddlewareWrapperFactory\n is present, this prototype will be\n  used to seed one for use with decorating callable middleware.\n\n\n$pipeline->setResponsePrototype(new Response());\n\n\n\n\n\n\n\nManually decorate your middleware prior to passing it to the pipeline:\n\n\n$pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-middleware signature already.\n\n\n\n\n\n\n\nInvoking MiddlewarePipe instances in version 2.0.0\n\n\nInvocation of the outermost middleware can now be done in two ways:\n\n\n\n\nUsing \n__invoke()\n. This now requires a third argument, \n$delegate\n, which\n  may be one of a \ncallable\n accepting \nServerRequestInterface\n and \nResponseInterface\n\n  arguments, or a \nDelegateInterface\n instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the \nMiddlewarePipe\n's internal queue is exhausted without returning\n  a response, and \nmust\n return a response itself. A good candidate for this\n  is the \nNoopFinalHandler\n.\n\n\nUsing \nprocess()\n. This argument requires a request and \nDelegateInterface\n\n  instance; again, the \nDelegateInterface\n instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.\n\n\n\n\nAs examples:\n\n\nuse Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline->process($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));\n\n\n\nOnce you have done so, you can process the returned request via an\n\nemitter\n.\n\n\nDeprecated functionality\n\n\nThe following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\Dispatch\n (class); this class is marked internal already,\n  but anybody extending \nNext\n and/or this class should be aware of its removal.\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (interface); error middleware\n  should now be implemented per the \nerror handling section above\n.\n\n\nThe \n$response\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n  \nCallableMiddlewareWrapper\n also ensures that a response argument is populated\n  and present when invoking callable middleware.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an \nE_USER_DEPRECATED\n notice, referencing this documentation.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\n\n\nInterface/signature changes\n\n\nThe following signature changes were made with the 2.0.0 release:\n\n\n\n\nZend\\Stratigility\\Next\n:\n\n\nThe \n$done\n constructor argument was renamed to \n$nextDelegate\n, and now\n    allows either \ncallable\n or \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n\n    arguments.\n\n\nThe \n$response\n argument to \n__invoke()\n was removed.\n\n\nThe (optional) \n$err\n argument to \n__invoke()\n was removed.\n\n\n\n\nRemoved functionality\n\n\nThe following classes, methods, and arguments are removed starting in version\n2.0.0.\n\n\n\n\nZend\\Stratigility\\Dispatch\n (class)\n\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n (class)\n\n\nZend\\Stratigility\\FinalHandler\n (class)\n\n\nZend\\Stratigility\\MiddlewareInterface\n. Define your middleware as callables,\n  or using http-interop/http-middleware interfaces instead.\n\n\nZend\\Stratigility\\Utils::getArity()\n (static method); no longer used\n  internally.\n\n\nThe \n$err\n argument to \nZend\\Stratigility\\Next\n's \n__invoke()\n method. If\n  passed, it will now be ignored.\n\n\nZend\\Stratigility\\Http\\Request\n (class)\n\n\nZend\\Stratigility\\Http\\ResponseInterface\n (interface)\n\n\nZend\\Stratigility\\Http\\Response\n (class)\n\n\nThe \n$response\n argument to middleware is deprecated; please see the\n  \nsection on callable middleware\n\n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop/http-middleware interface.",
            "title": "Migration"
        },
        {
            "location": "/v2/migration/#migrating-to-version-2",
            "text": "Version 2 of Stratigility makes several breaking changes to the API in\norder to provide more flexibility, promote interoperability, and reduce\ncomplexity.  To help you prepare your code for version 2, version 1.3.0 provides several\nforwards compatibility features to assist you in the process. However, some\nchanges will still require changes to your code following the 2.0 release.",
            "title": "Migrating to version 2"
        },
        {
            "location": "/v2/migration/#original-request-response-and-uri",
            "text": "In the original 1.X releases, Stratigility would decorate the request and\nresponse instances with  Zend\\Stratigility\\Http\\Request  and Zend\\Stratigility\\Http\\Response , respectively. This was done to facilitate\naccess to the incoming request in cases of nested layers, where the URI path\nmay have been truncated ( Next  truncates matched paths when executing a layer\nif a path was provided when piping the middleware).  Internally, prior to 1.3, only  Zend\\Stratigility\\FinalHandler  was still using\nthis functionality:   It would query the original request to get the original URI when creating a\n  404 response message.  It passes the decorated request and response instances to  onerror  handlers.   Starting with 1.3.0, we now deprecate these message decorators, and recommend\nagainst their usage.  If you still need access to the original request, response, or URI instance, we\nrecommend the following:   Pipe  Zend\\Stratigility\\Middleware\\OriginalMessages  as the outermost layer of\n  your application. This will inject the following request attributes into\n  layers beneath it:  originalRequest , mapping to the request provided to it at invocation.  originalResponse , mapping to the response provided to it at invocation.  originalUri , mapping to the URI composed by the request provided to it at\n  invocation.     You can then access these values within other middleware:  $originalRequest = $request->getAttribute('originalRequest');\n$originalResponse = $request->getAttribute('originalResponse');\n$originalUri = $request->getAttribute('originalUri');  Internally, starting with 1.3.0, we have updated the request decorator to add\nthe  originalRequest  attribute, and the  FinalHandler  to check for this,\ninstead of the decorated instance.  Finally, if you are creating an  onerror  handler for the  FinalHandler , update\nyour typehints to refer to the PSR-7 request and response interfaces instead of\nthe Stratigility decorators, if you aren't already.  The  Zend\\Stratigility\\Http  classes, interfaces, and namespace are removed\nin version 2.0.0.",
            "title": "Original request, response, and URI"
        },
        {
            "location": "/v2/migration/#error-handling",
            "text": "Prior to version 1.3, the recommended way to handle errors was via error middleware , special\nmiddleware that accepts an additional initial argument representing an error. On\ntop of this, we provide the concept of a \"final handler\", pseudo-middleware that\nis executed by the  Next  implementation when the middleware stack is exhausted,\nbut no response has been returned.  These approaches, however, have several shortcomings:   No other middleware frameworks implement the error middleware feature, which\n  means any middleware that calls  $next()  with the error argument will not\n  work in those other systems, and error middleware written for Stratigility\n  cannot be composed in other systems.  The  FinalHandler  implementation hits edge cases when empty responses are\n  intended.  Neither combination works well with error or exception handlers.   Starting in 1.3, we are promoting using standard middleware layers as error\nhandlers, instead of using the existing error middleware/final handler system.  The first step is to opt-in to having throwables and exceptions raised by\nmiddleware, instead of having the dispatcher catch them and then invoke\nmiddleware. Do this via the  MiddlewarePipe::raiseThrowables()  method:  $pipeline = new MiddlewarePipe();\n$pipeline->raiseThrowables();  Once you have done that you may start using some of the new functionality, as\nwell as augmented existing functionality:   NotFoundHandler middleware  ErrorHandler middleware  Zend\\Stratigility\\NoopFinalHandler  (see next section)   Updating your application to use these features will ensure you are forwards\ncompatible with version 2 releases.",
            "title": "Error handling"
        },
        {
            "location": "/v2/migration/#no-op-final-handler",
            "text": "When using the  NotFoundHandler  and  ErrorHandler  middleware (or custom\nmiddleware you drop in place of them), the  FinalHandler  implementation loses\nmost of its meaning, as you are now handling errors and 404 conditions as\nmiddleware layers.  However, you still need to ensure that the pipeline returns a response,\nregardless of how the pipeline is setup, and for that we still need some form of\n\"final\" handler that can do so. (In fact, starting in version 2, the  $out \nargument is renamed to  $delegate , and is a  required  argument of the MiddlewarePipe .)  Starting in version 1.3, we now offer a  Zend\\Stratigility\\NoopFinalHandler \nimplementation, which simply returns the response passed to it. You can compose\nit in your application in one of two ways:   By passing it explicitly when invoking the middleware pipeline.  By passing it to  Zend\\Diactoros\\Server::listen() .   If you are not using  Zend\\Diactoros\\Server  to execute your application, but\ninstead invoking your pipeline manually, use the following:  $response = $app($request, $response, new NoopFinalHandler());  If you are using  Zend\\Diactoros\\Server , you will need to pass the final\nhandler you wish to use as an argument to the  listen()  method; that method\nwill then pass that value as the third argument to  MiddlewarePipe  as shown\nabove:  $server->listen(new NoopFinalHandler());  Both approaches above are fully forwards compatible with version 2, and will\nwork in all version 1 releases as well.  (You can also compose your own custom final handler; it only needs to accept a\nrequest and a response, and be guaranteed to return a response instance.)  To summarize:   Call the  raiseThrowables()  method of your  MiddlewarePipe  instance to\n  opt-in to the new error handling strategy.  Use the new  Zend\\Stratigility\\Middleware\\NotFoundHandler  as the innermost\n  layer of your application pipeline in order to provide 404 responses.  Use the new  Zend\\Stratigility\\Middleware\\ErrorHandler  middleware as the\n  outermost (or close to outermost) layer of your application pipeline in order\n  to handle exceptions.  Use the  Zend\\Stratigility\\NoopFinalHandler  as the  $out  argument when\n  dispatching your application pipeline.",
            "title": "No-op final handler"
        },
        {
            "location": "/v2/migration/#http-interop-compatibility",
            "text": "",
            "title": "http-interop compatibility"
        },
        {
            "location": "/v2/migration/#http-middleware-020-and-stratigility-13",
            "text": "Starting in version 1.3.0, we offer compatibility with http-interop/http-middleware 0.2.0 .\nThat version of the specification defines the following interfaces:  namespace Interop\\Http\\Middleware;\n\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface DelegateInterface\n{\n    public function process(RequestInterface $request) : ResponseInterface;\n}\n\ninterface MiddlewareInterface\n{\n    public function process(RequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}\n\ninterface ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate) : ResponseInterface;\n}  The support in version 1.3.0 consists of the following:   MiddlewarePipe  now also implements  ServerMiddlewareInterface , and allows\n  piping either type of http-interop middleware.  Next  now also implements  DelegateInterface .  Dispatch  is now capable of dispatching either http-interop middleware type,\n  in addition to legacy callable middleware.   Additionally,  MiddlewarePipe  will now allow composing a  response prototype ;\nthis is a PSR-7  ResponseInterface  instance. If not set, the first time the\npipeline is invoked via its  __invoke()  method, it will set the prototype from\nthe provided  $response  argument. When present, any callable, non-error\nmiddleware piped to the pipeline will be wrapped in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper  instance, which\nconverts it into an http-interop middleware type; when processed, the response\nprototype will be passed to the callable for the response argument.",
            "title": "http-middleware 0.2.0 and Stratigility 1.3"
        },
        {
            "location": "/v2/migration/#http-middleware-041-and-stratigility-20",
            "text": "http-interop/http-middleware 0.4.1 introduces breaking changes in the\ninterfaces, including the following:    The namespace changes from  Interop\\Http\\Middleware  to\n   Interop\\Http\\ServerMiddleware , signaling a change indicating that the project\n  now only targets server-side middleware.    The interface  ServerMiddlewareInterface  is now more simply\n   MiddlewareInterface , as the namespace indicates its usage in server-side\n  applications.  Interop\\Http\\Middleware\\MiddlewareInterface , which targeted\n  client-side middleware, was removed entirely.    The method  DelegateInterface::process  now accepts specifically a\n   Psr\\Http\\Message\\ServerRequestInterface , and not the more general\n   RequestInterface .    The first two changes required only a change in import statements to\naccommodate, and could have been imported in parallel to the 0.2.0 interfaces.\nHowever, the second represents a signature change, which has necessitated a\nmajor version bump in Stratigility in order to remain compatible.  Stratigility 2.0.0 therefor targets http-interop/http-middleware 0.4.1, and that\nversion (and compatible versions) only.  Additionally, starting in version 2.0.0,  MiddlewarePipe   will no longer implement Zend\\Stratigility\\MiddlewareInterface , and only implement the\nhttp-interop/http-middleware  MiddlewareInterface . This has several\nrepercussions.",
            "title": "http-middleware 0.4.1 and Stratigility 2.0"
        },
        {
            "location": "/v2/migration/#callable-middleware-in-version-130",
            "text": "Callable middleware can be used without change in version 1.3.0. However, we\nrecommend updating your code to prepare for version 2.0.0.  First,  we recommend  never  using the  $response  argument provided to\nmiddleware.  The reason for this recommendation is two-fold. First, the http-interop/http-middleware\ninterfaces do not provide it, and, as such, using it within your middleware\nmakes your middleware incompatible. Second, and more importantly, is due to the\nreason why http-interop does not include the argument: usage can lead to\ninconsistent and/or unexpected results.  As an example, consider the following:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return $next($request, $response->withHeader('X-Foo', 'Bar'));\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});  The first, outer layer of middleware sets a response header. However, the\nsecond, inner middleware,  creates and returns an entirely new response ,\nmaking the new header disappear.  As such, we recommend rewriting such middleware to modify the  returned \nresponse instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response->withHeader('X-Foo', 'Bar');\n});\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});  The above will have the expected result for whatever middleware is nested\nbeneath it, as it will operate on the returned response, and have consistent\nresults.  Second, either wrap your middleware in  CallableMiddlewareWrapper , or ensure\nyour pipeline composes a  response prototype  (doing so will implicitly\ndecorate callable middleware). Either of these will ensure your middleware will\nwork with http-interop/http-middleware delegators.  use Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper;\n\n// Manually decorating callable middleware for use with http-middleware:\n$pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n\n// Auto-decorate middleware by providing a response prototype:\n$pipeline->setResponsePrototype($response);\n$pipeline->pipe($middleware);",
            "title": "Callable middleware in version 1.3.0"
        },
        {
            "location": "/v2/migration/#callablemiddlewarewrapper-and-stratigility-20",
            "text": "As noted above, version 2 of Stratigility is incompatible with version 1.3 due\nto signature changes in the http-middleware project. However, if you wrap your\ncallable middleware using  CallableMiddlewareWrapper , you will need to make\nno changes in your application to make it forwards compatible.  We recommend using this strategy if you need to do a stepped transition to\nStratigility 2.0.   Third, and optionally, you can make one or both of the following changes to\nyour callable middleware:   Typehint the final  $next  argument against  Interop\\Http\\Middleware\\DelegateInterface ;\n  optionally, rename it to  $delegate . This will require a slight change to\n  how you invoke the next layer as well; see below.  Remove the  $response  argument from your signature; if you do, make sure you\n  typehint the delegate argument, and make it required.   As an example of the first:  function ($request, $response, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}  As an example of adopting both practices:  function ($request, DelegateInterface $delegate) {\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Foo', 'Bar');\n}  At this point, you have essentially implemented  Interop\\Http\\Middleware\\ServerMiddlewareInterface \n(with the notable exception of not type-hinting the  $request  argument).\nWhen you pipe such callable middleware to  MiddlewarePipeline , it will be\nwrapped in a  Zend\\Stratigility\\Middleware\\CallableInteropMiddlewareWrapper ,\nwhich simply proxies to the middleware when processed.",
            "title": "CallableMiddlewareWrapper and Stratigility 2.0"
        },
        {
            "location": "/v2/migration/#delegateinterface-and-stratigility-20",
            "text": "Since the namespace within http-interop/http-middleware changes between\nversion 0.2.0 and 0.4.1, the above strategy will require making changes\nmultiple times: once when upgrading to Stratigility 1.3, and another when\nupgrading to 2.0. As such, we recommend instead decorating your callable\nmiddleware using the  CallableMiddlewareWrapper , until such time as you can\nrewrite your middleware to implement the http-middleware 0.4.1 interfaces.   Finally, if you are so inclined, you can rewrite your middleware to\nspecifically implement one or the other of the http-interop/http-middleware\ninterfaces. This is particularly relevant for class-based middleware, but can\nalso be accomplished by using PHP 7 anonymous classes.  As an example, consider the following middleware class:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  This could be rewritten as follows:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  If we were dealing with callable middleware instead:  use Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(function ($request, $response, $next) {\n    return new JsonResponse(['ack' => time()]);\n});  we could wrap this in an anonymous class instead:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\n$pipeline->pipe(new class implements ServerMiddlewareInterface {\n    public function (ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n});   Using anonymous classes is likely overkill, as both v1.3.0 and v2.0.0 support\npiping closures.   If you want your middleware to work with either http-interop/http-middleware or\nwith the pre-1.3.0 middleware signature, you can do that as well. To accomplish\nthis, we provide  Zend\\Stratigility\\Delegate\\CallableDelegateDecorator , which\nwill wrap a  callable $next  such that it may be used as a  DelegateInterface \nimplementation:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\nclass PingMiddleware implements ServerMiddlewareInterface\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        return $this->process($request, new CallableDelegateDecorator($next, $response));\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}",
            "title": "DelegateInterface and Stratigility 2.0"
        },
        {
            "location": "/v2/migration/#implementing-http-interop-between-stratigility-13-and-20",
            "text": "While you  can  write your middleware to implement the\nhttp-interop/http-middleware middleware interface, please be aware that if you\ndo so, you will need to take additional steps when upgrading from 1.3 to 2.0.  In most cases, you should be able to simply change the import statements\nwithin your class file. As an example, if you have the following in your\nStratigility 1.3-based project:  use Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;  The imports would become:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface as ServerMiddlewareInterface;   To summarize:    Never work with the provided  $response  argument, but instead manipulate the\n  response returned from calling  $next .    Ensure your pipeline can decorate callable middleware as http-interop/http-middleware.\n  Do this by injecting a response prototype in the pipeline prior to piping any\n  middleware. ( Note: this is not necessary if all callable middleware defines\n  exactly two parameters, with the second type-hinting on the http-interop\n   DelegateInterface .)    Consider adapting your callable middleware to follow the http-interop middleware\n  signature ( function (ServerRequestInterface $request, DelegateInterface $delegate) );\n  this will make it forward-compatible. (Be aware that this may require changes\n  in import statements between Stratigility 1.3 and 2.0.)    Consider updating your class-based middleware to implement the\n  http-interop/http-middleware server middleware interface, potentially keeping\n  the  __invoke()  method for interoperability with existing callable-based\n  middleware runners. (Be aware that this may require changes in import\n  statements between Stratigility\n  1.3 and 2.0.)    The first and last suggestions in this list are strongly recommended to ensure\nforwards compatibility with http-middleware, and to ensure your middleware works\nproperly across middleware stacks.",
            "title": "Implementing http-interop between Stratigility 1.3 and 2.0"
        },
        {
            "location": "/v2/migration/#callable-middleware-in-version-200",
            "text": "Callable middleware may still be used; however, in order to pipe it to the\npipeline, you must do one of the following:    Inject a  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapperFactory \n  instance via the pipeline's  setCallableMiddlewareDecorator()  method,\n  prior to piping callable middleware to the instance. This factory class\n  requires a  ResponseInterface  in its constructor, and will use that\n  response when creating  CallableMiddlewareWrapper  instances.  $factory = new CallableMiddlewareWrapperFactory(new Response());\n$pipeline->setCallableMiddlewareDecorator($factory);    Pass a response prototype before piping the callable middleware. If no\n   CallableMiddlewareWrapperFactory  is present, this prototype will be\n  used to seed one for use with decorating callable middleware.  $pipeline->setResponsePrototype(new Response());    Manually decorate your middleware prior to passing it to the pipeline:  $pipeline->pipe(new CallableMiddlewareWrapper($middleware, $response));\n// or CallableInteropMiddlewareWrapper, if your middleware implements\n// the http-middleware signature already.",
            "title": "Callable middleware in version 2.0.0"
        },
        {
            "location": "/v2/migration/#invoking-middlewarepipe-instances-in-version-200",
            "text": "Invocation of the outermost middleware can now be done in two ways:   Using  __invoke() . This now requires a third argument,  $delegate , which\n  may be one of a  callable  accepting  ServerRequestInterface  and  ResponseInterface \n  arguments, or a  DelegateInterface  instance (the former will be decorated\n  as the latter, binding the response instance). This will be invoked only\n  if the  MiddlewarePipe 's internal queue is exhausted without returning\n  a response, and  must  return a response itself. A good candidate for this\n  is the  NoopFinalHandler .  Using  process() . This argument requires a request and  DelegateInterface \n  instance; again, the  DelegateInterface  instance will only be invoked if\n  the pipeline's internal queue is exhausted without returning a response.   As examples:  use Zend\\Stratigility\\NoopFinalHandler;\nuse Zend\\Stratigility\\Delegate\\CallableDelegateDecorator;\n\n// Using __invoke():\n$response = $pipeline($request, $response, new NoopFinalHandler());\n\n// Using process():\n$response = $pipeline->process($request, new CallableDelegateDecorator(\n    new NoopFinalHandler(),\n    $response\n));  Once you have done so, you can process the returned request via an emitter .",
            "title": "Invoking MiddlewarePipe instances in version 2.0.0"
        },
        {
            "location": "/v2/migration/#deprecated-functionality",
            "text": "The following classes, methods, and arguments are deprecated starting in version\n1.3.0, and will be removed in version 2.0.0.   Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\Dispatch  (class); this class is marked internal already,\n  but anybody extending  Next  and/or this class should be aware of its removal.  Zend\\Stratigility\\ErrorMiddlewareInterface  (interface); error middleware\n  should now be implemented per the  error handling section above .  The  $response  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  The argument, and all following it, are ignored starting in 2.0.0; it is used\n  in 1.3.0 to ensure backwards compatibility with existing middleware. The\n   CallableMiddlewareWrapper  also ensures that a response argument is populated\n  and present when invoking callable middleware.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method.\n  Starting in 1.3.0, if a non-null value is encountered, this method will now\n  emit an  E_USER_DEPRECATED  notice, referencing this documentation.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)",
            "title": "Deprecated functionality"
        },
        {
            "location": "/v2/migration/#interfacesignature-changes",
            "text": "The following signature changes were made with the 2.0.0 release:   Zend\\Stratigility\\Next :  The  $done  constructor argument was renamed to  $nextDelegate , and now\n    allows either  callable  or  Interop\\Http\\ServerMiddleware\\DelegateInterface \n    arguments.  The  $response  argument to  __invoke()  was removed.  The (optional)  $err  argument to  __invoke()  was removed.",
            "title": "Interface/signature changes"
        },
        {
            "location": "/v2/migration/#removed-functionality",
            "text": "The following classes, methods, and arguments are removed starting in version\n2.0.0.   Zend\\Stratigility\\Dispatch  (class)  Zend\\Stratigility\\ErrorMiddlewareInterface  (class)  Zend\\Stratigility\\FinalHandler  (class)  Zend\\Stratigility\\MiddlewareInterface . Define your middleware as callables,\n  or using http-interop/http-middleware interfaces instead.  Zend\\Stratigility\\Utils::getArity()  (static method); no longer used\n  internally.  The  $err  argument to  Zend\\Stratigility\\Next 's  __invoke()  method. If\n  passed, it will now be ignored.  Zend\\Stratigility\\Http\\Request  (class)  Zend\\Stratigility\\Http\\ResponseInterface  (interface)  Zend\\Stratigility\\Http\\Response  (class)  The  $response  argument to middleware is deprecated; please see the\n   section on callable middleware \n  for details, and adapt your middleware to no longer use the argument.\n  While the legacy callable signature will continue to work, we recommend\n  implementing an http-interop/http-middleware interface.",
            "title": "Removed functionality"
        },
        {
            "location": "/install/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/install/';\n    window.location = uri.href;\n  });",
            "title": "_install"
        },
        {
            "location": "/usage/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/usage/';\n    window.location = uri.href;\n  });",
            "title": "_usage"
        },
        {
            "location": "/middleware/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/middleware/';\n    window.location = uri.href;\n  });",
            "title": "_middleware"
        },
        {
            "location": "/error-handlers/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/error-handlers/';\n    window.location = uri.href;\n  });",
            "title": "_error-handlers"
        },
        {
            "location": "/creating-middleware/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/creating-middleware/';\n    window.location = uri.href;\n  });",
            "title": "_creating-middleware"
        },
        {
            "location": "/executing-middleware/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/executing-middleware/';\n    window.location = uri.href;\n  });",
            "title": "_executing-middleware"
        },
        {
            "location": "/api/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/api/';\n    window.location = uri.href;\n  });",
            "title": "_api"
        },
        {
            "location": "/migration/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    var uri = new URL(window.location.href);\n    uri.pathname = '/zend-stratigility/v3/migration/';\n    window.location = uri.href;\n  });",
            "title": "_migration"
        }
    ]
}